
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model DatabaseChangeLog
 * 
 */
export type DatabaseChangeLog = $Result.DefaultSelection<Prisma.$DatabaseChangeLogPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model SystemPlanRestrictions
 * 
 */
export type SystemPlanRestrictions = $Result.DefaultSelection<Prisma.$SystemPlanRestrictionsPayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantSystemPlan
 * 
 */
export type TenantSystemPlan = $Result.DefaultSelection<Prisma.$TenantSystemPlanPayload>
/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model admin_log
 * 
 */
export type admin_log = $Result.DefaultSelection<Prisma.$admin_logPayload>
/**
 * Model campaign_categories
 * 
 */
export type campaign_categories = $Result.DefaultSelection<Prisma.$campaign_categoriesPayload>
/**
 * Model campaign_category_relations
 * 
 */
export type campaign_category_relations = $Result.DefaultSelection<Prisma.$campaign_category_relationsPayload>
/**
 * Model campaign_items
 * 
 */
export type campaign_items = $Result.DefaultSelection<Prisma.$campaign_itemsPayload>
/**
 * Model campaign_translations
 * 
 */
export type campaign_translations = $Result.DefaultSelection<Prisma.$campaign_translationsPayload>
/**
 * Model campaign_usage_logs
 * 
 */
export type campaign_usage_logs = $Result.DefaultSelection<Prisma.$campaign_usage_logsPayload>
/**
 * Model campaigns
 * 
 */
export type campaigns = $Result.DefaultSelection<Prisma.$campaignsPayload>
/**
 * Model customers
 * 
 */
export type customers = $Result.DefaultSelection<Prisma.$customersPayload>
/**
 * Model device_rooms
 * 
 */
export type device_rooms = $Result.DefaultSelection<Prisma.$device_roomsPayload>
/**
 * Model device_video_caches
 * 
 */
export type device_video_caches = $Result.DefaultSelection<Prisma.$device_video_cachesPayload>
/**
 * Model notification_templates
 * 
 */
export type notification_templates = $Result.DefaultSelection<Prisma.$notification_templatesPayload>
/**
 * Model page_histories
 * 
 */
export type page_histories = $Result.DefaultSelection<Prisma.$page_historiesPayload>
/**
 * Model pages
 * 
 */
export type pages = $Result.DefaultSelection<Prisma.$pagesPayload>
/**
 * Model reservations
 * 
 */
export type reservations = $Result.DefaultSelection<Prisma.$reservationsPayload>
/**
 * Model response_node_translations
 * 
 */
export type response_node_translations = $Result.DefaultSelection<Prisma.$response_node_translationsPayload>
/**
 * Model response_nodes
 * 
 */
export type response_nodes = $Result.DefaultSelection<Prisma.$response_nodesPayload>
/**
 * Model response_tree_history
 * 
 */
export type response_tree_history = $Result.DefaultSelection<Prisma.$response_tree_historyPayload>
/**
 * Model response_tree_mobile_links
 * 
 */
export type response_tree_mobile_links = $Result.DefaultSelection<Prisma.$response_tree_mobile_linksPayload>
/**
 * Model response_tree_sessions
 * 
 */
export type response_tree_sessions = $Result.DefaultSelection<Prisma.$response_tree_sessionsPayload>
/**
 * Model response_tree_versions
 * 
 */
export type response_tree_versions = $Result.DefaultSelection<Prisma.$response_tree_versionsPayload>
/**
 * Model response_trees
 * 
 */
export type response_trees = $Result.DefaultSelection<Prisma.$response_treesPayload>
/**
 * Model room_grades
 * 
 */
export type room_grades = $Result.DefaultSelection<Prisma.$room_gradesPayload>
/**
 * Model schema_version
 * 
 */
export type schema_version = $Result.DefaultSelection<Prisma.$schema_versionPayload>
/**
 * Model service_plan_restrictions
 * 
 */
export type service_plan_restrictions = $Result.DefaultSelection<Prisma.$service_plan_restrictionsPayload>
/**
 * Model service_usage_statistics
 * 
 */
export type service_usage_statistics = $Result.DefaultSelection<Prisma.$service_usage_statisticsPayload>
/**
 * Model staff
 * 
 */
export type staff = $Result.DefaultSelection<Prisma.$staffPayload>
/**
 * Model system_event
 * 
 */
export type system_event = $Result.DefaultSelection<Prisma.$system_eventPayload>
/**
 * Model tenant_access_logs
 * 
 */
export type tenant_access_logs = $Result.DefaultSelection<Prisma.$tenant_access_logsPayload>
/**
 * Model tenant_services
 * 
 */
export type tenant_services = $Result.DefaultSelection<Prisma.$tenant_servicesPayload>
/**
 * Model checkin_sessions
 * 
 */
export type checkin_sessions = $Result.DefaultSelection<Prisma.$checkin_sessionsPayload>
/**
 * Model session_billings
 * 
 */
export type session_billings = $Result.DefaultSelection<Prisma.$session_billingsPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AdminLevel: {
  chainadmin: 'chainadmin',
  groupadmin: 'groupadmin',
  superadmin: 'superadmin'
};

export type AdminLevel = (typeof AdminLevel)[keyof typeof AdminLevel]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  ENDED: 'ENDED',
  SCHEDULED: 'SCHEDULED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const CampaignDisplayType: {
  BANNER: 'BANNER',
  POPUP: 'POPUP',
  NOTIFICATION: 'NOTIFICATION',
  FEATURED: 'FEATURED'
};

export type CampaignDisplayType = (typeof CampaignDisplayType)[keyof typeof CampaignDisplayType]


export const CampaignCtaType: {
  NONE: 'NONE',
  LINK: 'LINK',
  BUTTON: 'BUTTON',
  COUPON: 'COUPON'
};

export type CampaignCtaType = (typeof CampaignCtaType)[keyof typeof CampaignCtaType]

}

export type AdminLevel = $Enums.AdminLevel

export const AdminLevel: typeof $Enums.AdminLevel

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type CampaignDisplayType = $Enums.CampaignDisplayType

export const CampaignDisplayType: typeof $Enums.CampaignDisplayType

export type CampaignCtaType = $Enums.CampaignCtaType

export const CampaignCtaType: typeof $Enums.CampaignCtaType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more DatabaseChangeLogs
 * const databaseChangeLogs = await prisma.databaseChangeLog.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more DatabaseChangeLogs
   * const databaseChangeLogs = await prisma.databaseChangeLog.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.databaseChangeLog`: Exposes CRUD operations for the **DatabaseChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatabaseChangeLogs
    * const databaseChangeLogs = await prisma.databaseChangeLog.findMany()
    * ```
    */
  get databaseChangeLog(): Prisma.DatabaseChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.systemPlanRestrictions`: Exposes CRUD operations for the **SystemPlanRestrictions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemPlanRestrictions
    * const systemPlanRestrictions = await prisma.systemPlanRestrictions.findMany()
    * ```
    */
  get systemPlanRestrictions(): Prisma.SystemPlanRestrictionsDelegate<ExtArgs>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.tenantSystemPlan`: Exposes CRUD operations for the **TenantSystemPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantSystemPlans
    * const tenantSystemPlans = await prisma.tenantSystemPlan.findMany()
    * ```
    */
  get tenantSystemPlan(): Prisma.TenantSystemPlanDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs>;

  /**
   * `prisma.admin_log`: Exposes CRUD operations for the **admin_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_logs
    * const admin_logs = await prisma.admin_log.findMany()
    * ```
    */
  get admin_log(): Prisma.admin_logDelegate<ExtArgs>;

  /**
   * `prisma.campaign_categories`: Exposes CRUD operations for the **campaign_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaign_categories
    * const campaign_categories = await prisma.campaign_categories.findMany()
    * ```
    */
  get campaign_categories(): Prisma.campaign_categoriesDelegate<ExtArgs>;

  /**
   * `prisma.campaign_category_relations`: Exposes CRUD operations for the **campaign_category_relations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaign_category_relations
    * const campaign_category_relations = await prisma.campaign_category_relations.findMany()
    * ```
    */
  get campaign_category_relations(): Prisma.campaign_category_relationsDelegate<ExtArgs>;

  /**
   * `prisma.campaign_items`: Exposes CRUD operations for the **campaign_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaign_items
    * const campaign_items = await prisma.campaign_items.findMany()
    * ```
    */
  get campaign_items(): Prisma.campaign_itemsDelegate<ExtArgs>;

  /**
   * `prisma.campaign_translations`: Exposes CRUD operations for the **campaign_translations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaign_translations
    * const campaign_translations = await prisma.campaign_translations.findMany()
    * ```
    */
  get campaign_translations(): Prisma.campaign_translationsDelegate<ExtArgs>;

  /**
   * `prisma.campaign_usage_logs`: Exposes CRUD operations for the **campaign_usage_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaign_usage_logs
    * const campaign_usage_logs = await prisma.campaign_usage_logs.findMany()
    * ```
    */
  get campaign_usage_logs(): Prisma.campaign_usage_logsDelegate<ExtArgs>;

  /**
   * `prisma.campaigns`: Exposes CRUD operations for the **campaigns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaigns.findMany()
    * ```
    */
  get campaigns(): Prisma.campaignsDelegate<ExtArgs>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.customersDelegate<ExtArgs>;

  /**
   * `prisma.device_rooms`: Exposes CRUD operations for the **device_rooms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Device_rooms
    * const device_rooms = await prisma.device_rooms.findMany()
    * ```
    */
  get device_rooms(): Prisma.device_roomsDelegate<ExtArgs>;

  /**
   * `prisma.device_video_caches`: Exposes CRUD operations for the **device_video_caches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Device_video_caches
    * const device_video_caches = await prisma.device_video_caches.findMany()
    * ```
    */
  get device_video_caches(): Prisma.device_video_cachesDelegate<ExtArgs>;

  /**
   * `prisma.notification_templates`: Exposes CRUD operations for the **notification_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notification_templates
    * const notification_templates = await prisma.notification_templates.findMany()
    * ```
    */
  get notification_templates(): Prisma.notification_templatesDelegate<ExtArgs>;

  /**
   * `prisma.page_histories`: Exposes CRUD operations for the **page_histories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Page_histories
    * const page_histories = await prisma.page_histories.findMany()
    * ```
    */
  get page_histories(): Prisma.page_historiesDelegate<ExtArgs>;

  /**
   * `prisma.pages`: Exposes CRUD operations for the **pages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.pages.findMany()
    * ```
    */
  get pages(): Prisma.pagesDelegate<ExtArgs>;

  /**
   * `prisma.reservations`: Exposes CRUD operations for the **reservations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservations.findMany()
    * ```
    */
  get reservations(): Prisma.reservationsDelegate<ExtArgs>;

  /**
   * `prisma.response_node_translations`: Exposes CRUD operations for the **response_node_translations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Response_node_translations
    * const response_node_translations = await prisma.response_node_translations.findMany()
    * ```
    */
  get response_node_translations(): Prisma.response_node_translationsDelegate<ExtArgs>;

  /**
   * `prisma.response_nodes`: Exposes CRUD operations for the **response_nodes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Response_nodes
    * const response_nodes = await prisma.response_nodes.findMany()
    * ```
    */
  get response_nodes(): Prisma.response_nodesDelegate<ExtArgs>;

  /**
   * `prisma.response_tree_history`: Exposes CRUD operations for the **response_tree_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Response_tree_histories
    * const response_tree_histories = await prisma.response_tree_history.findMany()
    * ```
    */
  get response_tree_history(): Prisma.response_tree_historyDelegate<ExtArgs>;

  /**
   * `prisma.response_tree_mobile_links`: Exposes CRUD operations for the **response_tree_mobile_links** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Response_tree_mobile_links
    * const response_tree_mobile_links = await prisma.response_tree_mobile_links.findMany()
    * ```
    */
  get response_tree_mobile_links(): Prisma.response_tree_mobile_linksDelegate<ExtArgs>;

  /**
   * `prisma.response_tree_sessions`: Exposes CRUD operations for the **response_tree_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Response_tree_sessions
    * const response_tree_sessions = await prisma.response_tree_sessions.findMany()
    * ```
    */
  get response_tree_sessions(): Prisma.response_tree_sessionsDelegate<ExtArgs>;

  /**
   * `prisma.response_tree_versions`: Exposes CRUD operations for the **response_tree_versions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Response_tree_versions
    * const response_tree_versions = await prisma.response_tree_versions.findMany()
    * ```
    */
  get response_tree_versions(): Prisma.response_tree_versionsDelegate<ExtArgs>;

  /**
   * `prisma.response_trees`: Exposes CRUD operations for the **response_trees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Response_trees
    * const response_trees = await prisma.response_trees.findMany()
    * ```
    */
  get response_trees(): Prisma.response_treesDelegate<ExtArgs>;

  /**
   * `prisma.room_grades`: Exposes CRUD operations for the **room_grades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Room_grades
    * const room_grades = await prisma.room_grades.findMany()
    * ```
    */
  get room_grades(): Prisma.room_gradesDelegate<ExtArgs>;

  /**
   * `prisma.schema_version`: Exposes CRUD operations for the **schema_version** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schema_versions
    * const schema_versions = await prisma.schema_version.findMany()
    * ```
    */
  get schema_version(): Prisma.schema_versionDelegate<ExtArgs>;

  /**
   * `prisma.service_plan_restrictions`: Exposes CRUD operations for the **service_plan_restrictions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_plan_restrictions
    * const service_plan_restrictions = await prisma.service_plan_restrictions.findMany()
    * ```
    */
  get service_plan_restrictions(): Prisma.service_plan_restrictionsDelegate<ExtArgs>;

  /**
   * `prisma.service_usage_statistics`: Exposes CRUD operations for the **service_usage_statistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_usage_statistics
    * const service_usage_statistics = await prisma.service_usage_statistics.findMany()
    * ```
    */
  get service_usage_statistics(): Prisma.service_usage_statisticsDelegate<ExtArgs>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.staffDelegate<ExtArgs>;

  /**
   * `prisma.system_event`: Exposes CRUD operations for the **system_event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more System_events
    * const system_events = await prisma.system_event.findMany()
    * ```
    */
  get system_event(): Prisma.system_eventDelegate<ExtArgs>;

  /**
   * `prisma.tenant_access_logs`: Exposes CRUD operations for the **tenant_access_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenant_access_logs
    * const tenant_access_logs = await prisma.tenant_access_logs.findMany()
    * ```
    */
  get tenant_access_logs(): Prisma.tenant_access_logsDelegate<ExtArgs>;

  /**
   * `prisma.tenant_services`: Exposes CRUD operations for the **tenant_services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenant_services
    * const tenant_services = await prisma.tenant_services.findMany()
    * ```
    */
  get tenant_services(): Prisma.tenant_servicesDelegate<ExtArgs>;

  /**
   * `prisma.checkin_sessions`: Exposes CRUD operations for the **checkin_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checkin_sessions
    * const checkin_sessions = await prisma.checkin_sessions.findMany()
    * ```
    */
  get checkin_sessions(): Prisma.checkin_sessionsDelegate<ExtArgs>;

  /**
   * `prisma.session_billings`: Exposes CRUD operations for the **session_billings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Session_billings
    * const session_billings = await prisma.session_billings.findMany()
    * ```
    */
  get session_billings(): Prisma.session_billingsDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    DatabaseChangeLog: 'DatabaseChangeLog',
    Order: 'Order',
    OrderItem: 'OrderItem',
    SystemPlanRestrictions: 'SystemPlanRestrictions',
    Tenant: 'Tenant',
    TenantSystemPlan: 'TenantSystemPlan',
    admin: 'admin',
    admin_log: 'admin_log',
    campaign_categories: 'campaign_categories',
    campaign_category_relations: 'campaign_category_relations',
    campaign_items: 'campaign_items',
    campaign_translations: 'campaign_translations',
    campaign_usage_logs: 'campaign_usage_logs',
    campaigns: 'campaigns',
    customers: 'customers',
    device_rooms: 'device_rooms',
    device_video_caches: 'device_video_caches',
    notification_templates: 'notification_templates',
    page_histories: 'page_histories',
    pages: 'pages',
    reservations: 'reservations',
    response_node_translations: 'response_node_translations',
    response_nodes: 'response_nodes',
    response_tree_history: 'response_tree_history',
    response_tree_mobile_links: 'response_tree_mobile_links',
    response_tree_sessions: 'response_tree_sessions',
    response_tree_versions: 'response_tree_versions',
    response_trees: 'response_trees',
    room_grades: 'room_grades',
    schema_version: 'schema_version',
    service_plan_restrictions: 'service_plan_restrictions',
    service_usage_statistics: 'service_usage_statistics',
    staff: 'staff',
    system_event: 'system_event',
    tenant_access_logs: 'tenant_access_logs',
    tenant_services: 'tenant_services',
    checkin_sessions: 'checkin_sessions',
    session_billings: 'session_billings',
    Room: 'Room',
    Transaction: 'Transaction',
    Invoice: 'Invoice',
    Payment: 'Payment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "databaseChangeLog" | "order" | "orderItem" | "systemPlanRestrictions" | "tenant" | "tenantSystemPlan" | "admin" | "admin_log" | "campaign_categories" | "campaign_category_relations" | "campaign_items" | "campaign_translations" | "campaign_usage_logs" | "campaigns" | "customers" | "device_rooms" | "device_video_caches" | "notification_templates" | "page_histories" | "pages" | "reservations" | "response_node_translations" | "response_nodes" | "response_tree_history" | "response_tree_mobile_links" | "response_tree_sessions" | "response_tree_versions" | "response_trees" | "room_grades" | "schema_version" | "service_plan_restrictions" | "service_usage_statistics" | "staff" | "system_event" | "tenant_access_logs" | "tenant_services" | "checkin_sessions" | "session_billings" | "room" | "transaction" | "invoice" | "payment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      DatabaseChangeLog: {
        payload: Prisma.$DatabaseChangeLogPayload<ExtArgs>
        fields: Prisma.DatabaseChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatabaseChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatabaseChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload>
          }
          findFirst: {
            args: Prisma.DatabaseChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatabaseChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload>
          }
          findMany: {
            args: Prisma.DatabaseChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload>[]
          }
          create: {
            args: Prisma.DatabaseChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload>
          }
          createMany: {
            args: Prisma.DatabaseChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatabaseChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload>[]
          }
          delete: {
            args: Prisma.DatabaseChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload>
          }
          update: {
            args: Prisma.DatabaseChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.DatabaseChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatabaseChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DatabaseChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseChangeLogPayload>
          }
          aggregate: {
            args: Prisma.DatabaseChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatabaseChangeLog>
          }
          groupBy: {
            args: Prisma.DatabaseChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatabaseChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatabaseChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<DatabaseChangeLogCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      SystemPlanRestrictions: {
        payload: Prisma.$SystemPlanRestrictionsPayload<ExtArgs>
        fields: Prisma.SystemPlanRestrictionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemPlanRestrictionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemPlanRestrictionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload>
          }
          findFirst: {
            args: Prisma.SystemPlanRestrictionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemPlanRestrictionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload>
          }
          findMany: {
            args: Prisma.SystemPlanRestrictionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload>[]
          }
          create: {
            args: Prisma.SystemPlanRestrictionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload>
          }
          createMany: {
            args: Prisma.SystemPlanRestrictionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemPlanRestrictionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload>[]
          }
          delete: {
            args: Prisma.SystemPlanRestrictionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload>
          }
          update: {
            args: Prisma.SystemPlanRestrictionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload>
          }
          deleteMany: {
            args: Prisma.SystemPlanRestrictionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemPlanRestrictionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemPlanRestrictionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPlanRestrictionsPayload>
          }
          aggregate: {
            args: Prisma.SystemPlanRestrictionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemPlanRestrictions>
          }
          groupBy: {
            args: Prisma.SystemPlanRestrictionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemPlanRestrictionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemPlanRestrictionsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemPlanRestrictionsCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantSystemPlan: {
        payload: Prisma.$TenantSystemPlanPayload<ExtArgs>
        fields: Prisma.TenantSystemPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantSystemPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantSystemPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload>
          }
          findFirst: {
            args: Prisma.TenantSystemPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantSystemPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload>
          }
          findMany: {
            args: Prisma.TenantSystemPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload>[]
          }
          create: {
            args: Prisma.TenantSystemPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload>
          }
          createMany: {
            args: Prisma.TenantSystemPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantSystemPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload>[]
          }
          delete: {
            args: Prisma.TenantSystemPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload>
          }
          update: {
            args: Prisma.TenantSystemPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload>
          }
          deleteMany: {
            args: Prisma.TenantSystemPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantSystemPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantSystemPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantSystemPlanPayload>
          }
          aggregate: {
            args: Prisma.TenantSystemPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantSystemPlan>
          }
          groupBy: {
            args: Prisma.TenantSystemPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantSystemPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantSystemPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TenantSystemPlanCountAggregateOutputType> | number
          }
        }
      }
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.adminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      admin_log: {
        payload: Prisma.$admin_logPayload<ExtArgs>
        fields: Prisma.admin_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admin_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admin_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload>
          }
          findFirst: {
            args: Prisma.admin_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admin_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload>
          }
          findMany: {
            args: Prisma.admin_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload>[]
          }
          create: {
            args: Prisma.admin_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload>
          }
          createMany: {
            args: Prisma.admin_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.admin_logCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload>[]
          }
          delete: {
            args: Prisma.admin_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload>
          }
          update: {
            args: Prisma.admin_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload>
          }
          deleteMany: {
            args: Prisma.admin_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admin_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.admin_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_logPayload>
          }
          aggregate: {
            args: Prisma.Admin_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin_log>
          }
          groupBy: {
            args: Prisma.admin_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Admin_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.admin_logCountArgs<ExtArgs>
            result: $Utils.Optional<Admin_logCountAggregateOutputType> | number
          }
        }
      }
      campaign_categories: {
        payload: Prisma.$campaign_categoriesPayload<ExtArgs>
        fields: Prisma.campaign_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaign_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaign_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload>
          }
          findFirst: {
            args: Prisma.campaign_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaign_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload>
          }
          findMany: {
            args: Prisma.campaign_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload>[]
          }
          create: {
            args: Prisma.campaign_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload>
          }
          createMany: {
            args: Prisma.campaign_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaign_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload>[]
          }
          delete: {
            args: Prisma.campaign_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload>
          }
          update: {
            args: Prisma.campaign_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.campaign_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaign_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.campaign_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Campaign_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign_categories>
          }
          groupBy: {
            args: Prisma.campaign_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Campaign_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaign_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Campaign_categoriesCountAggregateOutputType> | number
          }
        }
      }
      campaign_category_relations: {
        payload: Prisma.$campaign_category_relationsPayload<ExtArgs>
        fields: Prisma.campaign_category_relationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaign_category_relationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaign_category_relationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload>
          }
          findFirst: {
            args: Prisma.campaign_category_relationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaign_category_relationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload>
          }
          findMany: {
            args: Prisma.campaign_category_relationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload>[]
          }
          create: {
            args: Prisma.campaign_category_relationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload>
          }
          createMany: {
            args: Prisma.campaign_category_relationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaign_category_relationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload>[]
          }
          delete: {
            args: Prisma.campaign_category_relationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload>
          }
          update: {
            args: Prisma.campaign_category_relationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload>
          }
          deleteMany: {
            args: Prisma.campaign_category_relationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaign_category_relationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.campaign_category_relationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_category_relationsPayload>
          }
          aggregate: {
            args: Prisma.Campaign_category_relationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign_category_relations>
          }
          groupBy: {
            args: Prisma.campaign_category_relationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Campaign_category_relationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaign_category_relationsCountArgs<ExtArgs>
            result: $Utils.Optional<Campaign_category_relationsCountAggregateOutputType> | number
          }
        }
      }
      campaign_items: {
        payload: Prisma.$campaign_itemsPayload<ExtArgs>
        fields: Prisma.campaign_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaign_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaign_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload>
          }
          findFirst: {
            args: Prisma.campaign_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaign_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload>
          }
          findMany: {
            args: Prisma.campaign_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload>[]
          }
          create: {
            args: Prisma.campaign_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload>
          }
          createMany: {
            args: Prisma.campaign_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaign_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload>[]
          }
          delete: {
            args: Prisma.campaign_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload>
          }
          update: {
            args: Prisma.campaign_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload>
          }
          deleteMany: {
            args: Prisma.campaign_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaign_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.campaign_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_itemsPayload>
          }
          aggregate: {
            args: Prisma.Campaign_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign_items>
          }
          groupBy: {
            args: Prisma.campaign_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Campaign_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaign_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Campaign_itemsCountAggregateOutputType> | number
          }
        }
      }
      campaign_translations: {
        payload: Prisma.$campaign_translationsPayload<ExtArgs>
        fields: Prisma.campaign_translationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaign_translationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaign_translationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload>
          }
          findFirst: {
            args: Prisma.campaign_translationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaign_translationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload>
          }
          findMany: {
            args: Prisma.campaign_translationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload>[]
          }
          create: {
            args: Prisma.campaign_translationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload>
          }
          createMany: {
            args: Prisma.campaign_translationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaign_translationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload>[]
          }
          delete: {
            args: Prisma.campaign_translationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload>
          }
          update: {
            args: Prisma.campaign_translationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload>
          }
          deleteMany: {
            args: Prisma.campaign_translationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaign_translationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.campaign_translationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_translationsPayload>
          }
          aggregate: {
            args: Prisma.Campaign_translationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign_translations>
          }
          groupBy: {
            args: Prisma.campaign_translationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Campaign_translationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaign_translationsCountArgs<ExtArgs>
            result: $Utils.Optional<Campaign_translationsCountAggregateOutputType> | number
          }
        }
      }
      campaign_usage_logs: {
        payload: Prisma.$campaign_usage_logsPayload<ExtArgs>
        fields: Prisma.campaign_usage_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaign_usage_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaign_usage_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload>
          }
          findFirst: {
            args: Prisma.campaign_usage_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaign_usage_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload>
          }
          findMany: {
            args: Prisma.campaign_usage_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload>[]
          }
          create: {
            args: Prisma.campaign_usage_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload>
          }
          createMany: {
            args: Prisma.campaign_usage_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaign_usage_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload>[]
          }
          delete: {
            args: Prisma.campaign_usage_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload>
          }
          update: {
            args: Prisma.campaign_usage_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload>
          }
          deleteMany: {
            args: Prisma.campaign_usage_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaign_usage_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.campaign_usage_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaign_usage_logsPayload>
          }
          aggregate: {
            args: Prisma.Campaign_usage_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign_usage_logs>
          }
          groupBy: {
            args: Prisma.campaign_usage_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Campaign_usage_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaign_usage_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Campaign_usage_logsCountAggregateOutputType> | number
          }
        }
      }
      campaigns: {
        payload: Prisma.$campaignsPayload<ExtArgs>
        fields: Prisma.campaignsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaignsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaignsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          findFirst: {
            args: Prisma.campaignsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaignsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          findMany: {
            args: Prisma.campaignsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>[]
          }
          create: {
            args: Prisma.campaignsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          createMany: {
            args: Prisma.campaignsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaignsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>[]
          }
          delete: {
            args: Prisma.campaignsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          update: {
            args: Prisma.campaignsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          deleteMany: {
            args: Prisma.campaignsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaignsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.campaignsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          aggregate: {
            args: Prisma.CampaignsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaigns>
          }
          groupBy: {
            args: Prisma.campaignsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignsGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaignsCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignsCountAggregateOutputType> | number
          }
        }
      }
      customers: {
        payload: Prisma.$customersPayload<ExtArgs>
        fields: Prisma.customersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findFirst: {
            args: Prisma.customersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findMany: {
            args: Prisma.customersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          create: {
            args: Prisma.customersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          createMany: {
            args: Prisma.customersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          delete: {
            args: Prisma.customersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          update: {
            args: Prisma.customersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          deleteMany: {
            args: Prisma.customersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.customersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.customersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      device_rooms: {
        payload: Prisma.$device_roomsPayload<ExtArgs>
        fields: Prisma.device_roomsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.device_roomsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.device_roomsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload>
          }
          findFirst: {
            args: Prisma.device_roomsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.device_roomsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload>
          }
          findMany: {
            args: Prisma.device_roomsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload>[]
          }
          create: {
            args: Prisma.device_roomsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload>
          }
          createMany: {
            args: Prisma.device_roomsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.device_roomsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload>[]
          }
          delete: {
            args: Prisma.device_roomsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload>
          }
          update: {
            args: Prisma.device_roomsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload>
          }
          deleteMany: {
            args: Prisma.device_roomsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.device_roomsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.device_roomsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_roomsPayload>
          }
          aggregate: {
            args: Prisma.Device_roomsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice_rooms>
          }
          groupBy: {
            args: Prisma.device_roomsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Device_roomsGroupByOutputType>[]
          }
          count: {
            args: Prisma.device_roomsCountArgs<ExtArgs>
            result: $Utils.Optional<Device_roomsCountAggregateOutputType> | number
          }
        }
      }
      device_video_caches: {
        payload: Prisma.$device_video_cachesPayload<ExtArgs>
        fields: Prisma.device_video_cachesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.device_video_cachesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.device_video_cachesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload>
          }
          findFirst: {
            args: Prisma.device_video_cachesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.device_video_cachesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload>
          }
          findMany: {
            args: Prisma.device_video_cachesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload>[]
          }
          create: {
            args: Prisma.device_video_cachesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload>
          }
          createMany: {
            args: Prisma.device_video_cachesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.device_video_cachesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload>[]
          }
          delete: {
            args: Prisma.device_video_cachesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload>
          }
          update: {
            args: Prisma.device_video_cachesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload>
          }
          deleteMany: {
            args: Prisma.device_video_cachesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.device_video_cachesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.device_video_cachesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$device_video_cachesPayload>
          }
          aggregate: {
            args: Prisma.Device_video_cachesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice_video_caches>
          }
          groupBy: {
            args: Prisma.device_video_cachesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Device_video_cachesGroupByOutputType>[]
          }
          count: {
            args: Prisma.device_video_cachesCountArgs<ExtArgs>
            result: $Utils.Optional<Device_video_cachesCountAggregateOutputType> | number
          }
        }
      }
      notification_templates: {
        payload: Prisma.$notification_templatesPayload<ExtArgs>
        fields: Prisma.notification_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notification_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notification_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload>
          }
          findFirst: {
            args: Prisma.notification_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notification_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload>
          }
          findMany: {
            args: Prisma.notification_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload>[]
          }
          create: {
            args: Prisma.notification_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload>
          }
          createMany: {
            args: Prisma.notification_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notification_templatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload>[]
          }
          delete: {
            args: Prisma.notification_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload>
          }
          update: {
            args: Prisma.notification_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload>
          }
          deleteMany: {
            args: Prisma.notification_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notification_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notification_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notification_templatesPayload>
          }
          aggregate: {
            args: Prisma.Notification_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification_templates>
          }
          groupBy: {
            args: Prisma.notification_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Notification_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notification_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Notification_templatesCountAggregateOutputType> | number
          }
        }
      }
      page_histories: {
        payload: Prisma.$page_historiesPayload<ExtArgs>
        fields: Prisma.page_historiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.page_historiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.page_historiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload>
          }
          findFirst: {
            args: Prisma.page_historiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.page_historiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload>
          }
          findMany: {
            args: Prisma.page_historiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload>[]
          }
          create: {
            args: Prisma.page_historiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload>
          }
          createMany: {
            args: Prisma.page_historiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.page_historiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload>[]
          }
          delete: {
            args: Prisma.page_historiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload>
          }
          update: {
            args: Prisma.page_historiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload>
          }
          deleteMany: {
            args: Prisma.page_historiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.page_historiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.page_historiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$page_historiesPayload>
          }
          aggregate: {
            args: Prisma.Page_historiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage_histories>
          }
          groupBy: {
            args: Prisma.page_historiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Page_historiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.page_historiesCountArgs<ExtArgs>
            result: $Utils.Optional<Page_historiesCountAggregateOutputType> | number
          }
        }
      }
      pages: {
        payload: Prisma.$pagesPayload<ExtArgs>
        fields: Prisma.pagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          findFirst: {
            args: Prisma.pagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          findMany: {
            args: Prisma.pagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>[]
          }
          create: {
            args: Prisma.pagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          createMany: {
            args: Prisma.pagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>[]
          }
          delete: {
            args: Prisma.pagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          update: {
            args: Prisma.pagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          deleteMany: {
            args: Prisma.pagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagesPayload>
          }
          aggregate: {
            args: Prisma.PagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePages>
          }
          groupBy: {
            args: Prisma.pagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.pagesCountArgs<ExtArgs>
            result: $Utils.Optional<PagesCountAggregateOutputType> | number
          }
        }
      }
      reservations: {
        payload: Prisma.$reservationsPayload<ExtArgs>
        fields: Prisma.reservationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reservationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reservationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload>
          }
          findFirst: {
            args: Prisma.reservationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reservationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload>
          }
          findMany: {
            args: Prisma.reservationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload>[]
          }
          create: {
            args: Prisma.reservationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload>
          }
          createMany: {
            args: Prisma.reservationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reservationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload>[]
          }
          delete: {
            args: Prisma.reservationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload>
          }
          update: {
            args: Prisma.reservationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload>
          }
          deleteMany: {
            args: Prisma.reservationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reservationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reservationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservationsPayload>
          }
          aggregate: {
            args: Prisma.ReservationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservations>
          }
          groupBy: {
            args: Prisma.reservationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reservationsCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationsCountAggregateOutputType> | number
          }
        }
      }
      response_node_translations: {
        payload: Prisma.$response_node_translationsPayload<ExtArgs>
        fields: Prisma.response_node_translationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.response_node_translationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.response_node_translationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload>
          }
          findFirst: {
            args: Prisma.response_node_translationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.response_node_translationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload>
          }
          findMany: {
            args: Prisma.response_node_translationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload>[]
          }
          create: {
            args: Prisma.response_node_translationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload>
          }
          createMany: {
            args: Prisma.response_node_translationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.response_node_translationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload>[]
          }
          delete: {
            args: Prisma.response_node_translationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload>
          }
          update: {
            args: Prisma.response_node_translationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload>
          }
          deleteMany: {
            args: Prisma.response_node_translationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.response_node_translationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.response_node_translationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_node_translationsPayload>
          }
          aggregate: {
            args: Prisma.Response_node_translationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponse_node_translations>
          }
          groupBy: {
            args: Prisma.response_node_translationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Response_node_translationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.response_node_translationsCountArgs<ExtArgs>
            result: $Utils.Optional<Response_node_translationsCountAggregateOutputType> | number
          }
        }
      }
      response_nodes: {
        payload: Prisma.$response_nodesPayload<ExtArgs>
        fields: Prisma.response_nodesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.response_nodesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.response_nodesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload>
          }
          findFirst: {
            args: Prisma.response_nodesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.response_nodesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload>
          }
          findMany: {
            args: Prisma.response_nodesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload>[]
          }
          create: {
            args: Prisma.response_nodesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload>
          }
          createMany: {
            args: Prisma.response_nodesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.response_nodesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload>[]
          }
          delete: {
            args: Prisma.response_nodesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload>
          }
          update: {
            args: Prisma.response_nodesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload>
          }
          deleteMany: {
            args: Prisma.response_nodesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.response_nodesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.response_nodesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_nodesPayload>
          }
          aggregate: {
            args: Prisma.Response_nodesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponse_nodes>
          }
          groupBy: {
            args: Prisma.response_nodesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Response_nodesGroupByOutputType>[]
          }
          count: {
            args: Prisma.response_nodesCountArgs<ExtArgs>
            result: $Utils.Optional<Response_nodesCountAggregateOutputType> | number
          }
        }
      }
      response_tree_history: {
        payload: Prisma.$response_tree_historyPayload<ExtArgs>
        fields: Prisma.response_tree_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.response_tree_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.response_tree_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload>
          }
          findFirst: {
            args: Prisma.response_tree_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.response_tree_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload>
          }
          findMany: {
            args: Prisma.response_tree_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload>[]
          }
          create: {
            args: Prisma.response_tree_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload>
          }
          createMany: {
            args: Prisma.response_tree_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.response_tree_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload>[]
          }
          delete: {
            args: Prisma.response_tree_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload>
          }
          update: {
            args: Prisma.response_tree_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload>
          }
          deleteMany: {
            args: Prisma.response_tree_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.response_tree_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.response_tree_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_historyPayload>
          }
          aggregate: {
            args: Prisma.Response_tree_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponse_tree_history>
          }
          groupBy: {
            args: Prisma.response_tree_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Response_tree_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.response_tree_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Response_tree_historyCountAggregateOutputType> | number
          }
        }
      }
      response_tree_mobile_links: {
        payload: Prisma.$response_tree_mobile_linksPayload<ExtArgs>
        fields: Prisma.response_tree_mobile_linksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.response_tree_mobile_linksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.response_tree_mobile_linksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload>
          }
          findFirst: {
            args: Prisma.response_tree_mobile_linksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.response_tree_mobile_linksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload>
          }
          findMany: {
            args: Prisma.response_tree_mobile_linksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload>[]
          }
          create: {
            args: Prisma.response_tree_mobile_linksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload>
          }
          createMany: {
            args: Prisma.response_tree_mobile_linksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.response_tree_mobile_linksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload>[]
          }
          delete: {
            args: Prisma.response_tree_mobile_linksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload>
          }
          update: {
            args: Prisma.response_tree_mobile_linksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload>
          }
          deleteMany: {
            args: Prisma.response_tree_mobile_linksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.response_tree_mobile_linksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.response_tree_mobile_linksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_mobile_linksPayload>
          }
          aggregate: {
            args: Prisma.Response_tree_mobile_linksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponse_tree_mobile_links>
          }
          groupBy: {
            args: Prisma.response_tree_mobile_linksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Response_tree_mobile_linksGroupByOutputType>[]
          }
          count: {
            args: Prisma.response_tree_mobile_linksCountArgs<ExtArgs>
            result: $Utils.Optional<Response_tree_mobile_linksCountAggregateOutputType> | number
          }
        }
      }
      response_tree_sessions: {
        payload: Prisma.$response_tree_sessionsPayload<ExtArgs>
        fields: Prisma.response_tree_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.response_tree_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.response_tree_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload>
          }
          findFirst: {
            args: Prisma.response_tree_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.response_tree_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload>
          }
          findMany: {
            args: Prisma.response_tree_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload>[]
          }
          create: {
            args: Prisma.response_tree_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload>
          }
          createMany: {
            args: Prisma.response_tree_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.response_tree_sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload>[]
          }
          delete: {
            args: Prisma.response_tree_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload>
          }
          update: {
            args: Prisma.response_tree_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.response_tree_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.response_tree_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.response_tree_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Response_tree_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponse_tree_sessions>
          }
          groupBy: {
            args: Prisma.response_tree_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Response_tree_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.response_tree_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Response_tree_sessionsCountAggregateOutputType> | number
          }
        }
      }
      response_tree_versions: {
        payload: Prisma.$response_tree_versionsPayload<ExtArgs>
        fields: Prisma.response_tree_versionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.response_tree_versionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.response_tree_versionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload>
          }
          findFirst: {
            args: Prisma.response_tree_versionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.response_tree_versionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload>
          }
          findMany: {
            args: Prisma.response_tree_versionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload>[]
          }
          create: {
            args: Prisma.response_tree_versionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload>
          }
          createMany: {
            args: Prisma.response_tree_versionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.response_tree_versionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload>[]
          }
          delete: {
            args: Prisma.response_tree_versionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload>
          }
          update: {
            args: Prisma.response_tree_versionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload>
          }
          deleteMany: {
            args: Prisma.response_tree_versionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.response_tree_versionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.response_tree_versionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_tree_versionsPayload>
          }
          aggregate: {
            args: Prisma.Response_tree_versionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponse_tree_versions>
          }
          groupBy: {
            args: Prisma.response_tree_versionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Response_tree_versionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.response_tree_versionsCountArgs<ExtArgs>
            result: $Utils.Optional<Response_tree_versionsCountAggregateOutputType> | number
          }
        }
      }
      response_trees: {
        payload: Prisma.$response_treesPayload<ExtArgs>
        fields: Prisma.response_treesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.response_treesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.response_treesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload>
          }
          findFirst: {
            args: Prisma.response_treesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.response_treesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload>
          }
          findMany: {
            args: Prisma.response_treesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload>[]
          }
          create: {
            args: Prisma.response_treesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload>
          }
          createMany: {
            args: Prisma.response_treesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.response_treesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload>[]
          }
          delete: {
            args: Prisma.response_treesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload>
          }
          update: {
            args: Prisma.response_treesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload>
          }
          deleteMany: {
            args: Prisma.response_treesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.response_treesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.response_treesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$response_treesPayload>
          }
          aggregate: {
            args: Prisma.Response_treesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponse_trees>
          }
          groupBy: {
            args: Prisma.response_treesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Response_treesGroupByOutputType>[]
          }
          count: {
            args: Prisma.response_treesCountArgs<ExtArgs>
            result: $Utils.Optional<Response_treesCountAggregateOutputType> | number
          }
        }
      }
      room_grades: {
        payload: Prisma.$room_gradesPayload<ExtArgs>
        fields: Prisma.room_gradesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.room_gradesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.room_gradesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload>
          }
          findFirst: {
            args: Prisma.room_gradesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.room_gradesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload>
          }
          findMany: {
            args: Prisma.room_gradesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload>[]
          }
          create: {
            args: Prisma.room_gradesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload>
          }
          createMany: {
            args: Prisma.room_gradesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.room_gradesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload>[]
          }
          delete: {
            args: Prisma.room_gradesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload>
          }
          update: {
            args: Prisma.room_gradesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload>
          }
          deleteMany: {
            args: Prisma.room_gradesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.room_gradesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.room_gradesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$room_gradesPayload>
          }
          aggregate: {
            args: Prisma.Room_gradesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom_grades>
          }
          groupBy: {
            args: Prisma.room_gradesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Room_gradesGroupByOutputType>[]
          }
          count: {
            args: Prisma.room_gradesCountArgs<ExtArgs>
            result: $Utils.Optional<Room_gradesCountAggregateOutputType> | number
          }
        }
      }
      schema_version: {
        payload: Prisma.$schema_versionPayload<ExtArgs>
        fields: Prisma.schema_versionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.schema_versionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.schema_versionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          findFirst: {
            args: Prisma.schema_versionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.schema_versionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          findMany: {
            args: Prisma.schema_versionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>[]
          }
          create: {
            args: Prisma.schema_versionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          createMany: {
            args: Prisma.schema_versionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.schema_versionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>[]
          }
          delete: {
            args: Prisma.schema_versionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          update: {
            args: Prisma.schema_versionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          deleteMany: {
            args: Prisma.schema_versionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.schema_versionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.schema_versionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          aggregate: {
            args: Prisma.Schema_versionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchema_version>
          }
          groupBy: {
            args: Prisma.schema_versionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Schema_versionGroupByOutputType>[]
          }
          count: {
            args: Prisma.schema_versionCountArgs<ExtArgs>
            result: $Utils.Optional<Schema_versionCountAggregateOutputType> | number
          }
        }
      }
      service_plan_restrictions: {
        payload: Prisma.$service_plan_restrictionsPayload<ExtArgs>
        fields: Prisma.service_plan_restrictionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.service_plan_restrictionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.service_plan_restrictionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload>
          }
          findFirst: {
            args: Prisma.service_plan_restrictionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.service_plan_restrictionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload>
          }
          findMany: {
            args: Prisma.service_plan_restrictionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload>[]
          }
          create: {
            args: Prisma.service_plan_restrictionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload>
          }
          createMany: {
            args: Prisma.service_plan_restrictionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.service_plan_restrictionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload>[]
          }
          delete: {
            args: Prisma.service_plan_restrictionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload>
          }
          update: {
            args: Prisma.service_plan_restrictionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload>
          }
          deleteMany: {
            args: Prisma.service_plan_restrictionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.service_plan_restrictionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.service_plan_restrictionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_plan_restrictionsPayload>
          }
          aggregate: {
            args: Prisma.Service_plan_restrictionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService_plan_restrictions>
          }
          groupBy: {
            args: Prisma.service_plan_restrictionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Service_plan_restrictionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.service_plan_restrictionsCountArgs<ExtArgs>
            result: $Utils.Optional<Service_plan_restrictionsCountAggregateOutputType> | number
          }
        }
      }
      service_usage_statistics: {
        payload: Prisma.$service_usage_statisticsPayload<ExtArgs>
        fields: Prisma.service_usage_statisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.service_usage_statisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.service_usage_statisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload>
          }
          findFirst: {
            args: Prisma.service_usage_statisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.service_usage_statisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload>
          }
          findMany: {
            args: Prisma.service_usage_statisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload>[]
          }
          create: {
            args: Prisma.service_usage_statisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload>
          }
          createMany: {
            args: Prisma.service_usage_statisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.service_usage_statisticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload>[]
          }
          delete: {
            args: Prisma.service_usage_statisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload>
          }
          update: {
            args: Prisma.service_usage_statisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload>
          }
          deleteMany: {
            args: Prisma.service_usage_statisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.service_usage_statisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.service_usage_statisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_usage_statisticsPayload>
          }
          aggregate: {
            args: Prisma.Service_usage_statisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService_usage_statistics>
          }
          groupBy: {
            args: Prisma.service_usage_statisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Service_usage_statisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.service_usage_statisticsCountArgs<ExtArgs>
            result: $Utils.Optional<Service_usage_statisticsCountAggregateOutputType> | number
          }
        }
      }
      staff: {
        payload: Prisma.$staffPayload<ExtArgs>
        fields: Prisma.staffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.staffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.staffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload>
          }
          findFirst: {
            args: Prisma.staffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.staffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload>
          }
          findMany: {
            args: Prisma.staffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload>[]
          }
          create: {
            args: Prisma.staffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload>
          }
          createMany: {
            args: Prisma.staffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.staffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload>[]
          }
          delete: {
            args: Prisma.staffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload>
          }
          update: {
            args: Prisma.staffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload>
          }
          deleteMany: {
            args: Prisma.staffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.staffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.staffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.staffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.staffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      system_event: {
        payload: Prisma.$system_eventPayload<ExtArgs>
        fields: Prisma.system_eventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.system_eventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.system_eventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload>
          }
          findFirst: {
            args: Prisma.system_eventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.system_eventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload>
          }
          findMany: {
            args: Prisma.system_eventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload>[]
          }
          create: {
            args: Prisma.system_eventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload>
          }
          createMany: {
            args: Prisma.system_eventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.system_eventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload>[]
          }
          delete: {
            args: Prisma.system_eventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload>
          }
          update: {
            args: Prisma.system_eventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload>
          }
          deleteMany: {
            args: Prisma.system_eventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.system_eventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.system_eventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$system_eventPayload>
          }
          aggregate: {
            args: Prisma.System_eventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystem_event>
          }
          groupBy: {
            args: Prisma.system_eventGroupByArgs<ExtArgs>
            result: $Utils.Optional<System_eventGroupByOutputType>[]
          }
          count: {
            args: Prisma.system_eventCountArgs<ExtArgs>
            result: $Utils.Optional<System_eventCountAggregateOutputType> | number
          }
        }
      }
      tenant_access_logs: {
        payload: Prisma.$tenant_access_logsPayload<ExtArgs>
        fields: Prisma.tenant_access_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tenant_access_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tenant_access_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload>
          }
          findFirst: {
            args: Prisma.tenant_access_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tenant_access_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload>
          }
          findMany: {
            args: Prisma.tenant_access_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload>[]
          }
          create: {
            args: Prisma.tenant_access_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload>
          }
          createMany: {
            args: Prisma.tenant_access_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tenant_access_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload>[]
          }
          delete: {
            args: Prisma.tenant_access_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload>
          }
          update: {
            args: Prisma.tenant_access_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload>
          }
          deleteMany: {
            args: Prisma.tenant_access_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tenant_access_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tenant_access_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_access_logsPayload>
          }
          aggregate: {
            args: Prisma.Tenant_access_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant_access_logs>
          }
          groupBy: {
            args: Prisma.tenant_access_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tenant_access_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tenant_access_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Tenant_access_logsCountAggregateOutputType> | number
          }
        }
      }
      tenant_services: {
        payload: Prisma.$tenant_servicesPayload<ExtArgs>
        fields: Prisma.tenant_servicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tenant_servicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tenant_servicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload>
          }
          findFirst: {
            args: Prisma.tenant_servicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tenant_servicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload>
          }
          findMany: {
            args: Prisma.tenant_servicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload>[]
          }
          create: {
            args: Prisma.tenant_servicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload>
          }
          createMany: {
            args: Prisma.tenant_servicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tenant_servicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload>[]
          }
          delete: {
            args: Prisma.tenant_servicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload>
          }
          update: {
            args: Prisma.tenant_servicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload>
          }
          deleteMany: {
            args: Prisma.tenant_servicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tenant_servicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tenant_servicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tenant_servicesPayload>
          }
          aggregate: {
            args: Prisma.Tenant_servicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant_services>
          }
          groupBy: {
            args: Prisma.tenant_servicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tenant_servicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tenant_servicesCountArgs<ExtArgs>
            result: $Utils.Optional<Tenant_servicesCountAggregateOutputType> | number
          }
        }
      }
      checkin_sessions: {
        payload: Prisma.$checkin_sessionsPayload<ExtArgs>
        fields: Prisma.checkin_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.checkin_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.checkin_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload>
          }
          findFirst: {
            args: Prisma.checkin_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.checkin_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload>
          }
          findMany: {
            args: Prisma.checkin_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload>[]
          }
          create: {
            args: Prisma.checkin_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload>
          }
          createMany: {
            args: Prisma.checkin_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.checkin_sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload>[]
          }
          delete: {
            args: Prisma.checkin_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload>
          }
          update: {
            args: Prisma.checkin_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.checkin_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.checkin_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.checkin_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkin_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Checkin_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckin_sessions>
          }
          groupBy: {
            args: Prisma.checkin_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Checkin_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.checkin_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Checkin_sessionsCountAggregateOutputType> | number
          }
        }
      }
      session_billings: {
        payload: Prisma.$session_billingsPayload<ExtArgs>
        fields: Prisma.session_billingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.session_billingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.session_billingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload>
          }
          findFirst: {
            args: Prisma.session_billingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.session_billingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload>
          }
          findMany: {
            args: Prisma.session_billingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload>[]
          }
          create: {
            args: Prisma.session_billingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload>
          }
          createMany: {
            args: Prisma.session_billingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.session_billingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload>[]
          }
          delete: {
            args: Prisma.session_billingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload>
          }
          update: {
            args: Prisma.session_billingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload>
          }
          deleteMany: {
            args: Prisma.session_billingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.session_billingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.session_billingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_billingsPayload>
          }
          aggregate: {
            args: Prisma.Session_billingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession_billings>
          }
          groupBy: {
            args: Prisma.session_billingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Session_billingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.session_billingsCountArgs<ExtArgs>
            result: $Utils.Optional<Session_billingsCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    OrderItem: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItem?: boolean | OrderCountOutputTypeCountOrderItemArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type SystemPlanRestrictionsCountOutputType
   */

  export type SystemPlanRestrictionsCountOutputType = {
    TenantSystemPlan: number
  }

  export type SystemPlanRestrictionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TenantSystemPlan?: boolean | SystemPlanRestrictionsCountOutputTypeCountTenantSystemPlanArgs
  }

  // Custom InputTypes
  /**
   * SystemPlanRestrictionsCountOutputType without action
   */
  export type SystemPlanRestrictionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictionsCountOutputType
     */
    select?: SystemPlanRestrictionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SystemPlanRestrictionsCountOutputType without action
   */
  export type SystemPlanRestrictionsCountOutputTypeCountTenantSystemPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantSystemPlanWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    TenantSystemPlan: number
    device_rooms: number
    pages: number
    service_usage_statistics: number
    tenant_services: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TenantSystemPlan?: boolean | TenantCountOutputTypeCountTenantSystemPlanArgs
    device_rooms?: boolean | TenantCountOutputTypeCountDevice_roomsArgs
    pages?: boolean | TenantCountOutputTypeCountPagesArgs
    service_usage_statistics?: boolean | TenantCountOutputTypeCountService_usage_statisticsArgs
    tenant_services?: boolean | TenantCountOutputTypeCountTenant_servicesArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTenantSystemPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantSystemPlanWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDevice_roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: device_roomsWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagesWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountService_usage_statisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_usage_statisticsWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTenant_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenant_servicesWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    admin_log: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_log?: boolean | AdminCountOutputTypeCountAdmin_logArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAdmin_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_logWhereInput
  }


  /**
   * Count Type Campaign_categoriesCountOutputType
   */

  export type Campaign_categoriesCountOutputType = {
    campaign_category_relations: number
  }

  export type Campaign_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign_category_relations?: boolean | Campaign_categoriesCountOutputTypeCountCampaign_category_relationsArgs
  }

  // Custom InputTypes
  /**
   * Campaign_categoriesCountOutputType without action
   */
  export type Campaign_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_categoriesCountOutputType
     */
    select?: Campaign_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Campaign_categoriesCountOutputType without action
   */
  export type Campaign_categoriesCountOutputTypeCountCampaign_category_relationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_category_relationsWhereInput
  }


  /**
   * Count Type CampaignsCountOutputType
   */

  export type CampaignsCountOutputType = {
    campaign_category_relations: number
    campaign_items: number
    campaign_translations: number
    campaign_usage_logs: number
  }

  export type CampaignsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign_category_relations?: boolean | CampaignsCountOutputTypeCountCampaign_category_relationsArgs
    campaign_items?: boolean | CampaignsCountOutputTypeCountCampaign_itemsArgs
    campaign_translations?: boolean | CampaignsCountOutputTypeCountCampaign_translationsArgs
    campaign_usage_logs?: boolean | CampaignsCountOutputTypeCountCampaign_usage_logsArgs
  }

  // Custom InputTypes
  /**
   * CampaignsCountOutputType without action
   */
  export type CampaignsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignsCountOutputType
     */
    select?: CampaignsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignsCountOutputType without action
   */
  export type CampaignsCountOutputTypeCountCampaign_category_relationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_category_relationsWhereInput
  }

  /**
   * CampaignsCountOutputType without action
   */
  export type CampaignsCountOutputTypeCountCampaign_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_itemsWhereInput
  }

  /**
   * CampaignsCountOutputType without action
   */
  export type CampaignsCountOutputTypeCountCampaign_translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_translationsWhereInput
  }

  /**
   * CampaignsCountOutputType without action
   */
  export type CampaignsCountOutputTypeCountCampaign_usage_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_usage_logsWhereInput
  }


  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    reservations: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | CustomersCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reservationsWhereInput
  }


  /**
   * Count Type PagesCountOutputType
   */

  export type PagesCountOutputType = {
    page_histories: number
  }

  export type PagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page_histories?: boolean | PagesCountOutputTypeCountPage_historiesArgs
  }

  // Custom InputTypes
  /**
   * PagesCountOutputType without action
   */
  export type PagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagesCountOutputType
     */
    select?: PagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PagesCountOutputType without action
   */
  export type PagesCountOutputTypeCountPage_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: page_historiesWhereInput
  }


  /**
   * Count Type Response_nodesCountOutputType
   */

  export type Response_nodesCountOutputType = {
    response_node_translations: number
    other_response_nodes: number
    response_tree_history: number
    response_tree_sessions: number
  }

  export type Response_nodesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_node_translations?: boolean | Response_nodesCountOutputTypeCountResponse_node_translationsArgs
    other_response_nodes?: boolean | Response_nodesCountOutputTypeCountOther_response_nodesArgs
    response_tree_history?: boolean | Response_nodesCountOutputTypeCountResponse_tree_historyArgs
    response_tree_sessions?: boolean | Response_nodesCountOutputTypeCountResponse_tree_sessionsArgs
  }

  // Custom InputTypes
  /**
   * Response_nodesCountOutputType without action
   */
  export type Response_nodesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response_nodesCountOutputType
     */
    select?: Response_nodesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Response_nodesCountOutputType without action
   */
  export type Response_nodesCountOutputTypeCountResponse_node_translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_node_translationsWhereInput
  }

  /**
   * Response_nodesCountOutputType without action
   */
  export type Response_nodesCountOutputTypeCountOther_response_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_nodesWhereInput
  }

  /**
   * Response_nodesCountOutputType without action
   */
  export type Response_nodesCountOutputTypeCountResponse_tree_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_historyWhereInput
  }

  /**
   * Response_nodesCountOutputType without action
   */
  export type Response_nodesCountOutputTypeCountResponse_tree_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_sessionsWhereInput
  }


  /**
   * Count Type Response_tree_sessionsCountOutputType
   */

  export type Response_tree_sessionsCountOutputType = {
    response_tree_history: number
    response_tree_mobile_links: number
  }

  export type Response_tree_sessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_tree_history?: boolean | Response_tree_sessionsCountOutputTypeCountResponse_tree_historyArgs
    response_tree_mobile_links?: boolean | Response_tree_sessionsCountOutputTypeCountResponse_tree_mobile_linksArgs
  }

  // Custom InputTypes
  /**
   * Response_tree_sessionsCountOutputType without action
   */
  export type Response_tree_sessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response_tree_sessionsCountOutputType
     */
    select?: Response_tree_sessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Response_tree_sessionsCountOutputType without action
   */
  export type Response_tree_sessionsCountOutputTypeCountResponse_tree_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_historyWhereInput
  }

  /**
   * Response_tree_sessionsCountOutputType without action
   */
  export type Response_tree_sessionsCountOutputTypeCountResponse_tree_mobile_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_mobile_linksWhereInput
  }


  /**
   * Count Type Response_treesCountOutputType
   */

  export type Response_treesCountOutputType = {
    response_nodes: number
    response_tree_sessions: number
    response_tree_versions: number
  }

  export type Response_treesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_nodes?: boolean | Response_treesCountOutputTypeCountResponse_nodesArgs
    response_tree_sessions?: boolean | Response_treesCountOutputTypeCountResponse_tree_sessionsArgs
    response_tree_versions?: boolean | Response_treesCountOutputTypeCountResponse_tree_versionsArgs
  }

  // Custom InputTypes
  /**
   * Response_treesCountOutputType without action
   */
  export type Response_treesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response_treesCountOutputType
     */
    select?: Response_treesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Response_treesCountOutputType without action
   */
  export type Response_treesCountOutputTypeCountResponse_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_nodesWhereInput
  }

  /**
   * Response_treesCountOutputType without action
   */
  export type Response_treesCountOutputTypeCountResponse_tree_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_sessionsWhereInput
  }

  /**
   * Response_treesCountOutputType without action
   */
  export type Response_treesCountOutputTypeCountResponse_tree_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_versionsWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    transactions: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | InvoiceCountOutputTypeCountTransactionsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model DatabaseChangeLog
   */

  export type AggregateDatabaseChangeLog = {
    _count: DatabaseChangeLogCountAggregateOutputType | null
    _avg: DatabaseChangeLogAvgAggregateOutputType | null
    _sum: DatabaseChangeLogSumAggregateOutputType | null
    _min: DatabaseChangeLogMinAggregateOutputType | null
    _max: DatabaseChangeLogMaxAggregateOutputType | null
  }

  export type DatabaseChangeLogAvgAggregateOutputType = {
    id: number | null
  }

  export type DatabaseChangeLogSumAggregateOutputType = {
    id: number | null
  }

  export type DatabaseChangeLogMinAggregateOutputType = {
    id: number | null
    changeType: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type DatabaseChangeLogMaxAggregateOutputType = {
    id: number | null
    changeType: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type DatabaseChangeLogCountAggregateOutputType = {
    id: number
    changeType: number
    description: number
    details: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type DatabaseChangeLogAvgAggregateInputType = {
    id?: true
  }

  export type DatabaseChangeLogSumAggregateInputType = {
    id?: true
  }

  export type DatabaseChangeLogMinAggregateInputType = {
    id?: true
    changeType?: true
    description?: true
    createdBy?: true
    createdAt?: true
  }

  export type DatabaseChangeLogMaxAggregateInputType = {
    id?: true
    changeType?: true
    description?: true
    createdBy?: true
    createdAt?: true
  }

  export type DatabaseChangeLogCountAggregateInputType = {
    id?: true
    changeType?: true
    description?: true
    details?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type DatabaseChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseChangeLog to aggregate.
     */
    where?: DatabaseChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseChangeLogs to fetch.
     */
    orderBy?: DatabaseChangeLogOrderByWithRelationInput | DatabaseChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatabaseChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatabaseChangeLogs
    **/
    _count?: true | DatabaseChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatabaseChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatabaseChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatabaseChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatabaseChangeLogMaxAggregateInputType
  }

  export type GetDatabaseChangeLogAggregateType<T extends DatabaseChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDatabaseChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatabaseChangeLog[P]>
      : GetScalarType<T[P], AggregateDatabaseChangeLog[P]>
  }




  export type DatabaseChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseChangeLogWhereInput
    orderBy?: DatabaseChangeLogOrderByWithAggregationInput | DatabaseChangeLogOrderByWithAggregationInput[]
    by: DatabaseChangeLogScalarFieldEnum[] | DatabaseChangeLogScalarFieldEnum
    having?: DatabaseChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatabaseChangeLogCountAggregateInputType | true
    _avg?: DatabaseChangeLogAvgAggregateInputType
    _sum?: DatabaseChangeLogSumAggregateInputType
    _min?: DatabaseChangeLogMinAggregateInputType
    _max?: DatabaseChangeLogMaxAggregateInputType
  }

  export type DatabaseChangeLogGroupByOutputType = {
    id: number
    changeType: string
    description: string
    details: JsonValue | null
    createdBy: string | null
    createdAt: Date
    _count: DatabaseChangeLogCountAggregateOutputType | null
    _avg: DatabaseChangeLogAvgAggregateOutputType | null
    _sum: DatabaseChangeLogSumAggregateOutputType | null
    _min: DatabaseChangeLogMinAggregateOutputType | null
    _max: DatabaseChangeLogMaxAggregateOutputType | null
  }

  type GetDatabaseChangeLogGroupByPayload<T extends DatabaseChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatabaseChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatabaseChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatabaseChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], DatabaseChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type DatabaseChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeType?: boolean
    description?: boolean
    details?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["databaseChangeLog"]>

  export type DatabaseChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeType?: boolean
    description?: boolean
    details?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["databaseChangeLog"]>

  export type DatabaseChangeLogSelectScalar = {
    id?: boolean
    changeType?: boolean
    description?: boolean
    details?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }


  export type $DatabaseChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatabaseChangeLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      changeType: string
      description: string
      details: Prisma.JsonValue | null
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["databaseChangeLog"]>
    composites: {}
  }

  type DatabaseChangeLogGetPayload<S extends boolean | null | undefined | DatabaseChangeLogDefaultArgs> = $Result.GetResult<Prisma.$DatabaseChangeLogPayload, S>

  type DatabaseChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DatabaseChangeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DatabaseChangeLogCountAggregateInputType | true
    }

  export interface DatabaseChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatabaseChangeLog'], meta: { name: 'DatabaseChangeLog' } }
    /**
     * Find zero or one DatabaseChangeLog that matches the filter.
     * @param {DatabaseChangeLogFindUniqueArgs} args - Arguments to find a DatabaseChangeLog
     * @example
     * // Get one DatabaseChangeLog
     * const databaseChangeLog = await prisma.databaseChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatabaseChangeLogFindUniqueArgs>(args: SelectSubset<T, DatabaseChangeLogFindUniqueArgs<ExtArgs>>): Prisma__DatabaseChangeLogClient<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DatabaseChangeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DatabaseChangeLogFindUniqueOrThrowArgs} args - Arguments to find a DatabaseChangeLog
     * @example
     * // Get one DatabaseChangeLog
     * const databaseChangeLog = await prisma.databaseChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatabaseChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DatabaseChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatabaseChangeLogClient<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DatabaseChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseChangeLogFindFirstArgs} args - Arguments to find a DatabaseChangeLog
     * @example
     * // Get one DatabaseChangeLog
     * const databaseChangeLog = await prisma.databaseChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatabaseChangeLogFindFirstArgs>(args?: SelectSubset<T, DatabaseChangeLogFindFirstArgs<ExtArgs>>): Prisma__DatabaseChangeLogClient<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DatabaseChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseChangeLogFindFirstOrThrowArgs} args - Arguments to find a DatabaseChangeLog
     * @example
     * // Get one DatabaseChangeLog
     * const databaseChangeLog = await prisma.databaseChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatabaseChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DatabaseChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatabaseChangeLogClient<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DatabaseChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatabaseChangeLogs
     * const databaseChangeLogs = await prisma.databaseChangeLog.findMany()
     * 
     * // Get first 10 DatabaseChangeLogs
     * const databaseChangeLogs = await prisma.databaseChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const databaseChangeLogWithIdOnly = await prisma.databaseChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatabaseChangeLogFindManyArgs>(args?: SelectSubset<T, DatabaseChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DatabaseChangeLog.
     * @param {DatabaseChangeLogCreateArgs} args - Arguments to create a DatabaseChangeLog.
     * @example
     * // Create one DatabaseChangeLog
     * const DatabaseChangeLog = await prisma.databaseChangeLog.create({
     *   data: {
     *     // ... data to create a DatabaseChangeLog
     *   }
     * })
     * 
     */
    create<T extends DatabaseChangeLogCreateArgs>(args: SelectSubset<T, DatabaseChangeLogCreateArgs<ExtArgs>>): Prisma__DatabaseChangeLogClient<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DatabaseChangeLogs.
     * @param {DatabaseChangeLogCreateManyArgs} args - Arguments to create many DatabaseChangeLogs.
     * @example
     * // Create many DatabaseChangeLogs
     * const databaseChangeLog = await prisma.databaseChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatabaseChangeLogCreateManyArgs>(args?: SelectSubset<T, DatabaseChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatabaseChangeLogs and returns the data saved in the database.
     * @param {DatabaseChangeLogCreateManyAndReturnArgs} args - Arguments to create many DatabaseChangeLogs.
     * @example
     * // Create many DatabaseChangeLogs
     * const databaseChangeLog = await prisma.databaseChangeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatabaseChangeLogs and only return the `id`
     * const databaseChangeLogWithIdOnly = await prisma.databaseChangeLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatabaseChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DatabaseChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DatabaseChangeLog.
     * @param {DatabaseChangeLogDeleteArgs} args - Arguments to delete one DatabaseChangeLog.
     * @example
     * // Delete one DatabaseChangeLog
     * const DatabaseChangeLog = await prisma.databaseChangeLog.delete({
     *   where: {
     *     // ... filter to delete one DatabaseChangeLog
     *   }
     * })
     * 
     */
    delete<T extends DatabaseChangeLogDeleteArgs>(args: SelectSubset<T, DatabaseChangeLogDeleteArgs<ExtArgs>>): Prisma__DatabaseChangeLogClient<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DatabaseChangeLog.
     * @param {DatabaseChangeLogUpdateArgs} args - Arguments to update one DatabaseChangeLog.
     * @example
     * // Update one DatabaseChangeLog
     * const databaseChangeLog = await prisma.databaseChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatabaseChangeLogUpdateArgs>(args: SelectSubset<T, DatabaseChangeLogUpdateArgs<ExtArgs>>): Prisma__DatabaseChangeLogClient<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DatabaseChangeLogs.
     * @param {DatabaseChangeLogDeleteManyArgs} args - Arguments to filter DatabaseChangeLogs to delete.
     * @example
     * // Delete a few DatabaseChangeLogs
     * const { count } = await prisma.databaseChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatabaseChangeLogDeleteManyArgs>(args?: SelectSubset<T, DatabaseChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatabaseChangeLogs
     * const databaseChangeLog = await prisma.databaseChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatabaseChangeLogUpdateManyArgs>(args: SelectSubset<T, DatabaseChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DatabaseChangeLog.
     * @param {DatabaseChangeLogUpsertArgs} args - Arguments to update or create a DatabaseChangeLog.
     * @example
     * // Update or create a DatabaseChangeLog
     * const databaseChangeLog = await prisma.databaseChangeLog.upsert({
     *   create: {
     *     // ... data to create a DatabaseChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatabaseChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends DatabaseChangeLogUpsertArgs>(args: SelectSubset<T, DatabaseChangeLogUpsertArgs<ExtArgs>>): Prisma__DatabaseChangeLogClient<$Result.GetResult<Prisma.$DatabaseChangeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DatabaseChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseChangeLogCountArgs} args - Arguments to filter DatabaseChangeLogs to count.
     * @example
     * // Count the number of DatabaseChangeLogs
     * const count = await prisma.databaseChangeLog.count({
     *   where: {
     *     // ... the filter for the DatabaseChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends DatabaseChangeLogCountArgs>(
      args?: Subset<T, DatabaseChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatabaseChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatabaseChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatabaseChangeLogAggregateArgs>(args: Subset<T, DatabaseChangeLogAggregateArgs>): Prisma.PrismaPromise<GetDatabaseChangeLogAggregateType<T>>

    /**
     * Group by DatabaseChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatabaseChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatabaseChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: DatabaseChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatabaseChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatabaseChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatabaseChangeLog model
   */
  readonly fields: DatabaseChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatabaseChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatabaseChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatabaseChangeLog model
   */ 
  interface DatabaseChangeLogFieldRefs {
    readonly id: FieldRef<"DatabaseChangeLog", 'Int'>
    readonly changeType: FieldRef<"DatabaseChangeLog", 'String'>
    readonly description: FieldRef<"DatabaseChangeLog", 'String'>
    readonly details: FieldRef<"DatabaseChangeLog", 'Json'>
    readonly createdBy: FieldRef<"DatabaseChangeLog", 'String'>
    readonly createdAt: FieldRef<"DatabaseChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DatabaseChangeLog findUnique
   */
  export type DatabaseChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which DatabaseChangeLog to fetch.
     */
    where: DatabaseChangeLogWhereUniqueInput
  }

  /**
   * DatabaseChangeLog findUniqueOrThrow
   */
  export type DatabaseChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which DatabaseChangeLog to fetch.
     */
    where: DatabaseChangeLogWhereUniqueInput
  }

  /**
   * DatabaseChangeLog findFirst
   */
  export type DatabaseChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which DatabaseChangeLog to fetch.
     */
    where?: DatabaseChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseChangeLogs to fetch.
     */
    orderBy?: DatabaseChangeLogOrderByWithRelationInput | DatabaseChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseChangeLogs.
     */
    cursor?: DatabaseChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseChangeLogs.
     */
    distinct?: DatabaseChangeLogScalarFieldEnum | DatabaseChangeLogScalarFieldEnum[]
  }

  /**
   * DatabaseChangeLog findFirstOrThrow
   */
  export type DatabaseChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which DatabaseChangeLog to fetch.
     */
    where?: DatabaseChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseChangeLogs to fetch.
     */
    orderBy?: DatabaseChangeLogOrderByWithRelationInput | DatabaseChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseChangeLogs.
     */
    cursor?: DatabaseChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseChangeLogs.
     */
    distinct?: DatabaseChangeLogScalarFieldEnum | DatabaseChangeLogScalarFieldEnum[]
  }

  /**
   * DatabaseChangeLog findMany
   */
  export type DatabaseChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
    /**
     * Filter, which DatabaseChangeLogs to fetch.
     */
    where?: DatabaseChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseChangeLogs to fetch.
     */
    orderBy?: DatabaseChangeLogOrderByWithRelationInput | DatabaseChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatabaseChangeLogs.
     */
    cursor?: DatabaseChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseChangeLogs.
     */
    skip?: number
    distinct?: DatabaseChangeLogScalarFieldEnum | DatabaseChangeLogScalarFieldEnum[]
  }

  /**
   * DatabaseChangeLog create
   */
  export type DatabaseChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
    /**
     * The data needed to create a DatabaseChangeLog.
     */
    data: XOR<DatabaseChangeLogCreateInput, DatabaseChangeLogUncheckedCreateInput>
  }

  /**
   * DatabaseChangeLog createMany
   */
  export type DatabaseChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatabaseChangeLogs.
     */
    data: DatabaseChangeLogCreateManyInput | DatabaseChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatabaseChangeLog createManyAndReturn
   */
  export type DatabaseChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DatabaseChangeLogs.
     */
    data: DatabaseChangeLogCreateManyInput | DatabaseChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatabaseChangeLog update
   */
  export type DatabaseChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
    /**
     * The data needed to update a DatabaseChangeLog.
     */
    data: XOR<DatabaseChangeLogUpdateInput, DatabaseChangeLogUncheckedUpdateInput>
    /**
     * Choose, which DatabaseChangeLog to update.
     */
    where: DatabaseChangeLogWhereUniqueInput
  }

  /**
   * DatabaseChangeLog updateMany
   */
  export type DatabaseChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatabaseChangeLogs.
     */
    data: XOR<DatabaseChangeLogUpdateManyMutationInput, DatabaseChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseChangeLogs to update
     */
    where?: DatabaseChangeLogWhereInput
  }

  /**
   * DatabaseChangeLog upsert
   */
  export type DatabaseChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
    /**
     * The filter to search for the DatabaseChangeLog to update in case it exists.
     */
    where: DatabaseChangeLogWhereUniqueInput
    /**
     * In case the DatabaseChangeLog found by the `where` argument doesn't exist, create a new DatabaseChangeLog with this data.
     */
    create: XOR<DatabaseChangeLogCreateInput, DatabaseChangeLogUncheckedCreateInput>
    /**
     * In case the DatabaseChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatabaseChangeLogUpdateInput, DatabaseChangeLogUncheckedUpdateInput>
  }

  /**
   * DatabaseChangeLog delete
   */
  export type DatabaseChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
    /**
     * Filter which DatabaseChangeLog to delete.
     */
    where: DatabaseChangeLogWhereUniqueInput
  }

  /**
   * DatabaseChangeLog deleteMany
   */
  export type DatabaseChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseChangeLogs to delete
     */
    where?: DatabaseChangeLogWhereInput
  }

  /**
   * DatabaseChangeLog without action
   */
  export type DatabaseChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseChangeLog
     */
    select?: DatabaseChangeLogSelect<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    placeId: number | null
    total: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    placeId: number | null
    total: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    tenantId: string | null
    roomId: string | null
    placeId: number | null
    status: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
    paidAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
    uuid: string | null
    sessionId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    tenantId: string | null
    roomId: string | null
    placeId: number | null
    status: string | null
    total: number | null
    createdAt: Date | null
    updatedAt: Date | null
    paidAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
    uuid: string | null
    sessionId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    tenantId: number
    roomId: number
    placeId: number
    status: number
    items: number
    total: number
    createdAt: number
    updatedAt: number
    paidAt: number
    isDeleted: number
    deletedAt: number
    uuid: number
    sessionId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    placeId?: true
    total?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    placeId?: true
    total?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    placeId?: true
    status?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    isDeleted?: true
    deletedAt?: true
    uuid?: true
    sessionId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    placeId?: true
    status?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    isDeleted?: true
    deletedAt?: true
    uuid?: true
    sessionId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    placeId?: true
    status?: true
    items?: true
    total?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    isDeleted?: true
    deletedAt?: true
    uuid?: true
    sessionId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    tenantId: string
    roomId: string
    placeId: number | null
    status: string
    items: JsonValue
    total: number
    createdAt: Date
    updatedAt: Date
    paidAt: Date | null
    isDeleted: boolean
    deletedAt: Date | null
    uuid: string | null
    sessionId: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    placeId?: boolean
    status?: boolean
    items?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    uuid?: boolean
    sessionId?: boolean
    OrderItem?: boolean | Order$OrderItemArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    placeId?: boolean
    status?: boolean
    items?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    uuid?: boolean
    sessionId?: boolean
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    placeId?: boolean
    status?: boolean
    items?: boolean
    total?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    uuid?: boolean
    sessionId?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderItem?: boolean | Order$OrderItemArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      OrderItem: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tenantId: string
      roomId: string
      placeId: number | null
      status: string
      items: Prisma.JsonValue
      total: number
      createdAt: Date
      updatedAt: Date
      paidAt: Date | null
      isDeleted: boolean
      deletedAt: Date | null
      uuid: string | null
      sessionId: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrderItem<T extends Order$OrderItemArgs<ExtArgs> = {}>(args?: Subset<T, Order$OrderItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly tenantId: FieldRef<"Order", 'String'>
    readonly roomId: FieldRef<"Order", 'String'>
    readonly placeId: FieldRef<"Order", 'Int'>
    readonly status: FieldRef<"Order", 'String'>
    readonly items: FieldRef<"Order", 'Json'>
    readonly total: FieldRef<"Order", 'Int'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly paidAt: FieldRef<"Order", 'DateTime'>
    readonly isDeleted: FieldRef<"Order", 'Boolean'>
    readonly deletedAt: FieldRef<"Order", 'DateTime'>
    readonly uuid: FieldRef<"Order", 'String'>
    readonly sessionId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.OrderItem
   */
  export type Order$OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    menuItemId: number | null
    price: number | null
    quantity: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    menuItemId: number | null
    price: number | null
    quantity: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    tenantId: string | null
    orderId: number | null
    menuItemId: number | null
    name: string | null
    price: number | null
    quantity: number | null
    status: string | null
    notes: string | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    tenantId: string | null
    orderId: number | null
    menuItemId: number | null
    name: string | null
    price: number | null
    quantity: number | null
    status: string | null
    notes: string | null
    deliveredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    tenantId: number
    orderId: number
    menuItemId: number
    name: number
    price: number
    quantity: number
    status: number
    notes: number
    deliveredAt: number
    createdAt: number
    updatedAt: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    menuItemId?: true
    price?: true
    quantity?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    menuItemId?: true
    price?: true
    quantity?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    menuItemId?: true
    name?: true
    price?: true
    quantity?: true
    status?: true
    notes?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    menuItemId?: true
    name?: true
    price?: true
    quantity?: true
    status?: true
    notes?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    menuItemId?: true
    name?: true
    price?: true
    quantity?: true
    status?: true
    notes?: true
    deliveredAt?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    tenantId: string
    orderId: number
    menuItemId: number
    name: string
    price: number
    quantity: number
    status: string
    notes: string | null
    deliveredAt: Date | null
    createdAt: Date
    updatedAt: Date
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    menuItemId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    status?: boolean
    notes?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    Order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    menuItemId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    status?: boolean
    notes?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    Order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    menuItemId?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    status?: boolean
    notes?: boolean
    deliveredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      Order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tenantId: string
      orderId: number
      menuItemId: number
      name: string
      price: number
      quantity: number
      status: string
      notes: string | null
      deliveredAt: Date | null
      createdAt: Date
      updatedAt: Date
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly tenantId: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly menuItemId: FieldRef<"OrderItem", 'Int'>
    readonly name: FieldRef<"OrderItem", 'String'>
    readonly price: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly status: FieldRef<"OrderItem", 'String'>
    readonly notes: FieldRef<"OrderItem", 'String'>
    readonly deliveredAt: FieldRef<"OrderItem", 'DateTime'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly deleted_at: FieldRef<"OrderItem", 'DateTime'>
    readonly deleted_by: FieldRef<"OrderItem", 'String'>
    readonly is_deleted: FieldRef<"OrderItem", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model SystemPlanRestrictions
   */

  export type AggregateSystemPlanRestrictions = {
    _count: SystemPlanRestrictionsCountAggregateOutputType | null
    _avg: SystemPlanRestrictionsAvgAggregateOutputType | null
    _sum: SystemPlanRestrictionsSumAggregateOutputType | null
    _min: SystemPlanRestrictionsMinAggregateOutputType | null
    _max: SystemPlanRestrictionsMaxAggregateOutputType | null
  }

  export type SystemPlanRestrictionsAvgAggregateOutputType = {
    monthlyPrice: number | null
    maxDevices: number | null
    additionalDeviceCost: number | null
    roomTerminalCost: number | null
    frontDeskCost: number | null
    kitchenCost: number | null
    barCost: number | null
    housekeepingCost: number | null
    managerCost: number | null
    commonAreaCost: number | null
    maxMonthlyOrders: number | null
    maxMonthlyAiRequests: number | null
    maxStorageGB: number | null
    multilingualUpgradePrice: number | null
  }

  export type SystemPlanRestrictionsSumAggregateOutputType = {
    monthlyPrice: number | null
    maxDevices: number | null
    additionalDeviceCost: number | null
    roomTerminalCost: number | null
    frontDeskCost: number | null
    kitchenCost: number | null
    barCost: number | null
    housekeepingCost: number | null
    managerCost: number | null
    commonAreaCost: number | null
    maxMonthlyOrders: number | null
    maxMonthlyAiRequests: number | null
    maxStorageGB: number | null
    multilingualUpgradePrice: number | null
  }

  export type SystemPlanRestrictionsMinAggregateOutputType = {
    id: string | null
    systemType: string | null
    businessType: string | null
    planType: string | null
    planCategory: string | null
    monthlyPrice: number | null
    maxDevices: number | null
    additionalDeviceCost: number | null
    roomTerminalCost: number | null
    frontDeskCost: number | null
    kitchenCost: number | null
    barCost: number | null
    housekeepingCost: number | null
    managerCost: number | null
    commonAreaCost: number | null
    enableAiConcierge: boolean | null
    enableMultilingual: boolean | null
    enableLayoutEditor: boolean | null
    enableFacilityGuide: boolean | null
    enableAiBusinessSupport: boolean | null
    maxMonthlyOrders: number | null
    maxMonthlyAiRequests: number | null
    maxStorageGB: number | null
    multilingualUpgradePrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type SystemPlanRestrictionsMaxAggregateOutputType = {
    id: string | null
    systemType: string | null
    businessType: string | null
    planType: string | null
    planCategory: string | null
    monthlyPrice: number | null
    maxDevices: number | null
    additionalDeviceCost: number | null
    roomTerminalCost: number | null
    frontDeskCost: number | null
    kitchenCost: number | null
    barCost: number | null
    housekeepingCost: number | null
    managerCost: number | null
    commonAreaCost: number | null
    enableAiConcierge: boolean | null
    enableMultilingual: boolean | null
    enableLayoutEditor: boolean | null
    enableFacilityGuide: boolean | null
    enableAiBusinessSupport: boolean | null
    maxMonthlyOrders: number | null
    maxMonthlyAiRequests: number | null
    maxStorageGB: number | null
    multilingualUpgradePrice: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type SystemPlanRestrictionsCountAggregateOutputType = {
    id: number
    systemType: number
    businessType: number
    planType: number
    planCategory: number
    monthlyPrice: number
    maxDevices: number
    additionalDeviceCost: number
    roomTerminalCost: number
    frontDeskCost: number
    kitchenCost: number
    barCost: number
    housekeepingCost: number
    managerCost: number
    commonAreaCost: number
    enableAiConcierge: number
    enableMultilingual: number
    enableLayoutEditor: number
    enableFacilityGuide: number
    enableAiBusinessSupport: number
    maxMonthlyOrders: number
    maxMonthlyAiRequests: number
    maxStorageGB: number
    multilingualUpgradePrice: number
    description: number
    createdAt: number
    updatedAt: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type SystemPlanRestrictionsAvgAggregateInputType = {
    monthlyPrice?: true
    maxDevices?: true
    additionalDeviceCost?: true
    roomTerminalCost?: true
    frontDeskCost?: true
    kitchenCost?: true
    barCost?: true
    housekeepingCost?: true
    managerCost?: true
    commonAreaCost?: true
    maxMonthlyOrders?: true
    maxMonthlyAiRequests?: true
    maxStorageGB?: true
    multilingualUpgradePrice?: true
  }

  export type SystemPlanRestrictionsSumAggregateInputType = {
    monthlyPrice?: true
    maxDevices?: true
    additionalDeviceCost?: true
    roomTerminalCost?: true
    frontDeskCost?: true
    kitchenCost?: true
    barCost?: true
    housekeepingCost?: true
    managerCost?: true
    commonAreaCost?: true
    maxMonthlyOrders?: true
    maxMonthlyAiRequests?: true
    maxStorageGB?: true
    multilingualUpgradePrice?: true
  }

  export type SystemPlanRestrictionsMinAggregateInputType = {
    id?: true
    systemType?: true
    businessType?: true
    planType?: true
    planCategory?: true
    monthlyPrice?: true
    maxDevices?: true
    additionalDeviceCost?: true
    roomTerminalCost?: true
    frontDeskCost?: true
    kitchenCost?: true
    barCost?: true
    housekeepingCost?: true
    managerCost?: true
    commonAreaCost?: true
    enableAiConcierge?: true
    enableMultilingual?: true
    enableLayoutEditor?: true
    enableFacilityGuide?: true
    enableAiBusinessSupport?: true
    maxMonthlyOrders?: true
    maxMonthlyAiRequests?: true
    maxStorageGB?: true
    multilingualUpgradePrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type SystemPlanRestrictionsMaxAggregateInputType = {
    id?: true
    systemType?: true
    businessType?: true
    planType?: true
    planCategory?: true
    monthlyPrice?: true
    maxDevices?: true
    additionalDeviceCost?: true
    roomTerminalCost?: true
    frontDeskCost?: true
    kitchenCost?: true
    barCost?: true
    housekeepingCost?: true
    managerCost?: true
    commonAreaCost?: true
    enableAiConcierge?: true
    enableMultilingual?: true
    enableLayoutEditor?: true
    enableFacilityGuide?: true
    enableAiBusinessSupport?: true
    maxMonthlyOrders?: true
    maxMonthlyAiRequests?: true
    maxStorageGB?: true
    multilingualUpgradePrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type SystemPlanRestrictionsCountAggregateInputType = {
    id?: true
    systemType?: true
    businessType?: true
    planType?: true
    planCategory?: true
    monthlyPrice?: true
    maxDevices?: true
    additionalDeviceCost?: true
    roomTerminalCost?: true
    frontDeskCost?: true
    kitchenCost?: true
    barCost?: true
    housekeepingCost?: true
    managerCost?: true
    commonAreaCost?: true
    enableAiConcierge?: true
    enableMultilingual?: true
    enableLayoutEditor?: true
    enableFacilityGuide?: true
    enableAiBusinessSupport?: true
    maxMonthlyOrders?: true
    maxMonthlyAiRequests?: true
    maxStorageGB?: true
    multilingualUpgradePrice?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type SystemPlanRestrictionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemPlanRestrictions to aggregate.
     */
    where?: SystemPlanRestrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemPlanRestrictions to fetch.
     */
    orderBy?: SystemPlanRestrictionsOrderByWithRelationInput | SystemPlanRestrictionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemPlanRestrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemPlanRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemPlanRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemPlanRestrictions
    **/
    _count?: true | SystemPlanRestrictionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemPlanRestrictionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemPlanRestrictionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemPlanRestrictionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemPlanRestrictionsMaxAggregateInputType
  }

  export type GetSystemPlanRestrictionsAggregateType<T extends SystemPlanRestrictionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemPlanRestrictions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemPlanRestrictions[P]>
      : GetScalarType<T[P], AggregateSystemPlanRestrictions[P]>
  }




  export type SystemPlanRestrictionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemPlanRestrictionsWhereInput
    orderBy?: SystemPlanRestrictionsOrderByWithAggregationInput | SystemPlanRestrictionsOrderByWithAggregationInput[]
    by: SystemPlanRestrictionsScalarFieldEnum[] | SystemPlanRestrictionsScalarFieldEnum
    having?: SystemPlanRestrictionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemPlanRestrictionsCountAggregateInputType | true
    _avg?: SystemPlanRestrictionsAvgAggregateInputType
    _sum?: SystemPlanRestrictionsSumAggregateInputType
    _min?: SystemPlanRestrictionsMinAggregateInputType
    _max?: SystemPlanRestrictionsMaxAggregateInputType
  }

  export type SystemPlanRestrictionsGroupByOutputType = {
    id: string
    systemType: string
    businessType: string
    planType: string
    planCategory: string
    monthlyPrice: number
    maxDevices: number
    additionalDeviceCost: number
    roomTerminalCost: number
    frontDeskCost: number
    kitchenCost: number
    barCost: number
    housekeepingCost: number
    managerCost: number
    commonAreaCost: number
    enableAiConcierge: boolean
    enableMultilingual: boolean
    enableLayoutEditor: boolean
    enableFacilityGuide: boolean
    enableAiBusinessSupport: boolean
    maxMonthlyOrders: number
    maxMonthlyAiRequests: number
    maxStorageGB: number
    multilingualUpgradePrice: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: SystemPlanRestrictionsCountAggregateOutputType | null
    _avg: SystemPlanRestrictionsAvgAggregateOutputType | null
    _sum: SystemPlanRestrictionsSumAggregateOutputType | null
    _min: SystemPlanRestrictionsMinAggregateOutputType | null
    _max: SystemPlanRestrictionsMaxAggregateOutputType | null
  }

  type GetSystemPlanRestrictionsGroupByPayload<T extends SystemPlanRestrictionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemPlanRestrictionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemPlanRestrictionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemPlanRestrictionsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemPlanRestrictionsGroupByOutputType[P]>
        }
      >
    >


  export type SystemPlanRestrictionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemType?: boolean
    businessType?: boolean
    planType?: boolean
    planCategory?: boolean
    monthlyPrice?: boolean
    maxDevices?: boolean
    additionalDeviceCost?: boolean
    roomTerminalCost?: boolean
    frontDeskCost?: boolean
    kitchenCost?: boolean
    barCost?: boolean
    housekeepingCost?: boolean
    managerCost?: boolean
    commonAreaCost?: boolean
    enableAiConcierge?: boolean
    enableMultilingual?: boolean
    enableLayoutEditor?: boolean
    enableFacilityGuide?: boolean
    enableAiBusinessSupport?: boolean
    maxMonthlyOrders?: boolean
    maxMonthlyAiRequests?: boolean
    maxStorageGB?: boolean
    multilingualUpgradePrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    TenantSystemPlan?: boolean | SystemPlanRestrictions$TenantSystemPlanArgs<ExtArgs>
    _count?: boolean | SystemPlanRestrictionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemPlanRestrictions"]>

  export type SystemPlanRestrictionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemType?: boolean
    businessType?: boolean
    planType?: boolean
    planCategory?: boolean
    monthlyPrice?: boolean
    maxDevices?: boolean
    additionalDeviceCost?: boolean
    roomTerminalCost?: boolean
    frontDeskCost?: boolean
    kitchenCost?: boolean
    barCost?: boolean
    housekeepingCost?: boolean
    managerCost?: boolean
    commonAreaCost?: boolean
    enableAiConcierge?: boolean
    enableMultilingual?: boolean
    enableLayoutEditor?: boolean
    enableFacilityGuide?: boolean
    enableAiBusinessSupport?: boolean
    maxMonthlyOrders?: boolean
    maxMonthlyAiRequests?: boolean
    maxStorageGB?: boolean
    multilingualUpgradePrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["systemPlanRestrictions"]>

  export type SystemPlanRestrictionsSelectScalar = {
    id?: boolean
    systemType?: boolean
    businessType?: boolean
    planType?: boolean
    planCategory?: boolean
    monthlyPrice?: boolean
    maxDevices?: boolean
    additionalDeviceCost?: boolean
    roomTerminalCost?: boolean
    frontDeskCost?: boolean
    kitchenCost?: boolean
    barCost?: boolean
    housekeepingCost?: boolean
    managerCost?: boolean
    commonAreaCost?: boolean
    enableAiConcierge?: boolean
    enableMultilingual?: boolean
    enableLayoutEditor?: boolean
    enableFacilityGuide?: boolean
    enableAiBusinessSupport?: boolean
    maxMonthlyOrders?: boolean
    maxMonthlyAiRequests?: boolean
    maxStorageGB?: boolean
    multilingualUpgradePrice?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type SystemPlanRestrictionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TenantSystemPlan?: boolean | SystemPlanRestrictions$TenantSystemPlanArgs<ExtArgs>
    _count?: boolean | SystemPlanRestrictionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SystemPlanRestrictionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SystemPlanRestrictionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemPlanRestrictions"
    objects: {
      TenantSystemPlan: Prisma.$TenantSystemPlanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      systemType: string
      businessType: string
      planType: string
      planCategory: string
      monthlyPrice: number
      maxDevices: number
      additionalDeviceCost: number
      roomTerminalCost: number
      frontDeskCost: number
      kitchenCost: number
      barCost: number
      housekeepingCost: number
      managerCost: number
      commonAreaCost: number
      enableAiConcierge: boolean
      enableMultilingual: boolean
      enableLayoutEditor: boolean
      enableFacilityGuide: boolean
      enableAiBusinessSupport: boolean
      maxMonthlyOrders: number
      maxMonthlyAiRequests: number
      maxStorageGB: number
      multilingualUpgradePrice: number
      description: string | null
      createdAt: Date
      updatedAt: Date
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["systemPlanRestrictions"]>
    composites: {}
  }

  type SystemPlanRestrictionsGetPayload<S extends boolean | null | undefined | SystemPlanRestrictionsDefaultArgs> = $Result.GetResult<Prisma.$SystemPlanRestrictionsPayload, S>

  type SystemPlanRestrictionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemPlanRestrictionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemPlanRestrictionsCountAggregateInputType | true
    }

  export interface SystemPlanRestrictionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemPlanRestrictions'], meta: { name: 'SystemPlanRestrictions' } }
    /**
     * Find zero or one SystemPlanRestrictions that matches the filter.
     * @param {SystemPlanRestrictionsFindUniqueArgs} args - Arguments to find a SystemPlanRestrictions
     * @example
     * // Get one SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemPlanRestrictionsFindUniqueArgs>(args: SelectSubset<T, SystemPlanRestrictionsFindUniqueArgs<ExtArgs>>): Prisma__SystemPlanRestrictionsClient<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemPlanRestrictions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemPlanRestrictionsFindUniqueOrThrowArgs} args - Arguments to find a SystemPlanRestrictions
     * @example
     * // Get one SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemPlanRestrictionsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemPlanRestrictionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemPlanRestrictionsClient<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemPlanRestrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPlanRestrictionsFindFirstArgs} args - Arguments to find a SystemPlanRestrictions
     * @example
     * // Get one SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemPlanRestrictionsFindFirstArgs>(args?: SelectSubset<T, SystemPlanRestrictionsFindFirstArgs<ExtArgs>>): Prisma__SystemPlanRestrictionsClient<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemPlanRestrictions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPlanRestrictionsFindFirstOrThrowArgs} args - Arguments to find a SystemPlanRestrictions
     * @example
     * // Get one SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemPlanRestrictionsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemPlanRestrictionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemPlanRestrictionsClient<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemPlanRestrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPlanRestrictionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.findMany()
     * 
     * // Get first 10 SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemPlanRestrictionsWithIdOnly = await prisma.systemPlanRestrictions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemPlanRestrictionsFindManyArgs>(args?: SelectSubset<T, SystemPlanRestrictionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemPlanRestrictions.
     * @param {SystemPlanRestrictionsCreateArgs} args - Arguments to create a SystemPlanRestrictions.
     * @example
     * // Create one SystemPlanRestrictions
     * const SystemPlanRestrictions = await prisma.systemPlanRestrictions.create({
     *   data: {
     *     // ... data to create a SystemPlanRestrictions
     *   }
     * })
     * 
     */
    create<T extends SystemPlanRestrictionsCreateArgs>(args: SelectSubset<T, SystemPlanRestrictionsCreateArgs<ExtArgs>>): Prisma__SystemPlanRestrictionsClient<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemPlanRestrictions.
     * @param {SystemPlanRestrictionsCreateManyArgs} args - Arguments to create many SystemPlanRestrictions.
     * @example
     * // Create many SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemPlanRestrictionsCreateManyArgs>(args?: SelectSubset<T, SystemPlanRestrictionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemPlanRestrictions and returns the data saved in the database.
     * @param {SystemPlanRestrictionsCreateManyAndReturnArgs} args - Arguments to create many SystemPlanRestrictions.
     * @example
     * // Create many SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemPlanRestrictions and only return the `id`
     * const systemPlanRestrictionsWithIdOnly = await prisma.systemPlanRestrictions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemPlanRestrictionsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemPlanRestrictionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemPlanRestrictions.
     * @param {SystemPlanRestrictionsDeleteArgs} args - Arguments to delete one SystemPlanRestrictions.
     * @example
     * // Delete one SystemPlanRestrictions
     * const SystemPlanRestrictions = await prisma.systemPlanRestrictions.delete({
     *   where: {
     *     // ... filter to delete one SystemPlanRestrictions
     *   }
     * })
     * 
     */
    delete<T extends SystemPlanRestrictionsDeleteArgs>(args: SelectSubset<T, SystemPlanRestrictionsDeleteArgs<ExtArgs>>): Prisma__SystemPlanRestrictionsClient<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemPlanRestrictions.
     * @param {SystemPlanRestrictionsUpdateArgs} args - Arguments to update one SystemPlanRestrictions.
     * @example
     * // Update one SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemPlanRestrictionsUpdateArgs>(args: SelectSubset<T, SystemPlanRestrictionsUpdateArgs<ExtArgs>>): Prisma__SystemPlanRestrictionsClient<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemPlanRestrictions.
     * @param {SystemPlanRestrictionsDeleteManyArgs} args - Arguments to filter SystemPlanRestrictions to delete.
     * @example
     * // Delete a few SystemPlanRestrictions
     * const { count } = await prisma.systemPlanRestrictions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemPlanRestrictionsDeleteManyArgs>(args?: SelectSubset<T, SystemPlanRestrictionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemPlanRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPlanRestrictionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemPlanRestrictionsUpdateManyArgs>(args: SelectSubset<T, SystemPlanRestrictionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemPlanRestrictions.
     * @param {SystemPlanRestrictionsUpsertArgs} args - Arguments to update or create a SystemPlanRestrictions.
     * @example
     * // Update or create a SystemPlanRestrictions
     * const systemPlanRestrictions = await prisma.systemPlanRestrictions.upsert({
     *   create: {
     *     // ... data to create a SystemPlanRestrictions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemPlanRestrictions we want to update
     *   }
     * })
     */
    upsert<T extends SystemPlanRestrictionsUpsertArgs>(args: SelectSubset<T, SystemPlanRestrictionsUpsertArgs<ExtArgs>>): Prisma__SystemPlanRestrictionsClient<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemPlanRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPlanRestrictionsCountArgs} args - Arguments to filter SystemPlanRestrictions to count.
     * @example
     * // Count the number of SystemPlanRestrictions
     * const count = await prisma.systemPlanRestrictions.count({
     *   where: {
     *     // ... the filter for the SystemPlanRestrictions we want to count
     *   }
     * })
    **/
    count<T extends SystemPlanRestrictionsCountArgs>(
      args?: Subset<T, SystemPlanRestrictionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemPlanRestrictionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemPlanRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPlanRestrictionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemPlanRestrictionsAggregateArgs>(args: Subset<T, SystemPlanRestrictionsAggregateArgs>): Prisma.PrismaPromise<GetSystemPlanRestrictionsAggregateType<T>>

    /**
     * Group by SystemPlanRestrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPlanRestrictionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemPlanRestrictionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemPlanRestrictionsGroupByArgs['orderBy'] }
        : { orderBy?: SystemPlanRestrictionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemPlanRestrictionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemPlanRestrictionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemPlanRestrictions model
   */
  readonly fields: SystemPlanRestrictionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemPlanRestrictions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemPlanRestrictionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TenantSystemPlan<T extends SystemPlanRestrictions$TenantSystemPlanArgs<ExtArgs> = {}>(args?: Subset<T, SystemPlanRestrictions$TenantSystemPlanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemPlanRestrictions model
   */ 
  interface SystemPlanRestrictionsFieldRefs {
    readonly id: FieldRef<"SystemPlanRestrictions", 'String'>
    readonly systemType: FieldRef<"SystemPlanRestrictions", 'String'>
    readonly businessType: FieldRef<"SystemPlanRestrictions", 'String'>
    readonly planType: FieldRef<"SystemPlanRestrictions", 'String'>
    readonly planCategory: FieldRef<"SystemPlanRestrictions", 'String'>
    readonly monthlyPrice: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly maxDevices: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly additionalDeviceCost: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly roomTerminalCost: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly frontDeskCost: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly kitchenCost: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly barCost: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly housekeepingCost: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly managerCost: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly commonAreaCost: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly enableAiConcierge: FieldRef<"SystemPlanRestrictions", 'Boolean'>
    readonly enableMultilingual: FieldRef<"SystemPlanRestrictions", 'Boolean'>
    readonly enableLayoutEditor: FieldRef<"SystemPlanRestrictions", 'Boolean'>
    readonly enableFacilityGuide: FieldRef<"SystemPlanRestrictions", 'Boolean'>
    readonly enableAiBusinessSupport: FieldRef<"SystemPlanRestrictions", 'Boolean'>
    readonly maxMonthlyOrders: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly maxMonthlyAiRequests: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly maxStorageGB: FieldRef<"SystemPlanRestrictions", 'Float'>
    readonly multilingualUpgradePrice: FieldRef<"SystemPlanRestrictions", 'Int'>
    readonly description: FieldRef<"SystemPlanRestrictions", 'String'>
    readonly createdAt: FieldRef<"SystemPlanRestrictions", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemPlanRestrictions", 'DateTime'>
    readonly deleted_at: FieldRef<"SystemPlanRestrictions", 'DateTime'>
    readonly deleted_by: FieldRef<"SystemPlanRestrictions", 'String'>
    readonly is_deleted: FieldRef<"SystemPlanRestrictions", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SystemPlanRestrictions findUnique
   */
  export type SystemPlanRestrictionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
    /**
     * Filter, which SystemPlanRestrictions to fetch.
     */
    where: SystemPlanRestrictionsWhereUniqueInput
  }

  /**
   * SystemPlanRestrictions findUniqueOrThrow
   */
  export type SystemPlanRestrictionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
    /**
     * Filter, which SystemPlanRestrictions to fetch.
     */
    where: SystemPlanRestrictionsWhereUniqueInput
  }

  /**
   * SystemPlanRestrictions findFirst
   */
  export type SystemPlanRestrictionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
    /**
     * Filter, which SystemPlanRestrictions to fetch.
     */
    where?: SystemPlanRestrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemPlanRestrictions to fetch.
     */
    orderBy?: SystemPlanRestrictionsOrderByWithRelationInput | SystemPlanRestrictionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemPlanRestrictions.
     */
    cursor?: SystemPlanRestrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemPlanRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemPlanRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemPlanRestrictions.
     */
    distinct?: SystemPlanRestrictionsScalarFieldEnum | SystemPlanRestrictionsScalarFieldEnum[]
  }

  /**
   * SystemPlanRestrictions findFirstOrThrow
   */
  export type SystemPlanRestrictionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
    /**
     * Filter, which SystemPlanRestrictions to fetch.
     */
    where?: SystemPlanRestrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemPlanRestrictions to fetch.
     */
    orderBy?: SystemPlanRestrictionsOrderByWithRelationInput | SystemPlanRestrictionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemPlanRestrictions.
     */
    cursor?: SystemPlanRestrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemPlanRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemPlanRestrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemPlanRestrictions.
     */
    distinct?: SystemPlanRestrictionsScalarFieldEnum | SystemPlanRestrictionsScalarFieldEnum[]
  }

  /**
   * SystemPlanRestrictions findMany
   */
  export type SystemPlanRestrictionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
    /**
     * Filter, which SystemPlanRestrictions to fetch.
     */
    where?: SystemPlanRestrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemPlanRestrictions to fetch.
     */
    orderBy?: SystemPlanRestrictionsOrderByWithRelationInput | SystemPlanRestrictionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemPlanRestrictions.
     */
    cursor?: SystemPlanRestrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemPlanRestrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemPlanRestrictions.
     */
    skip?: number
    distinct?: SystemPlanRestrictionsScalarFieldEnum | SystemPlanRestrictionsScalarFieldEnum[]
  }

  /**
   * SystemPlanRestrictions create
   */
  export type SystemPlanRestrictionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemPlanRestrictions.
     */
    data: XOR<SystemPlanRestrictionsCreateInput, SystemPlanRestrictionsUncheckedCreateInput>
  }

  /**
   * SystemPlanRestrictions createMany
   */
  export type SystemPlanRestrictionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemPlanRestrictions.
     */
    data: SystemPlanRestrictionsCreateManyInput | SystemPlanRestrictionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemPlanRestrictions createManyAndReturn
   */
  export type SystemPlanRestrictionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemPlanRestrictions.
     */
    data: SystemPlanRestrictionsCreateManyInput | SystemPlanRestrictionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemPlanRestrictions update
   */
  export type SystemPlanRestrictionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemPlanRestrictions.
     */
    data: XOR<SystemPlanRestrictionsUpdateInput, SystemPlanRestrictionsUncheckedUpdateInput>
    /**
     * Choose, which SystemPlanRestrictions to update.
     */
    where: SystemPlanRestrictionsWhereUniqueInput
  }

  /**
   * SystemPlanRestrictions updateMany
   */
  export type SystemPlanRestrictionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemPlanRestrictions.
     */
    data: XOR<SystemPlanRestrictionsUpdateManyMutationInput, SystemPlanRestrictionsUncheckedUpdateManyInput>
    /**
     * Filter which SystemPlanRestrictions to update
     */
    where?: SystemPlanRestrictionsWhereInput
  }

  /**
   * SystemPlanRestrictions upsert
   */
  export type SystemPlanRestrictionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemPlanRestrictions to update in case it exists.
     */
    where: SystemPlanRestrictionsWhereUniqueInput
    /**
     * In case the SystemPlanRestrictions found by the `where` argument doesn't exist, create a new SystemPlanRestrictions with this data.
     */
    create: XOR<SystemPlanRestrictionsCreateInput, SystemPlanRestrictionsUncheckedCreateInput>
    /**
     * In case the SystemPlanRestrictions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemPlanRestrictionsUpdateInput, SystemPlanRestrictionsUncheckedUpdateInput>
  }

  /**
   * SystemPlanRestrictions delete
   */
  export type SystemPlanRestrictionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
    /**
     * Filter which SystemPlanRestrictions to delete.
     */
    where: SystemPlanRestrictionsWhereUniqueInput
  }

  /**
   * SystemPlanRestrictions deleteMany
   */
  export type SystemPlanRestrictionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemPlanRestrictions to delete
     */
    where?: SystemPlanRestrictionsWhereInput
  }

  /**
   * SystemPlanRestrictions.TenantSystemPlan
   */
  export type SystemPlanRestrictions$TenantSystemPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    where?: TenantSystemPlanWhereInput
    orderBy?: TenantSystemPlanOrderByWithRelationInput | TenantSystemPlanOrderByWithRelationInput[]
    cursor?: TenantSystemPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantSystemPlanScalarFieldEnum | TenantSystemPlanScalarFieldEnum[]
  }

  /**
   * SystemPlanRestrictions without action
   */
  export type SystemPlanRestrictionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPlanRestrictions
     */
    select?: SystemPlanRestrictionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemPlanRestrictionsInclude<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    contactEmail: string | null
    createdAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
    planType: string | null
    status: string | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    contactEmail: string | null
    createdAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
    planType: string | null
    status: string | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    contactEmail: number
    createdAt: number
    deleted_at: number
    deleted_by: number
    features: number
    is_deleted: number
    planType: number
    settings: number
    status: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    contactEmail?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    planType?: true
    status?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    contactEmail?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    planType?: true
    status?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    contactEmail?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    features?: true
    is_deleted?: true
    planType?: true
    settings?: true
    status?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    domain: string | null
    contactEmail: string | null
    createdAt: Date
    deleted_at: Date | null
    deleted_by: string | null
    features: string[]
    is_deleted: boolean
    planType: string | null
    settings: JsonValue | null
    status: string
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    contactEmail?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    features?: boolean
    is_deleted?: boolean
    planType?: boolean
    settings?: boolean
    status?: boolean
    TenantSystemPlan?: boolean | Tenant$TenantSystemPlanArgs<ExtArgs>
    device_rooms?: boolean | Tenant$device_roomsArgs<ExtArgs>
    pages?: boolean | Tenant$pagesArgs<ExtArgs>
    service_usage_statistics?: boolean | Tenant$service_usage_statisticsArgs<ExtArgs>
    tenant_services?: boolean | Tenant$tenant_servicesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    contactEmail?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    features?: boolean
    is_deleted?: boolean
    planType?: boolean
    settings?: boolean
    status?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    contactEmail?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    features?: boolean
    is_deleted?: boolean
    planType?: boolean
    settings?: boolean
    status?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TenantSystemPlan?: boolean | Tenant$TenantSystemPlanArgs<ExtArgs>
    device_rooms?: boolean | Tenant$device_roomsArgs<ExtArgs>
    pages?: boolean | Tenant$pagesArgs<ExtArgs>
    service_usage_statistics?: boolean | Tenant$service_usage_statisticsArgs<ExtArgs>
    tenant_services?: boolean | Tenant$tenant_servicesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      TenantSystemPlan: Prisma.$TenantSystemPlanPayload<ExtArgs>[]
      device_rooms: Prisma.$device_roomsPayload<ExtArgs>[]
      pages: Prisma.$pagesPayload<ExtArgs>[]
      service_usage_statistics: Prisma.$service_usage_statisticsPayload<ExtArgs>[]
      tenant_services: Prisma.$tenant_servicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string | null
      contactEmail: string | null
      createdAt: Date
      deleted_at: Date | null
      deleted_by: string | null
      features: string[]
      is_deleted: boolean
      planType: string | null
      settings: Prisma.JsonValue | null
      status: string
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TenantSystemPlan<T extends Tenant$TenantSystemPlanArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$TenantSystemPlanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "findMany"> | Null>
    device_rooms<T extends Tenant$device_roomsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$device_roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "findMany"> | Null>
    pages<T extends Tenant$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findMany"> | Null>
    service_usage_statistics<T extends Tenant$service_usage_statisticsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$service_usage_statisticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "findMany"> | Null>
    tenant_services<T extends Tenant$tenant_servicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tenant_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly contactEmail: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly deleted_at: FieldRef<"Tenant", 'DateTime'>
    readonly deleted_by: FieldRef<"Tenant", 'String'>
    readonly features: FieldRef<"Tenant", 'String[]'>
    readonly is_deleted: FieldRef<"Tenant", 'Boolean'>
    readonly planType: FieldRef<"Tenant", 'String'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly status: FieldRef<"Tenant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.TenantSystemPlan
   */
  export type Tenant$TenantSystemPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    where?: TenantSystemPlanWhereInput
    orderBy?: TenantSystemPlanOrderByWithRelationInput | TenantSystemPlanOrderByWithRelationInput[]
    cursor?: TenantSystemPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantSystemPlanScalarFieldEnum | TenantSystemPlanScalarFieldEnum[]
  }

  /**
   * Tenant.device_rooms
   */
  export type Tenant$device_roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    where?: device_roomsWhereInput
    orderBy?: device_roomsOrderByWithRelationInput | device_roomsOrderByWithRelationInput[]
    cursor?: device_roomsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Device_roomsScalarFieldEnum | Device_roomsScalarFieldEnum[]
  }

  /**
   * Tenant.pages
   */
  export type Tenant$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    where?: pagesWhereInput
    orderBy?: pagesOrderByWithRelationInput | pagesOrderByWithRelationInput[]
    cursor?: pagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagesScalarFieldEnum | PagesScalarFieldEnum[]
  }

  /**
   * Tenant.service_usage_statistics
   */
  export type Tenant$service_usage_statisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    where?: service_usage_statisticsWhereInput
    orderBy?: service_usage_statisticsOrderByWithRelationInput | service_usage_statisticsOrderByWithRelationInput[]
    cursor?: service_usage_statisticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Service_usage_statisticsScalarFieldEnum | Service_usage_statisticsScalarFieldEnum[]
  }

  /**
   * Tenant.tenant_services
   */
  export type Tenant$tenant_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    where?: tenant_servicesWhereInput
    orderBy?: tenant_servicesOrderByWithRelationInput | tenant_servicesOrderByWithRelationInput[]
    cursor?: tenant_servicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tenant_servicesScalarFieldEnum | Tenant_servicesScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantSystemPlan
   */

  export type AggregateTenantSystemPlan = {
    _count: TenantSystemPlanCountAggregateOutputType | null
    _avg: TenantSystemPlanAvgAggregateOutputType | null
    _sum: TenantSystemPlanSumAggregateOutputType | null
    _min: TenantSystemPlanMinAggregateOutputType | null
    _max: TenantSystemPlanMaxAggregateOutputType | null
  }

  export type TenantSystemPlanAvgAggregateOutputType = {
    monthlyPrice: number | null
  }

  export type TenantSystemPlanSumAggregateOutputType = {
    monthlyPrice: number | null
  }

  export type TenantSystemPlanMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    systemType: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    monthlyPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type TenantSystemPlanMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    systemType: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    monthlyPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type TenantSystemPlanCountAggregateOutputType = {
    id: number
    tenantId: number
    systemType: number
    planId: number
    startDate: number
    endDate: number
    isActive: number
    monthlyPrice: number
    createdAt: number
    updatedAt: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type TenantSystemPlanAvgAggregateInputType = {
    monthlyPrice?: true
  }

  export type TenantSystemPlanSumAggregateInputType = {
    monthlyPrice?: true
  }

  export type TenantSystemPlanMinAggregateInputType = {
    id?: true
    tenantId?: true
    systemType?: true
    planId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    monthlyPrice?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type TenantSystemPlanMaxAggregateInputType = {
    id?: true
    tenantId?: true
    systemType?: true
    planId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    monthlyPrice?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type TenantSystemPlanCountAggregateInputType = {
    id?: true
    tenantId?: true
    systemType?: true
    planId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    monthlyPrice?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type TenantSystemPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantSystemPlan to aggregate.
     */
    where?: TenantSystemPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSystemPlans to fetch.
     */
    orderBy?: TenantSystemPlanOrderByWithRelationInput | TenantSystemPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantSystemPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSystemPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSystemPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantSystemPlans
    **/
    _count?: true | TenantSystemPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantSystemPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSystemPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantSystemPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantSystemPlanMaxAggregateInputType
  }

  export type GetTenantSystemPlanAggregateType<T extends TenantSystemPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantSystemPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantSystemPlan[P]>
      : GetScalarType<T[P], AggregateTenantSystemPlan[P]>
  }




  export type TenantSystemPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantSystemPlanWhereInput
    orderBy?: TenantSystemPlanOrderByWithAggregationInput | TenantSystemPlanOrderByWithAggregationInput[]
    by: TenantSystemPlanScalarFieldEnum[] | TenantSystemPlanScalarFieldEnum
    having?: TenantSystemPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantSystemPlanCountAggregateInputType | true
    _avg?: TenantSystemPlanAvgAggregateInputType
    _sum?: TenantSystemPlanSumAggregateInputType
    _min?: TenantSystemPlanMinAggregateInputType
    _max?: TenantSystemPlanMaxAggregateInputType
  }

  export type TenantSystemPlanGroupByOutputType = {
    id: string
    tenantId: string
    systemType: string
    planId: string
    startDate: Date
    endDate: Date | null
    isActive: boolean
    monthlyPrice: number
    createdAt: Date
    updatedAt: Date
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: TenantSystemPlanCountAggregateOutputType | null
    _avg: TenantSystemPlanAvgAggregateOutputType | null
    _sum: TenantSystemPlanSumAggregateOutputType | null
    _min: TenantSystemPlanMinAggregateOutputType | null
    _max: TenantSystemPlanMaxAggregateOutputType | null
  }

  type GetTenantSystemPlanGroupByPayload<T extends TenantSystemPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantSystemPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantSystemPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantSystemPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TenantSystemPlanGroupByOutputType[P]>
        }
      >
    >


  export type TenantSystemPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    systemType?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    monthlyPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    SystemPlanRestrictions?: boolean | SystemPlanRestrictionsDefaultArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantSystemPlan"]>

  export type TenantSystemPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    systemType?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    monthlyPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    SystemPlanRestrictions?: boolean | SystemPlanRestrictionsDefaultArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantSystemPlan"]>

  export type TenantSystemPlanSelectScalar = {
    id?: boolean
    tenantId?: boolean
    systemType?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    monthlyPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type TenantSystemPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SystemPlanRestrictions?: boolean | SystemPlanRestrictionsDefaultArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantSystemPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SystemPlanRestrictions?: boolean | SystemPlanRestrictionsDefaultArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantSystemPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantSystemPlan"
    objects: {
      SystemPlanRestrictions: Prisma.$SystemPlanRestrictionsPayload<ExtArgs>
      Tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      systemType: string
      planId: string
      startDate: Date
      endDate: Date | null
      isActive: boolean
      monthlyPrice: number
      createdAt: Date
      updatedAt: Date
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["tenantSystemPlan"]>
    composites: {}
  }

  type TenantSystemPlanGetPayload<S extends boolean | null | undefined | TenantSystemPlanDefaultArgs> = $Result.GetResult<Prisma.$TenantSystemPlanPayload, S>

  type TenantSystemPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantSystemPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantSystemPlanCountAggregateInputType | true
    }

  export interface TenantSystemPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantSystemPlan'], meta: { name: 'TenantSystemPlan' } }
    /**
     * Find zero or one TenantSystemPlan that matches the filter.
     * @param {TenantSystemPlanFindUniqueArgs} args - Arguments to find a TenantSystemPlan
     * @example
     * // Get one TenantSystemPlan
     * const tenantSystemPlan = await prisma.tenantSystemPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantSystemPlanFindUniqueArgs>(args: SelectSubset<T, TenantSystemPlanFindUniqueArgs<ExtArgs>>): Prisma__TenantSystemPlanClient<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TenantSystemPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantSystemPlanFindUniqueOrThrowArgs} args - Arguments to find a TenantSystemPlan
     * @example
     * // Get one TenantSystemPlan
     * const tenantSystemPlan = await prisma.tenantSystemPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantSystemPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantSystemPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantSystemPlanClient<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TenantSystemPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSystemPlanFindFirstArgs} args - Arguments to find a TenantSystemPlan
     * @example
     * // Get one TenantSystemPlan
     * const tenantSystemPlan = await prisma.tenantSystemPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantSystemPlanFindFirstArgs>(args?: SelectSubset<T, TenantSystemPlanFindFirstArgs<ExtArgs>>): Prisma__TenantSystemPlanClient<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TenantSystemPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSystemPlanFindFirstOrThrowArgs} args - Arguments to find a TenantSystemPlan
     * @example
     * // Get one TenantSystemPlan
     * const tenantSystemPlan = await prisma.tenantSystemPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantSystemPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantSystemPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantSystemPlanClient<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TenantSystemPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSystemPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantSystemPlans
     * const tenantSystemPlans = await prisma.tenantSystemPlan.findMany()
     * 
     * // Get first 10 TenantSystemPlans
     * const tenantSystemPlans = await prisma.tenantSystemPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantSystemPlanWithIdOnly = await prisma.tenantSystemPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantSystemPlanFindManyArgs>(args?: SelectSubset<T, TenantSystemPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TenantSystemPlan.
     * @param {TenantSystemPlanCreateArgs} args - Arguments to create a TenantSystemPlan.
     * @example
     * // Create one TenantSystemPlan
     * const TenantSystemPlan = await prisma.tenantSystemPlan.create({
     *   data: {
     *     // ... data to create a TenantSystemPlan
     *   }
     * })
     * 
     */
    create<T extends TenantSystemPlanCreateArgs>(args: SelectSubset<T, TenantSystemPlanCreateArgs<ExtArgs>>): Prisma__TenantSystemPlanClient<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TenantSystemPlans.
     * @param {TenantSystemPlanCreateManyArgs} args - Arguments to create many TenantSystemPlans.
     * @example
     * // Create many TenantSystemPlans
     * const tenantSystemPlan = await prisma.tenantSystemPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantSystemPlanCreateManyArgs>(args?: SelectSubset<T, TenantSystemPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantSystemPlans and returns the data saved in the database.
     * @param {TenantSystemPlanCreateManyAndReturnArgs} args - Arguments to create many TenantSystemPlans.
     * @example
     * // Create many TenantSystemPlans
     * const tenantSystemPlan = await prisma.tenantSystemPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantSystemPlans and only return the `id`
     * const tenantSystemPlanWithIdOnly = await prisma.tenantSystemPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantSystemPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantSystemPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TenantSystemPlan.
     * @param {TenantSystemPlanDeleteArgs} args - Arguments to delete one TenantSystemPlan.
     * @example
     * // Delete one TenantSystemPlan
     * const TenantSystemPlan = await prisma.tenantSystemPlan.delete({
     *   where: {
     *     // ... filter to delete one TenantSystemPlan
     *   }
     * })
     * 
     */
    delete<T extends TenantSystemPlanDeleteArgs>(args: SelectSubset<T, TenantSystemPlanDeleteArgs<ExtArgs>>): Prisma__TenantSystemPlanClient<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TenantSystemPlan.
     * @param {TenantSystemPlanUpdateArgs} args - Arguments to update one TenantSystemPlan.
     * @example
     * // Update one TenantSystemPlan
     * const tenantSystemPlan = await prisma.tenantSystemPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantSystemPlanUpdateArgs>(args: SelectSubset<T, TenantSystemPlanUpdateArgs<ExtArgs>>): Prisma__TenantSystemPlanClient<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TenantSystemPlans.
     * @param {TenantSystemPlanDeleteManyArgs} args - Arguments to filter TenantSystemPlans to delete.
     * @example
     * // Delete a few TenantSystemPlans
     * const { count } = await prisma.tenantSystemPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantSystemPlanDeleteManyArgs>(args?: SelectSubset<T, TenantSystemPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantSystemPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSystemPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantSystemPlans
     * const tenantSystemPlan = await prisma.tenantSystemPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantSystemPlanUpdateManyArgs>(args: SelectSubset<T, TenantSystemPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TenantSystemPlan.
     * @param {TenantSystemPlanUpsertArgs} args - Arguments to update or create a TenantSystemPlan.
     * @example
     * // Update or create a TenantSystemPlan
     * const tenantSystemPlan = await prisma.tenantSystemPlan.upsert({
     *   create: {
     *     // ... data to create a TenantSystemPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantSystemPlan we want to update
     *   }
     * })
     */
    upsert<T extends TenantSystemPlanUpsertArgs>(args: SelectSubset<T, TenantSystemPlanUpsertArgs<ExtArgs>>): Prisma__TenantSystemPlanClient<$Result.GetResult<Prisma.$TenantSystemPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TenantSystemPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSystemPlanCountArgs} args - Arguments to filter TenantSystemPlans to count.
     * @example
     * // Count the number of TenantSystemPlans
     * const count = await prisma.tenantSystemPlan.count({
     *   where: {
     *     // ... the filter for the TenantSystemPlans we want to count
     *   }
     * })
    **/
    count<T extends TenantSystemPlanCountArgs>(
      args?: Subset<T, TenantSystemPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantSystemPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantSystemPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSystemPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantSystemPlanAggregateArgs>(args: Subset<T, TenantSystemPlanAggregateArgs>): Prisma.PrismaPromise<GetTenantSystemPlanAggregateType<T>>

    /**
     * Group by TenantSystemPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantSystemPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantSystemPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantSystemPlanGroupByArgs['orderBy'] }
        : { orderBy?: TenantSystemPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantSystemPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantSystemPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantSystemPlan model
   */
  readonly fields: TenantSystemPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantSystemPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantSystemPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SystemPlanRestrictions<T extends SystemPlanRestrictionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SystemPlanRestrictionsDefaultArgs<ExtArgs>>): Prisma__SystemPlanRestrictionsClient<$Result.GetResult<Prisma.$SystemPlanRestrictionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantSystemPlan model
   */ 
  interface TenantSystemPlanFieldRefs {
    readonly id: FieldRef<"TenantSystemPlan", 'String'>
    readonly tenantId: FieldRef<"TenantSystemPlan", 'String'>
    readonly systemType: FieldRef<"TenantSystemPlan", 'String'>
    readonly planId: FieldRef<"TenantSystemPlan", 'String'>
    readonly startDate: FieldRef<"TenantSystemPlan", 'DateTime'>
    readonly endDate: FieldRef<"TenantSystemPlan", 'DateTime'>
    readonly isActive: FieldRef<"TenantSystemPlan", 'Boolean'>
    readonly monthlyPrice: FieldRef<"TenantSystemPlan", 'Int'>
    readonly createdAt: FieldRef<"TenantSystemPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantSystemPlan", 'DateTime'>
    readonly deleted_at: FieldRef<"TenantSystemPlan", 'DateTime'>
    readonly deleted_by: FieldRef<"TenantSystemPlan", 'String'>
    readonly is_deleted: FieldRef<"TenantSystemPlan", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TenantSystemPlan findUnique
   */
  export type TenantSystemPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantSystemPlan to fetch.
     */
    where: TenantSystemPlanWhereUniqueInput
  }

  /**
   * TenantSystemPlan findUniqueOrThrow
   */
  export type TenantSystemPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantSystemPlan to fetch.
     */
    where: TenantSystemPlanWhereUniqueInput
  }

  /**
   * TenantSystemPlan findFirst
   */
  export type TenantSystemPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantSystemPlan to fetch.
     */
    where?: TenantSystemPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSystemPlans to fetch.
     */
    orderBy?: TenantSystemPlanOrderByWithRelationInput | TenantSystemPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantSystemPlans.
     */
    cursor?: TenantSystemPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSystemPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSystemPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantSystemPlans.
     */
    distinct?: TenantSystemPlanScalarFieldEnum | TenantSystemPlanScalarFieldEnum[]
  }

  /**
   * TenantSystemPlan findFirstOrThrow
   */
  export type TenantSystemPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantSystemPlan to fetch.
     */
    where?: TenantSystemPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSystemPlans to fetch.
     */
    orderBy?: TenantSystemPlanOrderByWithRelationInput | TenantSystemPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantSystemPlans.
     */
    cursor?: TenantSystemPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSystemPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSystemPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantSystemPlans.
     */
    distinct?: TenantSystemPlanScalarFieldEnum | TenantSystemPlanScalarFieldEnum[]
  }

  /**
   * TenantSystemPlan findMany
   */
  export type TenantSystemPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantSystemPlans to fetch.
     */
    where?: TenantSystemPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantSystemPlans to fetch.
     */
    orderBy?: TenantSystemPlanOrderByWithRelationInput | TenantSystemPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantSystemPlans.
     */
    cursor?: TenantSystemPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantSystemPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantSystemPlans.
     */
    skip?: number
    distinct?: TenantSystemPlanScalarFieldEnum | TenantSystemPlanScalarFieldEnum[]
  }

  /**
   * TenantSystemPlan create
   */
  export type TenantSystemPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantSystemPlan.
     */
    data: XOR<TenantSystemPlanCreateInput, TenantSystemPlanUncheckedCreateInput>
  }

  /**
   * TenantSystemPlan createMany
   */
  export type TenantSystemPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantSystemPlans.
     */
    data: TenantSystemPlanCreateManyInput | TenantSystemPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantSystemPlan createManyAndReturn
   */
  export type TenantSystemPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TenantSystemPlans.
     */
    data: TenantSystemPlanCreateManyInput | TenantSystemPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantSystemPlan update
   */
  export type TenantSystemPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantSystemPlan.
     */
    data: XOR<TenantSystemPlanUpdateInput, TenantSystemPlanUncheckedUpdateInput>
    /**
     * Choose, which TenantSystemPlan to update.
     */
    where: TenantSystemPlanWhereUniqueInput
  }

  /**
   * TenantSystemPlan updateMany
   */
  export type TenantSystemPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantSystemPlans.
     */
    data: XOR<TenantSystemPlanUpdateManyMutationInput, TenantSystemPlanUncheckedUpdateManyInput>
    /**
     * Filter which TenantSystemPlans to update
     */
    where?: TenantSystemPlanWhereInput
  }

  /**
   * TenantSystemPlan upsert
   */
  export type TenantSystemPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantSystemPlan to update in case it exists.
     */
    where: TenantSystemPlanWhereUniqueInput
    /**
     * In case the TenantSystemPlan found by the `where` argument doesn't exist, create a new TenantSystemPlan with this data.
     */
    create: XOR<TenantSystemPlanCreateInput, TenantSystemPlanUncheckedCreateInput>
    /**
     * In case the TenantSystemPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantSystemPlanUpdateInput, TenantSystemPlanUncheckedUpdateInput>
  }

  /**
   * TenantSystemPlan delete
   */
  export type TenantSystemPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
    /**
     * Filter which TenantSystemPlan to delete.
     */
    where: TenantSystemPlanWhereUniqueInput
  }

  /**
   * TenantSystemPlan deleteMany
   */
  export type TenantSystemPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantSystemPlans to delete
     */
    where?: TenantSystemPlanWhereInput
  }

  /**
   * TenantSystemPlan without action
   */
  export type TenantSystemPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantSystemPlan
     */
    select?: TenantSystemPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantSystemPlanInclude<ExtArgs> | null
  }


  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    login_attempts: number | null
  }

  export type AdminSumAggregateOutputType = {
    login_attempts: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    display_name: string | null
    password_hash: string | null
    admin_level: $Enums.AdminLevel | null
    last_login_at: Date | null
    login_attempts: number | null
    locked_until: Date | null
    totp_secret: string | null
    totp_enabled: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    is_active: boolean | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    display_name: string | null
    password_hash: string | null
    admin_level: $Enums.AdminLevel | null
    last_login_at: Date | null
    login_attempts: number | null
    locked_until: Date | null
    totp_secret: string | null
    totp_enabled: boolean | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
    is_active: boolean | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    email: number
    username: number
    display_name: number
    password_hash: number
    admin_level: number
    accessible_group_ids: number
    accessible_chain_ids: number
    accessible_tenant_ids: number
    last_login_at: number
    login_attempts: number
    locked_until: number
    totp_secret: number
    totp_enabled: number
    created_at: number
    updated_at: number
    created_by: number
    is_active: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    login_attempts?: true
  }

  export type AdminSumAggregateInputType = {
    login_attempts?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    display_name?: true
    password_hash?: true
    admin_level?: true
    last_login_at?: true
    login_attempts?: true
    locked_until?: true
    totp_secret?: true
    totp_enabled?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    is_active?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    display_name?: true
    password_hash?: true
    admin_level?: true
    last_login_at?: true
    login_attempts?: true
    locked_until?: true
    totp_secret?: true
    totp_enabled?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    is_active?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    display_name?: true
    password_hash?: true
    admin_level?: true
    accessible_group_ids?: true
    accessible_chain_ids?: true
    accessible_tenant_ids?: true
    last_login_at?: true
    login_attempts?: true
    locked_until?: true
    totp_secret?: true
    totp_enabled?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    is_active?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    email: string
    username: string
    display_name: string
    password_hash: string
    admin_level: $Enums.AdminLevel
    accessible_group_ids: string[]
    accessible_chain_ids: string[]
    accessible_tenant_ids: string[]
    last_login_at: Date | null
    login_attempts: number
    locked_until: Date | null
    totp_secret: string | null
    totp_enabled: boolean
    created_at: Date
    updated_at: Date
    created_by: string | null
    is_active: boolean
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    display_name?: boolean
    password_hash?: boolean
    admin_level?: boolean
    accessible_group_ids?: boolean
    accessible_chain_ids?: boolean
    accessible_tenant_ids?: boolean
    last_login_at?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    totp_secret?: boolean
    totp_enabled?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    is_active?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    admin_log?: boolean | admin$admin_logArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    display_name?: boolean
    password_hash?: boolean
    admin_level?: boolean
    accessible_group_ids?: boolean
    accessible_chain_ids?: boolean
    accessible_tenant_ids?: boolean
    last_login_at?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    totp_secret?: boolean
    totp_enabled?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    is_active?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["admin"]>

  export type adminSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    display_name?: boolean
    password_hash?: boolean
    admin_level?: boolean
    accessible_group_ids?: boolean
    accessible_chain_ids?: boolean
    accessible_tenant_ids?: boolean
    last_login_at?: boolean
    login_attempts?: boolean
    locked_until?: boolean
    totp_secret?: boolean
    totp_enabled?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    is_active?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_log?: boolean | admin$admin_logArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type adminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      admin_log: Prisma.$admin_logPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      display_name: string
      password_hash: string
      admin_level: $Enums.AdminLevel
      accessible_group_ids: string[]
      accessible_chain_ids: string[]
      accessible_tenant_ids: string[]
      last_login_at: Date | null
      login_attempts: number
      locked_until: Date | null
      totp_secret: string | null
      totp_enabled: boolean
      created_at: Date
      updated_at: Date
      created_by: string | null
      is_active: boolean
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {adminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends adminCreateManyAndReturnArgs>(args?: SelectSubset<T, adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_log<T extends admin$admin_logArgs<ExtArgs> = {}>(args?: Subset<T, admin$admin_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */ 
  interface adminFieldRefs {
    readonly id: FieldRef<"admin", 'String'>
    readonly email: FieldRef<"admin", 'String'>
    readonly username: FieldRef<"admin", 'String'>
    readonly display_name: FieldRef<"admin", 'String'>
    readonly password_hash: FieldRef<"admin", 'String'>
    readonly admin_level: FieldRef<"admin", 'AdminLevel'>
    readonly accessible_group_ids: FieldRef<"admin", 'String[]'>
    readonly accessible_chain_ids: FieldRef<"admin", 'String[]'>
    readonly accessible_tenant_ids: FieldRef<"admin", 'String[]'>
    readonly last_login_at: FieldRef<"admin", 'DateTime'>
    readonly login_attempts: FieldRef<"admin", 'Int'>
    readonly locked_until: FieldRef<"admin", 'DateTime'>
    readonly totp_secret: FieldRef<"admin", 'String'>
    readonly totp_enabled: FieldRef<"admin", 'Boolean'>
    readonly created_at: FieldRef<"admin", 'DateTime'>
    readonly updated_at: FieldRef<"admin", 'DateTime'>
    readonly created_by: FieldRef<"admin", 'String'>
    readonly is_active: FieldRef<"admin", 'Boolean'>
    readonly deleted_at: FieldRef<"admin", 'DateTime'>
    readonly deleted_by: FieldRef<"admin", 'String'>
    readonly is_deleted: FieldRef<"admin", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin createManyAndReturn
   */
  export type adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
  }

  /**
   * admin.admin_log
   */
  export type admin$admin_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    where?: admin_logWhereInput
    orderBy?: admin_logOrderByWithRelationInput | admin_logOrderByWithRelationInput[]
    cursor?: admin_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Admin_logScalarFieldEnum | Admin_logScalarFieldEnum[]
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
  }


  /**
   * Model admin_log
   */

  export type AggregateAdmin_log = {
    _count: Admin_logCountAggregateOutputType | null
    _min: Admin_logMinAggregateOutputType | null
    _max: Admin_logMaxAggregateOutputType | null
  }

  export type Admin_logMinAggregateOutputType = {
    id: string | null
    admin_id: string | null
    action: string | null
    target_type: string | null
    target_id: string | null
    ip_address: string | null
    user_agent: string | null
    success: boolean | null
    error_message: string | null
    created_at: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Admin_logMaxAggregateOutputType = {
    id: string | null
    admin_id: string | null
    action: string | null
    target_type: string | null
    target_id: string | null
    ip_address: string | null
    user_agent: string | null
    success: boolean | null
    error_message: string | null
    created_at: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Admin_logCountAggregateOutputType = {
    id: number
    admin_id: number
    action: number
    target_type: number
    target_id: number
    ip_address: number
    user_agent: number
    success: number
    error_message: number
    created_at: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Admin_logMinAggregateInputType = {
    id?: true
    admin_id?: true
    action?: true
    target_type?: true
    target_id?: true
    ip_address?: true
    user_agent?: true
    success?: true
    error_message?: true
    created_at?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Admin_logMaxAggregateInputType = {
    id?: true
    admin_id?: true
    action?: true
    target_type?: true
    target_id?: true
    ip_address?: true
    user_agent?: true
    success?: true
    error_message?: true
    created_at?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Admin_logCountAggregateInputType = {
    id?: true
    admin_id?: true
    action?: true
    target_type?: true
    target_id?: true
    ip_address?: true
    user_agent?: true
    success?: true
    error_message?: true
    created_at?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Admin_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_log to aggregate.
     */
    where?: admin_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_logs to fetch.
     */
    orderBy?: admin_logOrderByWithRelationInput | admin_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admin_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_logs
    **/
    _count?: true | Admin_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_logMaxAggregateInputType
  }

  export type GetAdmin_logAggregateType<T extends Admin_logAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_log[P]>
      : GetScalarType<T[P], AggregateAdmin_log[P]>
  }




  export type admin_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_logWhereInput
    orderBy?: admin_logOrderByWithAggregationInput | admin_logOrderByWithAggregationInput[]
    by: Admin_logScalarFieldEnum[] | Admin_logScalarFieldEnum
    having?: admin_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_logCountAggregateInputType | true
    _min?: Admin_logMinAggregateInputType
    _max?: Admin_logMaxAggregateInputType
  }

  export type Admin_logGroupByOutputType = {
    id: string
    admin_id: string
    action: string
    target_type: string | null
    target_id: string | null
    ip_address: string | null
    user_agent: string | null
    success: boolean
    error_message: string | null
    created_at: Date
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Admin_logCountAggregateOutputType | null
    _min: Admin_logMinAggregateOutputType | null
    _max: Admin_logMaxAggregateOutputType | null
  }

  type GetAdmin_logGroupByPayload<T extends admin_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Admin_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_logGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_logGroupByOutputType[P]>
        }
      >
    >


  export type admin_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    action?: boolean
    target_type?: boolean
    target_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    success?: boolean
    error_message?: boolean
    created_at?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_log"]>

  export type admin_logSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    action?: boolean
    target_type?: boolean
    target_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    success?: boolean
    error_message?: boolean
    created_at?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_log"]>

  export type admin_logSelectScalar = {
    id?: boolean
    admin_id?: boolean
    action?: boolean
    target_type?: boolean
    target_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    success?: boolean
    error_message?: boolean
    created_at?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type admin_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }
  export type admin_logIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | adminDefaultArgs<ExtArgs>
  }

  export type $admin_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin_log"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      admin_id: string
      action: string
      target_type: string | null
      target_id: string | null
      ip_address: string | null
      user_agent: string | null
      success: boolean
      error_message: string | null
      created_at: Date
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["admin_log"]>
    composites: {}
  }

  type admin_logGetPayload<S extends boolean | null | undefined | admin_logDefaultArgs> = $Result.GetResult<Prisma.$admin_logPayload, S>

  type admin_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<admin_logFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Admin_logCountAggregateInputType | true
    }

  export interface admin_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin_log'], meta: { name: 'admin_log' } }
    /**
     * Find zero or one Admin_log that matches the filter.
     * @param {admin_logFindUniqueArgs} args - Arguments to find a Admin_log
     * @example
     * // Get one Admin_log
     * const admin_log = await prisma.admin_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admin_logFindUniqueArgs>(args: SelectSubset<T, admin_logFindUniqueArgs<ExtArgs>>): Prisma__admin_logClient<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin_log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {admin_logFindUniqueOrThrowArgs} args - Arguments to find a Admin_log
     * @example
     * // Get one Admin_log
     * const admin_log = await prisma.admin_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admin_logFindUniqueOrThrowArgs>(args: SelectSubset<T, admin_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admin_logClient<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_logFindFirstArgs} args - Arguments to find a Admin_log
     * @example
     * // Get one Admin_log
     * const admin_log = await prisma.admin_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admin_logFindFirstArgs>(args?: SelectSubset<T, admin_logFindFirstArgs<ExtArgs>>): Prisma__admin_logClient<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_logFindFirstOrThrowArgs} args - Arguments to find a Admin_log
     * @example
     * // Get one Admin_log
     * const admin_log = await prisma.admin_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admin_logFindFirstOrThrowArgs>(args?: SelectSubset<T, admin_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__admin_logClient<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admin_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_logs
     * const admin_logs = await prisma.admin_log.findMany()
     * 
     * // Get first 10 Admin_logs
     * const admin_logs = await prisma.admin_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_logWithIdOnly = await prisma.admin_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admin_logFindManyArgs>(args?: SelectSubset<T, admin_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin_log.
     * @param {admin_logCreateArgs} args - Arguments to create a Admin_log.
     * @example
     * // Create one Admin_log
     * const Admin_log = await prisma.admin_log.create({
     *   data: {
     *     // ... data to create a Admin_log
     *   }
     * })
     * 
     */
    create<T extends admin_logCreateArgs>(args: SelectSubset<T, admin_logCreateArgs<ExtArgs>>): Prisma__admin_logClient<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admin_logs.
     * @param {admin_logCreateManyArgs} args - Arguments to create many Admin_logs.
     * @example
     * // Create many Admin_logs
     * const admin_log = await prisma.admin_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admin_logCreateManyArgs>(args?: SelectSubset<T, admin_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admin_logs and returns the data saved in the database.
     * @param {admin_logCreateManyAndReturnArgs} args - Arguments to create many Admin_logs.
     * @example
     * // Create many Admin_logs
     * const admin_log = await prisma.admin_log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admin_logs and only return the `id`
     * const admin_logWithIdOnly = await prisma.admin_log.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends admin_logCreateManyAndReturnArgs>(args?: SelectSubset<T, admin_logCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admin_log.
     * @param {admin_logDeleteArgs} args - Arguments to delete one Admin_log.
     * @example
     * // Delete one Admin_log
     * const Admin_log = await prisma.admin_log.delete({
     *   where: {
     *     // ... filter to delete one Admin_log
     *   }
     * })
     * 
     */
    delete<T extends admin_logDeleteArgs>(args: SelectSubset<T, admin_logDeleteArgs<ExtArgs>>): Prisma__admin_logClient<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin_log.
     * @param {admin_logUpdateArgs} args - Arguments to update one Admin_log.
     * @example
     * // Update one Admin_log
     * const admin_log = await prisma.admin_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admin_logUpdateArgs>(args: SelectSubset<T, admin_logUpdateArgs<ExtArgs>>): Prisma__admin_logClient<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admin_logs.
     * @param {admin_logDeleteManyArgs} args - Arguments to filter Admin_logs to delete.
     * @example
     * // Delete a few Admin_logs
     * const { count } = await prisma.admin_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admin_logDeleteManyArgs>(args?: SelectSubset<T, admin_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_logs
     * const admin_log = await prisma.admin_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admin_logUpdateManyArgs>(args: SelectSubset<T, admin_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_log.
     * @param {admin_logUpsertArgs} args - Arguments to update or create a Admin_log.
     * @example
     * // Update or create a Admin_log
     * const admin_log = await prisma.admin_log.upsert({
     *   create: {
     *     // ... data to create a Admin_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_log we want to update
     *   }
     * })
     */
    upsert<T extends admin_logUpsertArgs>(args: SelectSubset<T, admin_logUpsertArgs<ExtArgs>>): Prisma__admin_logClient<$Result.GetResult<Prisma.$admin_logPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admin_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_logCountArgs} args - Arguments to filter Admin_logs to count.
     * @example
     * // Count the number of Admin_logs
     * const count = await prisma.admin_log.count({
     *   where: {
     *     // ... the filter for the Admin_logs we want to count
     *   }
     * })
    **/
    count<T extends admin_logCountArgs>(
      args?: Subset<T, admin_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_logAggregateArgs>(args: Subset<T, Admin_logAggregateArgs>): Prisma.PrismaPromise<GetAdmin_logAggregateType<T>>

    /**
     * Group by Admin_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admin_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admin_logGroupByArgs['orderBy'] }
        : { orderBy?: admin_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admin_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin_log model
   */
  readonly fields: admin_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admin_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends adminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, adminDefaultArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin_log model
   */ 
  interface admin_logFieldRefs {
    readonly id: FieldRef<"admin_log", 'String'>
    readonly admin_id: FieldRef<"admin_log", 'String'>
    readonly action: FieldRef<"admin_log", 'String'>
    readonly target_type: FieldRef<"admin_log", 'String'>
    readonly target_id: FieldRef<"admin_log", 'String'>
    readonly ip_address: FieldRef<"admin_log", 'String'>
    readonly user_agent: FieldRef<"admin_log", 'String'>
    readonly success: FieldRef<"admin_log", 'Boolean'>
    readonly error_message: FieldRef<"admin_log", 'String'>
    readonly created_at: FieldRef<"admin_log", 'DateTime'>
    readonly deleted_at: FieldRef<"admin_log", 'DateTime'>
    readonly deleted_by: FieldRef<"admin_log", 'String'>
    readonly is_deleted: FieldRef<"admin_log", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * admin_log findUnique
   */
  export type admin_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_log to fetch.
     */
    where: admin_logWhereUniqueInput
  }

  /**
   * admin_log findUniqueOrThrow
   */
  export type admin_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_log to fetch.
     */
    where: admin_logWhereUniqueInput
  }

  /**
   * admin_log findFirst
   */
  export type admin_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_log to fetch.
     */
    where?: admin_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_logs to fetch.
     */
    orderBy?: admin_logOrderByWithRelationInput | admin_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_logs.
     */
    cursor?: admin_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_logs.
     */
    distinct?: Admin_logScalarFieldEnum | Admin_logScalarFieldEnum[]
  }

  /**
   * admin_log findFirstOrThrow
   */
  export type admin_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_log to fetch.
     */
    where?: admin_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_logs to fetch.
     */
    orderBy?: admin_logOrderByWithRelationInput | admin_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_logs.
     */
    cursor?: admin_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_logs.
     */
    distinct?: Admin_logScalarFieldEnum | Admin_logScalarFieldEnum[]
  }

  /**
   * admin_log findMany
   */
  export type admin_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    /**
     * Filter, which admin_logs to fetch.
     */
    where?: admin_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_logs to fetch.
     */
    orderBy?: admin_logOrderByWithRelationInput | admin_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_logs.
     */
    cursor?: admin_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_logs.
     */
    skip?: number
    distinct?: Admin_logScalarFieldEnum | Admin_logScalarFieldEnum[]
  }

  /**
   * admin_log create
   */
  export type admin_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    /**
     * The data needed to create a admin_log.
     */
    data: XOR<admin_logCreateInput, admin_logUncheckedCreateInput>
  }

  /**
   * admin_log createMany
   */
  export type admin_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admin_logs.
     */
    data: admin_logCreateManyInput | admin_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_log createManyAndReturn
   */
  export type admin_logCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many admin_logs.
     */
    data: admin_logCreateManyInput | admin_logCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_log update
   */
  export type admin_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    /**
     * The data needed to update a admin_log.
     */
    data: XOR<admin_logUpdateInput, admin_logUncheckedUpdateInput>
    /**
     * Choose, which admin_log to update.
     */
    where: admin_logWhereUniqueInput
  }

  /**
   * admin_log updateMany
   */
  export type admin_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admin_logs.
     */
    data: XOR<admin_logUpdateManyMutationInput, admin_logUncheckedUpdateManyInput>
    /**
     * Filter which admin_logs to update
     */
    where?: admin_logWhereInput
  }

  /**
   * admin_log upsert
   */
  export type admin_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    /**
     * The filter to search for the admin_log to update in case it exists.
     */
    where: admin_logWhereUniqueInput
    /**
     * In case the admin_log found by the `where` argument doesn't exist, create a new admin_log with this data.
     */
    create: XOR<admin_logCreateInput, admin_logUncheckedCreateInput>
    /**
     * In case the admin_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admin_logUpdateInput, admin_logUncheckedUpdateInput>
  }

  /**
   * admin_log delete
   */
  export type admin_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
    /**
     * Filter which admin_log to delete.
     */
    where: admin_logWhereUniqueInput
  }

  /**
   * admin_log deleteMany
   */
  export type admin_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_logs to delete
     */
    where?: admin_logWhereInput
  }

  /**
   * admin_log without action
   */
  export type admin_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_log
     */
    select?: admin_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_logInclude<ExtArgs> | null
  }


  /**
   * Model campaign_categories
   */

  export type AggregateCampaign_categories = {
    _count: Campaign_categoriesCountAggregateOutputType | null
    _min: Campaign_categoriesMinAggregateOutputType | null
    _max: Campaign_categoriesMaxAggregateOutputType | null
  }

  export type Campaign_categoriesMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_categoriesMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_categoriesCountAggregateOutputType = {
    id: number
    tenantId: number
    code: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Campaign_categoriesMinAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_categoriesMaxAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_categoriesCountAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Campaign_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_categories to aggregate.
     */
    where?: campaign_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_categories to fetch.
     */
    orderBy?: campaign_categoriesOrderByWithRelationInput | campaign_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaign_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaign_categories
    **/
    _count?: true | Campaign_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Campaign_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Campaign_categoriesMaxAggregateInputType
  }

  export type GetCampaign_categoriesAggregateType<T extends Campaign_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign_categories[P]>
      : GetScalarType<T[P], AggregateCampaign_categories[P]>
  }




  export type campaign_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_categoriesWhereInput
    orderBy?: campaign_categoriesOrderByWithAggregationInput | campaign_categoriesOrderByWithAggregationInput[]
    by: Campaign_categoriesScalarFieldEnum[] | Campaign_categoriesScalarFieldEnum
    having?: campaign_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Campaign_categoriesCountAggregateInputType | true
    _min?: Campaign_categoriesMinAggregateInputType
    _max?: Campaign_categoriesMaxAggregateInputType
  }

  export type Campaign_categoriesGroupByOutputType = {
    id: string
    tenantId: string
    code: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Campaign_categoriesCountAggregateOutputType | null
    _min: Campaign_categoriesMinAggregateOutputType | null
    _max: Campaign_categoriesMaxAggregateOutputType | null
  }

  type GetCampaign_categoriesGroupByPayload<T extends campaign_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Campaign_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Campaign_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Campaign_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Campaign_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type campaign_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaign_category_relations?: boolean | campaign_categories$campaign_category_relationsArgs<ExtArgs>
    _count?: boolean | Campaign_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign_categories"]>

  export type campaign_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["campaign_categories"]>

  export type campaign_categoriesSelectScalar = {
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type campaign_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign_category_relations?: boolean | campaign_categories$campaign_category_relationsArgs<ExtArgs>
    _count?: boolean | Campaign_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type campaign_categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $campaign_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaign_categories"
    objects: {
      campaign_category_relations: Prisma.$campaign_category_relationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      code: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["campaign_categories"]>
    composites: {}
  }

  type campaign_categoriesGetPayload<S extends boolean | null | undefined | campaign_categoriesDefaultArgs> = $Result.GetResult<Prisma.$campaign_categoriesPayload, S>

  type campaign_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<campaign_categoriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Campaign_categoriesCountAggregateInputType | true
    }

  export interface campaign_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaign_categories'], meta: { name: 'campaign_categories' } }
    /**
     * Find zero or one Campaign_categories that matches the filter.
     * @param {campaign_categoriesFindUniqueArgs} args - Arguments to find a Campaign_categories
     * @example
     * // Get one Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaign_categoriesFindUniqueArgs>(args: SelectSubset<T, campaign_categoriesFindUniqueArgs<ExtArgs>>): Prisma__campaign_categoriesClient<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign_categories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {campaign_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Campaign_categories
     * @example
     * // Get one Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaign_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, campaign_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaign_categoriesClient<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_categoriesFindFirstArgs} args - Arguments to find a Campaign_categories
     * @example
     * // Get one Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaign_categoriesFindFirstArgs>(args?: SelectSubset<T, campaign_categoriesFindFirstArgs<ExtArgs>>): Prisma__campaign_categoriesClient<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_categoriesFindFirstOrThrowArgs} args - Arguments to find a Campaign_categories
     * @example
     * // Get one Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaign_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, campaign_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaign_categoriesClient<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaign_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.findMany()
     * 
     * // Get first 10 Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaign_categoriesWithIdOnly = await prisma.campaign_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaign_categoriesFindManyArgs>(args?: SelectSubset<T, campaign_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign_categories.
     * @param {campaign_categoriesCreateArgs} args - Arguments to create a Campaign_categories.
     * @example
     * // Create one Campaign_categories
     * const Campaign_categories = await prisma.campaign_categories.create({
     *   data: {
     *     // ... data to create a Campaign_categories
     *   }
     * })
     * 
     */
    create<T extends campaign_categoriesCreateArgs>(args: SelectSubset<T, campaign_categoriesCreateArgs<ExtArgs>>): Prisma__campaign_categoriesClient<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaign_categories.
     * @param {campaign_categoriesCreateManyArgs} args - Arguments to create many Campaign_categories.
     * @example
     * // Create many Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaign_categoriesCreateManyArgs>(args?: SelectSubset<T, campaign_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaign_categories and returns the data saved in the database.
     * @param {campaign_categoriesCreateManyAndReturnArgs} args - Arguments to create many Campaign_categories.
     * @example
     * // Create many Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaign_categories and only return the `id`
     * const campaign_categoriesWithIdOnly = await prisma.campaign_categories.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaign_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, campaign_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign_categories.
     * @param {campaign_categoriesDeleteArgs} args - Arguments to delete one Campaign_categories.
     * @example
     * // Delete one Campaign_categories
     * const Campaign_categories = await prisma.campaign_categories.delete({
     *   where: {
     *     // ... filter to delete one Campaign_categories
     *   }
     * })
     * 
     */
    delete<T extends campaign_categoriesDeleteArgs>(args: SelectSubset<T, campaign_categoriesDeleteArgs<ExtArgs>>): Prisma__campaign_categoriesClient<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign_categories.
     * @param {campaign_categoriesUpdateArgs} args - Arguments to update one Campaign_categories.
     * @example
     * // Update one Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaign_categoriesUpdateArgs>(args: SelectSubset<T, campaign_categoriesUpdateArgs<ExtArgs>>): Prisma__campaign_categoriesClient<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaign_categories.
     * @param {campaign_categoriesDeleteManyArgs} args - Arguments to filter Campaign_categories to delete.
     * @example
     * // Delete a few Campaign_categories
     * const { count } = await prisma.campaign_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaign_categoriesDeleteManyArgs>(args?: SelectSubset<T, campaign_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaign_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaign_categoriesUpdateManyArgs>(args: SelectSubset<T, campaign_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign_categories.
     * @param {campaign_categoriesUpsertArgs} args - Arguments to update or create a Campaign_categories.
     * @example
     * // Update or create a Campaign_categories
     * const campaign_categories = await prisma.campaign_categories.upsert({
     *   create: {
     *     // ... data to create a Campaign_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign_categories we want to update
     *   }
     * })
     */
    upsert<T extends campaign_categoriesUpsertArgs>(args: SelectSubset<T, campaign_categoriesUpsertArgs<ExtArgs>>): Prisma__campaign_categoriesClient<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaign_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_categoriesCountArgs} args - Arguments to filter Campaign_categories to count.
     * @example
     * // Count the number of Campaign_categories
     * const count = await prisma.campaign_categories.count({
     *   where: {
     *     // ... the filter for the Campaign_categories we want to count
     *   }
     * })
    **/
    count<T extends campaign_categoriesCountArgs>(
      args?: Subset<T, campaign_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Campaign_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Campaign_categoriesAggregateArgs>(args: Subset<T, Campaign_categoriesAggregateArgs>): Prisma.PrismaPromise<GetCampaign_categoriesAggregateType<T>>

    /**
     * Group by Campaign_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaign_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaign_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: campaign_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaign_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaign_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaign_categories model
   */
  readonly fields: campaign_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaign_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaign_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign_category_relations<T extends campaign_categories$campaign_category_relationsArgs<ExtArgs> = {}>(args?: Subset<T, campaign_categories$campaign_category_relationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaign_categories model
   */ 
  interface campaign_categoriesFieldRefs {
    readonly id: FieldRef<"campaign_categories", 'String'>
    readonly tenantId: FieldRef<"campaign_categories", 'String'>
    readonly code: FieldRef<"campaign_categories", 'String'>
    readonly name: FieldRef<"campaign_categories", 'String'>
    readonly description: FieldRef<"campaign_categories", 'String'>
    readonly createdAt: FieldRef<"campaign_categories", 'DateTime'>
    readonly updatedAt: FieldRef<"campaign_categories", 'DateTime'>
    readonly deleted_at: FieldRef<"campaign_categories", 'DateTime'>
    readonly deleted_by: FieldRef<"campaign_categories", 'String'>
    readonly is_deleted: FieldRef<"campaign_categories", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * campaign_categories findUnique
   */
  export type campaign_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which campaign_categories to fetch.
     */
    where: campaign_categoriesWhereUniqueInput
  }

  /**
   * campaign_categories findUniqueOrThrow
   */
  export type campaign_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which campaign_categories to fetch.
     */
    where: campaign_categoriesWhereUniqueInput
  }

  /**
   * campaign_categories findFirst
   */
  export type campaign_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which campaign_categories to fetch.
     */
    where?: campaign_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_categories to fetch.
     */
    orderBy?: campaign_categoriesOrderByWithRelationInput | campaign_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_categories.
     */
    cursor?: campaign_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_categories.
     */
    distinct?: Campaign_categoriesScalarFieldEnum | Campaign_categoriesScalarFieldEnum[]
  }

  /**
   * campaign_categories findFirstOrThrow
   */
  export type campaign_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which campaign_categories to fetch.
     */
    where?: campaign_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_categories to fetch.
     */
    orderBy?: campaign_categoriesOrderByWithRelationInput | campaign_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_categories.
     */
    cursor?: campaign_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_categories.
     */
    distinct?: Campaign_categoriesScalarFieldEnum | Campaign_categoriesScalarFieldEnum[]
  }

  /**
   * campaign_categories findMany
   */
  export type campaign_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which campaign_categories to fetch.
     */
    where?: campaign_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_categories to fetch.
     */
    orderBy?: campaign_categoriesOrderByWithRelationInput | campaign_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaign_categories.
     */
    cursor?: campaign_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_categories.
     */
    skip?: number
    distinct?: Campaign_categoriesScalarFieldEnum | Campaign_categoriesScalarFieldEnum[]
  }

  /**
   * campaign_categories create
   */
  export type campaign_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a campaign_categories.
     */
    data: XOR<campaign_categoriesCreateInput, campaign_categoriesUncheckedCreateInput>
  }

  /**
   * campaign_categories createMany
   */
  export type campaign_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaign_categories.
     */
    data: campaign_categoriesCreateManyInput | campaign_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campaign_categories createManyAndReturn
   */
  export type campaign_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many campaign_categories.
     */
    data: campaign_categoriesCreateManyInput | campaign_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campaign_categories update
   */
  export type campaign_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a campaign_categories.
     */
    data: XOR<campaign_categoriesUpdateInput, campaign_categoriesUncheckedUpdateInput>
    /**
     * Choose, which campaign_categories to update.
     */
    where: campaign_categoriesWhereUniqueInput
  }

  /**
   * campaign_categories updateMany
   */
  export type campaign_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaign_categories.
     */
    data: XOR<campaign_categoriesUpdateManyMutationInput, campaign_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which campaign_categories to update
     */
    where?: campaign_categoriesWhereInput
  }

  /**
   * campaign_categories upsert
   */
  export type campaign_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the campaign_categories to update in case it exists.
     */
    where: campaign_categoriesWhereUniqueInput
    /**
     * In case the campaign_categories found by the `where` argument doesn't exist, create a new campaign_categories with this data.
     */
    create: XOR<campaign_categoriesCreateInput, campaign_categoriesUncheckedCreateInput>
    /**
     * In case the campaign_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaign_categoriesUpdateInput, campaign_categoriesUncheckedUpdateInput>
  }

  /**
   * campaign_categories delete
   */
  export type campaign_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
    /**
     * Filter which campaign_categories to delete.
     */
    where: campaign_categoriesWhereUniqueInput
  }

  /**
   * campaign_categories deleteMany
   */
  export type campaign_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_categories to delete
     */
    where?: campaign_categoriesWhereInput
  }

  /**
   * campaign_categories.campaign_category_relations
   */
  export type campaign_categories$campaign_category_relationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    where?: campaign_category_relationsWhereInput
    orderBy?: campaign_category_relationsOrderByWithRelationInput | campaign_category_relationsOrderByWithRelationInput[]
    cursor?: campaign_category_relationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Campaign_category_relationsScalarFieldEnum | Campaign_category_relationsScalarFieldEnum[]
  }

  /**
   * campaign_categories without action
   */
  export type campaign_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_categories
     */
    select?: campaign_categoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model campaign_category_relations
   */

  export type AggregateCampaign_category_relations = {
    _count: Campaign_category_relationsCountAggregateOutputType | null
    _min: Campaign_category_relationsMinAggregateOutputType | null
    _max: Campaign_category_relationsMaxAggregateOutputType | null
  }

  export type Campaign_category_relationsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    categoryId: string | null
    createdAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_category_relationsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    categoryId: string | null
    createdAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_category_relationsCountAggregateOutputType = {
    id: number
    campaignId: number
    categoryId: number
    createdAt: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Campaign_category_relationsMinAggregateInputType = {
    id?: true
    campaignId?: true
    categoryId?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_category_relationsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    categoryId?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_category_relationsCountAggregateInputType = {
    id?: true
    campaignId?: true
    categoryId?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Campaign_category_relationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_category_relations to aggregate.
     */
    where?: campaign_category_relationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_category_relations to fetch.
     */
    orderBy?: campaign_category_relationsOrderByWithRelationInput | campaign_category_relationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaign_category_relationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_category_relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_category_relations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaign_category_relations
    **/
    _count?: true | Campaign_category_relationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Campaign_category_relationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Campaign_category_relationsMaxAggregateInputType
  }

  export type GetCampaign_category_relationsAggregateType<T extends Campaign_category_relationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign_category_relations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign_category_relations[P]>
      : GetScalarType<T[P], AggregateCampaign_category_relations[P]>
  }




  export type campaign_category_relationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_category_relationsWhereInput
    orderBy?: campaign_category_relationsOrderByWithAggregationInput | campaign_category_relationsOrderByWithAggregationInput[]
    by: Campaign_category_relationsScalarFieldEnum[] | Campaign_category_relationsScalarFieldEnum
    having?: campaign_category_relationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Campaign_category_relationsCountAggregateInputType | true
    _min?: Campaign_category_relationsMinAggregateInputType
    _max?: Campaign_category_relationsMaxAggregateInputType
  }

  export type Campaign_category_relationsGroupByOutputType = {
    id: string
    campaignId: string
    categoryId: string
    createdAt: Date
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Campaign_category_relationsCountAggregateOutputType | null
    _min: Campaign_category_relationsMinAggregateOutputType | null
    _max: Campaign_category_relationsMaxAggregateOutputType | null
  }

  type GetCampaign_category_relationsGroupByPayload<T extends campaign_category_relationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Campaign_category_relationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Campaign_category_relationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Campaign_category_relationsGroupByOutputType[P]>
            : GetScalarType<T[P], Campaign_category_relationsGroupByOutputType[P]>
        }
      >
    >


  export type campaign_category_relationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
    campaign_categories?: boolean | campaign_categoriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign_category_relations"]>

  export type campaign_category_relationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
    campaign_categories?: boolean | campaign_categoriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign_category_relations"]>

  export type campaign_category_relationsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type campaign_category_relationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
    campaign_categories?: boolean | campaign_categoriesDefaultArgs<ExtArgs>
  }
  export type campaign_category_relationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
    campaign_categories?: boolean | campaign_categoriesDefaultArgs<ExtArgs>
  }

  export type $campaign_category_relationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaign_category_relations"
    objects: {
      campaigns: Prisma.$campaignsPayload<ExtArgs>
      campaign_categories: Prisma.$campaign_categoriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      categoryId: string
      createdAt: Date
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["campaign_category_relations"]>
    composites: {}
  }

  type campaign_category_relationsGetPayload<S extends boolean | null | undefined | campaign_category_relationsDefaultArgs> = $Result.GetResult<Prisma.$campaign_category_relationsPayload, S>

  type campaign_category_relationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<campaign_category_relationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Campaign_category_relationsCountAggregateInputType | true
    }

  export interface campaign_category_relationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaign_category_relations'], meta: { name: 'campaign_category_relations' } }
    /**
     * Find zero or one Campaign_category_relations that matches the filter.
     * @param {campaign_category_relationsFindUniqueArgs} args - Arguments to find a Campaign_category_relations
     * @example
     * // Get one Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaign_category_relationsFindUniqueArgs>(args: SelectSubset<T, campaign_category_relationsFindUniqueArgs<ExtArgs>>): Prisma__campaign_category_relationsClient<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign_category_relations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {campaign_category_relationsFindUniqueOrThrowArgs} args - Arguments to find a Campaign_category_relations
     * @example
     * // Get one Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaign_category_relationsFindUniqueOrThrowArgs>(args: SelectSubset<T, campaign_category_relationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaign_category_relationsClient<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign_category_relations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_category_relationsFindFirstArgs} args - Arguments to find a Campaign_category_relations
     * @example
     * // Get one Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaign_category_relationsFindFirstArgs>(args?: SelectSubset<T, campaign_category_relationsFindFirstArgs<ExtArgs>>): Prisma__campaign_category_relationsClient<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign_category_relations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_category_relationsFindFirstOrThrowArgs} args - Arguments to find a Campaign_category_relations
     * @example
     * // Get one Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaign_category_relationsFindFirstOrThrowArgs>(args?: SelectSubset<T, campaign_category_relationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaign_category_relationsClient<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaign_category_relations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_category_relationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.findMany()
     * 
     * // Get first 10 Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaign_category_relationsWithIdOnly = await prisma.campaign_category_relations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaign_category_relationsFindManyArgs>(args?: SelectSubset<T, campaign_category_relationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign_category_relations.
     * @param {campaign_category_relationsCreateArgs} args - Arguments to create a Campaign_category_relations.
     * @example
     * // Create one Campaign_category_relations
     * const Campaign_category_relations = await prisma.campaign_category_relations.create({
     *   data: {
     *     // ... data to create a Campaign_category_relations
     *   }
     * })
     * 
     */
    create<T extends campaign_category_relationsCreateArgs>(args: SelectSubset<T, campaign_category_relationsCreateArgs<ExtArgs>>): Prisma__campaign_category_relationsClient<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaign_category_relations.
     * @param {campaign_category_relationsCreateManyArgs} args - Arguments to create many Campaign_category_relations.
     * @example
     * // Create many Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaign_category_relationsCreateManyArgs>(args?: SelectSubset<T, campaign_category_relationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaign_category_relations and returns the data saved in the database.
     * @param {campaign_category_relationsCreateManyAndReturnArgs} args - Arguments to create many Campaign_category_relations.
     * @example
     * // Create many Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaign_category_relations and only return the `id`
     * const campaign_category_relationsWithIdOnly = await prisma.campaign_category_relations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaign_category_relationsCreateManyAndReturnArgs>(args?: SelectSubset<T, campaign_category_relationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign_category_relations.
     * @param {campaign_category_relationsDeleteArgs} args - Arguments to delete one Campaign_category_relations.
     * @example
     * // Delete one Campaign_category_relations
     * const Campaign_category_relations = await prisma.campaign_category_relations.delete({
     *   where: {
     *     // ... filter to delete one Campaign_category_relations
     *   }
     * })
     * 
     */
    delete<T extends campaign_category_relationsDeleteArgs>(args: SelectSubset<T, campaign_category_relationsDeleteArgs<ExtArgs>>): Prisma__campaign_category_relationsClient<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign_category_relations.
     * @param {campaign_category_relationsUpdateArgs} args - Arguments to update one Campaign_category_relations.
     * @example
     * // Update one Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaign_category_relationsUpdateArgs>(args: SelectSubset<T, campaign_category_relationsUpdateArgs<ExtArgs>>): Prisma__campaign_category_relationsClient<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaign_category_relations.
     * @param {campaign_category_relationsDeleteManyArgs} args - Arguments to filter Campaign_category_relations to delete.
     * @example
     * // Delete a few Campaign_category_relations
     * const { count } = await prisma.campaign_category_relations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaign_category_relationsDeleteManyArgs>(args?: SelectSubset<T, campaign_category_relationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaign_category_relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_category_relationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaign_category_relationsUpdateManyArgs>(args: SelectSubset<T, campaign_category_relationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign_category_relations.
     * @param {campaign_category_relationsUpsertArgs} args - Arguments to update or create a Campaign_category_relations.
     * @example
     * // Update or create a Campaign_category_relations
     * const campaign_category_relations = await prisma.campaign_category_relations.upsert({
     *   create: {
     *     // ... data to create a Campaign_category_relations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign_category_relations we want to update
     *   }
     * })
     */
    upsert<T extends campaign_category_relationsUpsertArgs>(args: SelectSubset<T, campaign_category_relationsUpsertArgs<ExtArgs>>): Prisma__campaign_category_relationsClient<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaign_category_relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_category_relationsCountArgs} args - Arguments to filter Campaign_category_relations to count.
     * @example
     * // Count the number of Campaign_category_relations
     * const count = await prisma.campaign_category_relations.count({
     *   where: {
     *     // ... the filter for the Campaign_category_relations we want to count
     *   }
     * })
    **/
    count<T extends campaign_category_relationsCountArgs>(
      args?: Subset<T, campaign_category_relationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Campaign_category_relationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign_category_relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_category_relationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Campaign_category_relationsAggregateArgs>(args: Subset<T, Campaign_category_relationsAggregateArgs>): Prisma.PrismaPromise<GetCampaign_category_relationsAggregateType<T>>

    /**
     * Group by Campaign_category_relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_category_relationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaign_category_relationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaign_category_relationsGroupByArgs['orderBy'] }
        : { orderBy?: campaign_category_relationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaign_category_relationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaign_category_relationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaign_category_relations model
   */
  readonly fields: campaign_category_relationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaign_category_relations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaign_category_relationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends campaignsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, campaignsDefaultArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaign_categories<T extends campaign_categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, campaign_categoriesDefaultArgs<ExtArgs>>): Prisma__campaign_categoriesClient<$Result.GetResult<Prisma.$campaign_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaign_category_relations model
   */ 
  interface campaign_category_relationsFieldRefs {
    readonly id: FieldRef<"campaign_category_relations", 'String'>
    readonly campaignId: FieldRef<"campaign_category_relations", 'String'>
    readonly categoryId: FieldRef<"campaign_category_relations", 'String'>
    readonly createdAt: FieldRef<"campaign_category_relations", 'DateTime'>
    readonly deleted_at: FieldRef<"campaign_category_relations", 'DateTime'>
    readonly deleted_by: FieldRef<"campaign_category_relations", 'String'>
    readonly is_deleted: FieldRef<"campaign_category_relations", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * campaign_category_relations findUnique
   */
  export type campaign_category_relationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_category_relations to fetch.
     */
    where: campaign_category_relationsWhereUniqueInput
  }

  /**
   * campaign_category_relations findUniqueOrThrow
   */
  export type campaign_category_relationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_category_relations to fetch.
     */
    where: campaign_category_relationsWhereUniqueInput
  }

  /**
   * campaign_category_relations findFirst
   */
  export type campaign_category_relationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_category_relations to fetch.
     */
    where?: campaign_category_relationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_category_relations to fetch.
     */
    orderBy?: campaign_category_relationsOrderByWithRelationInput | campaign_category_relationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_category_relations.
     */
    cursor?: campaign_category_relationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_category_relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_category_relations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_category_relations.
     */
    distinct?: Campaign_category_relationsScalarFieldEnum | Campaign_category_relationsScalarFieldEnum[]
  }

  /**
   * campaign_category_relations findFirstOrThrow
   */
  export type campaign_category_relationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_category_relations to fetch.
     */
    where?: campaign_category_relationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_category_relations to fetch.
     */
    orderBy?: campaign_category_relationsOrderByWithRelationInput | campaign_category_relationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_category_relations.
     */
    cursor?: campaign_category_relationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_category_relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_category_relations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_category_relations.
     */
    distinct?: Campaign_category_relationsScalarFieldEnum | Campaign_category_relationsScalarFieldEnum[]
  }

  /**
   * campaign_category_relations findMany
   */
  export type campaign_category_relationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_category_relations to fetch.
     */
    where?: campaign_category_relationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_category_relations to fetch.
     */
    orderBy?: campaign_category_relationsOrderByWithRelationInput | campaign_category_relationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaign_category_relations.
     */
    cursor?: campaign_category_relationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_category_relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_category_relations.
     */
    skip?: number
    distinct?: Campaign_category_relationsScalarFieldEnum | Campaign_category_relationsScalarFieldEnum[]
  }

  /**
   * campaign_category_relations create
   */
  export type campaign_category_relationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    /**
     * The data needed to create a campaign_category_relations.
     */
    data: XOR<campaign_category_relationsCreateInput, campaign_category_relationsUncheckedCreateInput>
  }

  /**
   * campaign_category_relations createMany
   */
  export type campaign_category_relationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaign_category_relations.
     */
    data: campaign_category_relationsCreateManyInput | campaign_category_relationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campaign_category_relations createManyAndReturn
   */
  export type campaign_category_relationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many campaign_category_relations.
     */
    data: campaign_category_relationsCreateManyInput | campaign_category_relationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * campaign_category_relations update
   */
  export type campaign_category_relationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    /**
     * The data needed to update a campaign_category_relations.
     */
    data: XOR<campaign_category_relationsUpdateInput, campaign_category_relationsUncheckedUpdateInput>
    /**
     * Choose, which campaign_category_relations to update.
     */
    where: campaign_category_relationsWhereUniqueInput
  }

  /**
   * campaign_category_relations updateMany
   */
  export type campaign_category_relationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaign_category_relations.
     */
    data: XOR<campaign_category_relationsUpdateManyMutationInput, campaign_category_relationsUncheckedUpdateManyInput>
    /**
     * Filter which campaign_category_relations to update
     */
    where?: campaign_category_relationsWhereInput
  }

  /**
   * campaign_category_relations upsert
   */
  export type campaign_category_relationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    /**
     * The filter to search for the campaign_category_relations to update in case it exists.
     */
    where: campaign_category_relationsWhereUniqueInput
    /**
     * In case the campaign_category_relations found by the `where` argument doesn't exist, create a new campaign_category_relations with this data.
     */
    create: XOR<campaign_category_relationsCreateInput, campaign_category_relationsUncheckedCreateInput>
    /**
     * In case the campaign_category_relations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaign_category_relationsUpdateInput, campaign_category_relationsUncheckedUpdateInput>
  }

  /**
   * campaign_category_relations delete
   */
  export type campaign_category_relationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    /**
     * Filter which campaign_category_relations to delete.
     */
    where: campaign_category_relationsWhereUniqueInput
  }

  /**
   * campaign_category_relations deleteMany
   */
  export type campaign_category_relationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_category_relations to delete
     */
    where?: campaign_category_relationsWhereInput
  }

  /**
   * campaign_category_relations without action
   */
  export type campaign_category_relationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
  }


  /**
   * Model campaign_items
   */

  export type AggregateCampaign_items = {
    _count: Campaign_itemsCountAggregateOutputType | null
    _avg: Campaign_itemsAvgAggregateOutputType | null
    _sum: Campaign_itemsSumAggregateOutputType | null
    _min: Campaign_itemsMinAggregateOutputType | null
    _max: Campaign_itemsMaxAggregateOutputType | null
  }

  export type Campaign_itemsAvgAggregateOutputType = {
    priority: number | null
  }

  export type Campaign_itemsSumAggregateOutputType = {
    priority: number | null
  }

  export type Campaign_itemsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    itemId: string | null
    itemType: string | null
    priority: number | null
    createdAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_itemsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    itemId: string | null
    itemType: string | null
    priority: number | null
    createdAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_itemsCountAggregateOutputType = {
    id: number
    campaignId: number
    itemId: number
    itemType: number
    priority: number
    createdAt: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Campaign_itemsAvgAggregateInputType = {
    priority?: true
  }

  export type Campaign_itemsSumAggregateInputType = {
    priority?: true
  }

  export type Campaign_itemsMinAggregateInputType = {
    id?: true
    campaignId?: true
    itemId?: true
    itemType?: true
    priority?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_itemsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    itemId?: true
    itemType?: true
    priority?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_itemsCountAggregateInputType = {
    id?: true
    campaignId?: true
    itemId?: true
    itemType?: true
    priority?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Campaign_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_items to aggregate.
     */
    where?: campaign_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_items to fetch.
     */
    orderBy?: campaign_itemsOrderByWithRelationInput | campaign_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaign_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaign_items
    **/
    _count?: true | Campaign_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Campaign_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Campaign_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Campaign_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Campaign_itemsMaxAggregateInputType
  }

  export type GetCampaign_itemsAggregateType<T extends Campaign_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign_items[P]>
      : GetScalarType<T[P], AggregateCampaign_items[P]>
  }




  export type campaign_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_itemsWhereInput
    orderBy?: campaign_itemsOrderByWithAggregationInput | campaign_itemsOrderByWithAggregationInput[]
    by: Campaign_itemsScalarFieldEnum[] | Campaign_itemsScalarFieldEnum
    having?: campaign_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Campaign_itemsCountAggregateInputType | true
    _avg?: Campaign_itemsAvgAggregateInputType
    _sum?: Campaign_itemsSumAggregateInputType
    _min?: Campaign_itemsMinAggregateInputType
    _max?: Campaign_itemsMaxAggregateInputType
  }

  export type Campaign_itemsGroupByOutputType = {
    id: string
    campaignId: string
    itemId: string
    itemType: string
    priority: number
    createdAt: Date
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Campaign_itemsCountAggregateOutputType | null
    _avg: Campaign_itemsAvgAggregateOutputType | null
    _sum: Campaign_itemsSumAggregateOutputType | null
    _min: Campaign_itemsMinAggregateOutputType | null
    _max: Campaign_itemsMaxAggregateOutputType | null
  }

  type GetCampaign_itemsGroupByPayload<T extends campaign_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Campaign_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Campaign_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Campaign_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Campaign_itemsGroupByOutputType[P]>
        }
      >
    >


  export type campaign_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    itemId?: boolean
    itemType?: boolean
    priority?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign_items"]>

  export type campaign_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    itemId?: boolean
    itemType?: boolean
    priority?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign_items"]>

  export type campaign_itemsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    itemId?: boolean
    itemType?: boolean
    priority?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type campaign_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }
  export type campaign_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }

  export type $campaign_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaign_items"
    objects: {
      campaigns: Prisma.$campaignsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      itemId: string
      itemType: string
      priority: number
      createdAt: Date
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["campaign_items"]>
    composites: {}
  }

  type campaign_itemsGetPayload<S extends boolean | null | undefined | campaign_itemsDefaultArgs> = $Result.GetResult<Prisma.$campaign_itemsPayload, S>

  type campaign_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<campaign_itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Campaign_itemsCountAggregateInputType | true
    }

  export interface campaign_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaign_items'], meta: { name: 'campaign_items' } }
    /**
     * Find zero or one Campaign_items that matches the filter.
     * @param {campaign_itemsFindUniqueArgs} args - Arguments to find a Campaign_items
     * @example
     * // Get one Campaign_items
     * const campaign_items = await prisma.campaign_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaign_itemsFindUniqueArgs>(args: SelectSubset<T, campaign_itemsFindUniqueArgs<ExtArgs>>): Prisma__campaign_itemsClient<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign_items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {campaign_itemsFindUniqueOrThrowArgs} args - Arguments to find a Campaign_items
     * @example
     * // Get one Campaign_items
     * const campaign_items = await prisma.campaign_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaign_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, campaign_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaign_itemsClient<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_itemsFindFirstArgs} args - Arguments to find a Campaign_items
     * @example
     * // Get one Campaign_items
     * const campaign_items = await prisma.campaign_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaign_itemsFindFirstArgs>(args?: SelectSubset<T, campaign_itemsFindFirstArgs<ExtArgs>>): Prisma__campaign_itemsClient<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_itemsFindFirstOrThrowArgs} args - Arguments to find a Campaign_items
     * @example
     * // Get one Campaign_items
     * const campaign_items = await prisma.campaign_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaign_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, campaign_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaign_itemsClient<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaign_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaign_items
     * const campaign_items = await prisma.campaign_items.findMany()
     * 
     * // Get first 10 Campaign_items
     * const campaign_items = await prisma.campaign_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaign_itemsWithIdOnly = await prisma.campaign_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaign_itemsFindManyArgs>(args?: SelectSubset<T, campaign_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign_items.
     * @param {campaign_itemsCreateArgs} args - Arguments to create a Campaign_items.
     * @example
     * // Create one Campaign_items
     * const Campaign_items = await prisma.campaign_items.create({
     *   data: {
     *     // ... data to create a Campaign_items
     *   }
     * })
     * 
     */
    create<T extends campaign_itemsCreateArgs>(args: SelectSubset<T, campaign_itemsCreateArgs<ExtArgs>>): Prisma__campaign_itemsClient<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaign_items.
     * @param {campaign_itemsCreateManyArgs} args - Arguments to create many Campaign_items.
     * @example
     * // Create many Campaign_items
     * const campaign_items = await prisma.campaign_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaign_itemsCreateManyArgs>(args?: SelectSubset<T, campaign_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaign_items and returns the data saved in the database.
     * @param {campaign_itemsCreateManyAndReturnArgs} args - Arguments to create many Campaign_items.
     * @example
     * // Create many Campaign_items
     * const campaign_items = await prisma.campaign_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaign_items and only return the `id`
     * const campaign_itemsWithIdOnly = await prisma.campaign_items.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaign_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, campaign_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign_items.
     * @param {campaign_itemsDeleteArgs} args - Arguments to delete one Campaign_items.
     * @example
     * // Delete one Campaign_items
     * const Campaign_items = await prisma.campaign_items.delete({
     *   where: {
     *     // ... filter to delete one Campaign_items
     *   }
     * })
     * 
     */
    delete<T extends campaign_itemsDeleteArgs>(args: SelectSubset<T, campaign_itemsDeleteArgs<ExtArgs>>): Prisma__campaign_itemsClient<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign_items.
     * @param {campaign_itemsUpdateArgs} args - Arguments to update one Campaign_items.
     * @example
     * // Update one Campaign_items
     * const campaign_items = await prisma.campaign_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaign_itemsUpdateArgs>(args: SelectSubset<T, campaign_itemsUpdateArgs<ExtArgs>>): Prisma__campaign_itemsClient<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaign_items.
     * @param {campaign_itemsDeleteManyArgs} args - Arguments to filter Campaign_items to delete.
     * @example
     * // Delete a few Campaign_items
     * const { count } = await prisma.campaign_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaign_itemsDeleteManyArgs>(args?: SelectSubset<T, campaign_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaign_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaign_items
     * const campaign_items = await prisma.campaign_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaign_itemsUpdateManyArgs>(args: SelectSubset<T, campaign_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign_items.
     * @param {campaign_itemsUpsertArgs} args - Arguments to update or create a Campaign_items.
     * @example
     * // Update or create a Campaign_items
     * const campaign_items = await prisma.campaign_items.upsert({
     *   create: {
     *     // ... data to create a Campaign_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign_items we want to update
     *   }
     * })
     */
    upsert<T extends campaign_itemsUpsertArgs>(args: SelectSubset<T, campaign_itemsUpsertArgs<ExtArgs>>): Prisma__campaign_itemsClient<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaign_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_itemsCountArgs} args - Arguments to filter Campaign_items to count.
     * @example
     * // Count the number of Campaign_items
     * const count = await prisma.campaign_items.count({
     *   where: {
     *     // ... the filter for the Campaign_items we want to count
     *   }
     * })
    **/
    count<T extends campaign_itemsCountArgs>(
      args?: Subset<T, campaign_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Campaign_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Campaign_itemsAggregateArgs>(args: Subset<T, Campaign_itemsAggregateArgs>): Prisma.PrismaPromise<GetCampaign_itemsAggregateType<T>>

    /**
     * Group by Campaign_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaign_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaign_itemsGroupByArgs['orderBy'] }
        : { orderBy?: campaign_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaign_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaign_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaign_items model
   */
  readonly fields: campaign_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaign_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaign_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends campaignsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, campaignsDefaultArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaign_items model
   */ 
  interface campaign_itemsFieldRefs {
    readonly id: FieldRef<"campaign_items", 'String'>
    readonly campaignId: FieldRef<"campaign_items", 'String'>
    readonly itemId: FieldRef<"campaign_items", 'String'>
    readonly itemType: FieldRef<"campaign_items", 'String'>
    readonly priority: FieldRef<"campaign_items", 'Int'>
    readonly createdAt: FieldRef<"campaign_items", 'DateTime'>
    readonly deleted_at: FieldRef<"campaign_items", 'DateTime'>
    readonly deleted_by: FieldRef<"campaign_items", 'String'>
    readonly is_deleted: FieldRef<"campaign_items", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * campaign_items findUnique
   */
  export type campaign_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_items to fetch.
     */
    where: campaign_itemsWhereUniqueInput
  }

  /**
   * campaign_items findUniqueOrThrow
   */
  export type campaign_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_items to fetch.
     */
    where: campaign_itemsWhereUniqueInput
  }

  /**
   * campaign_items findFirst
   */
  export type campaign_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_items to fetch.
     */
    where?: campaign_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_items to fetch.
     */
    orderBy?: campaign_itemsOrderByWithRelationInput | campaign_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_items.
     */
    cursor?: campaign_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_items.
     */
    distinct?: Campaign_itemsScalarFieldEnum | Campaign_itemsScalarFieldEnum[]
  }

  /**
   * campaign_items findFirstOrThrow
   */
  export type campaign_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_items to fetch.
     */
    where?: campaign_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_items to fetch.
     */
    orderBy?: campaign_itemsOrderByWithRelationInput | campaign_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_items.
     */
    cursor?: campaign_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_items.
     */
    distinct?: Campaign_itemsScalarFieldEnum | Campaign_itemsScalarFieldEnum[]
  }

  /**
   * campaign_items findMany
   */
  export type campaign_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_items to fetch.
     */
    where?: campaign_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_items to fetch.
     */
    orderBy?: campaign_itemsOrderByWithRelationInput | campaign_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaign_items.
     */
    cursor?: campaign_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_items.
     */
    skip?: number
    distinct?: Campaign_itemsScalarFieldEnum | Campaign_itemsScalarFieldEnum[]
  }

  /**
   * campaign_items create
   */
  export type campaign_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a campaign_items.
     */
    data: XOR<campaign_itemsCreateInput, campaign_itemsUncheckedCreateInput>
  }

  /**
   * campaign_items createMany
   */
  export type campaign_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaign_items.
     */
    data: campaign_itemsCreateManyInput | campaign_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campaign_items createManyAndReturn
   */
  export type campaign_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many campaign_items.
     */
    data: campaign_itemsCreateManyInput | campaign_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * campaign_items update
   */
  export type campaign_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a campaign_items.
     */
    data: XOR<campaign_itemsUpdateInput, campaign_itemsUncheckedUpdateInput>
    /**
     * Choose, which campaign_items to update.
     */
    where: campaign_itemsWhereUniqueInput
  }

  /**
   * campaign_items updateMany
   */
  export type campaign_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaign_items.
     */
    data: XOR<campaign_itemsUpdateManyMutationInput, campaign_itemsUncheckedUpdateManyInput>
    /**
     * Filter which campaign_items to update
     */
    where?: campaign_itemsWhereInput
  }

  /**
   * campaign_items upsert
   */
  export type campaign_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the campaign_items to update in case it exists.
     */
    where: campaign_itemsWhereUniqueInput
    /**
     * In case the campaign_items found by the `where` argument doesn't exist, create a new campaign_items with this data.
     */
    create: XOR<campaign_itemsCreateInput, campaign_itemsUncheckedCreateInput>
    /**
     * In case the campaign_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaign_itemsUpdateInput, campaign_itemsUncheckedUpdateInput>
  }

  /**
   * campaign_items delete
   */
  export type campaign_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    /**
     * Filter which campaign_items to delete.
     */
    where: campaign_itemsWhereUniqueInput
  }

  /**
   * campaign_items deleteMany
   */
  export type campaign_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_items to delete
     */
    where?: campaign_itemsWhereInput
  }

  /**
   * campaign_items without action
   */
  export type campaign_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
  }


  /**
   * Model campaign_translations
   */

  export type AggregateCampaign_translations = {
    _count: Campaign_translationsCountAggregateOutputType | null
    _min: Campaign_translationsMinAggregateOutputType | null
    _max: Campaign_translationsMaxAggregateOutputType | null
  }

  export type Campaign_translationsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    locale: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    languageCode: string | null
    name: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_translationsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    locale: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    languageCode: string | null
    name: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_translationsCountAggregateOutputType = {
    id: number
    campaignId: number
    locale: number
    title: number
    description: number
    imageUrl: number
    languageCode: number
    name: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Campaign_translationsMinAggregateInputType = {
    id?: true
    campaignId?: true
    locale?: true
    title?: true
    description?: true
    imageUrl?: true
    languageCode?: true
    name?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_translationsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    locale?: true
    title?: true
    description?: true
    imageUrl?: true
    languageCode?: true
    name?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_translationsCountAggregateInputType = {
    id?: true
    campaignId?: true
    locale?: true
    title?: true
    description?: true
    imageUrl?: true
    languageCode?: true
    name?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Campaign_translationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_translations to aggregate.
     */
    where?: campaign_translationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_translations to fetch.
     */
    orderBy?: campaign_translationsOrderByWithRelationInput | campaign_translationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaign_translationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaign_translations
    **/
    _count?: true | Campaign_translationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Campaign_translationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Campaign_translationsMaxAggregateInputType
  }

  export type GetCampaign_translationsAggregateType<T extends Campaign_translationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign_translations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign_translations[P]>
      : GetScalarType<T[P], AggregateCampaign_translations[P]>
  }




  export type campaign_translationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_translationsWhereInput
    orderBy?: campaign_translationsOrderByWithAggregationInput | campaign_translationsOrderByWithAggregationInput[]
    by: Campaign_translationsScalarFieldEnum[] | Campaign_translationsScalarFieldEnum
    having?: campaign_translationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Campaign_translationsCountAggregateInputType | true
    _min?: Campaign_translationsMinAggregateInputType
    _max?: Campaign_translationsMaxAggregateInputType
  }

  export type Campaign_translationsGroupByOutputType = {
    id: string
    campaignId: string
    locale: string
    title: string
    description: string | null
    imageUrl: string | null
    languageCode: string | null
    name: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Campaign_translationsCountAggregateOutputType | null
    _min: Campaign_translationsMinAggregateOutputType | null
    _max: Campaign_translationsMaxAggregateOutputType | null
  }

  type GetCampaign_translationsGroupByPayload<T extends campaign_translationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Campaign_translationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Campaign_translationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Campaign_translationsGroupByOutputType[P]>
            : GetScalarType<T[P], Campaign_translationsGroupByOutputType[P]>
        }
      >
    >


  export type campaign_translationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    languageCode?: boolean
    name?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign_translations"]>

  export type campaign_translationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    languageCode?: boolean
    name?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign_translations"]>

  export type campaign_translationsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    locale?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    languageCode?: boolean
    name?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type campaign_translationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }
  export type campaign_translationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }

  export type $campaign_translationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaign_translations"
    objects: {
      campaigns: Prisma.$campaignsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      locale: string
      title: string
      description: string | null
      imageUrl: string | null
      languageCode: string | null
      name: string | null
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["campaign_translations"]>
    composites: {}
  }

  type campaign_translationsGetPayload<S extends boolean | null | undefined | campaign_translationsDefaultArgs> = $Result.GetResult<Prisma.$campaign_translationsPayload, S>

  type campaign_translationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<campaign_translationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Campaign_translationsCountAggregateInputType | true
    }

  export interface campaign_translationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaign_translations'], meta: { name: 'campaign_translations' } }
    /**
     * Find zero or one Campaign_translations that matches the filter.
     * @param {campaign_translationsFindUniqueArgs} args - Arguments to find a Campaign_translations
     * @example
     * // Get one Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaign_translationsFindUniqueArgs>(args: SelectSubset<T, campaign_translationsFindUniqueArgs<ExtArgs>>): Prisma__campaign_translationsClient<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign_translations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {campaign_translationsFindUniqueOrThrowArgs} args - Arguments to find a Campaign_translations
     * @example
     * // Get one Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaign_translationsFindUniqueOrThrowArgs>(args: SelectSubset<T, campaign_translationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaign_translationsClient<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign_translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_translationsFindFirstArgs} args - Arguments to find a Campaign_translations
     * @example
     * // Get one Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaign_translationsFindFirstArgs>(args?: SelectSubset<T, campaign_translationsFindFirstArgs<ExtArgs>>): Prisma__campaign_translationsClient<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign_translations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_translationsFindFirstOrThrowArgs} args - Arguments to find a Campaign_translations
     * @example
     * // Get one Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaign_translationsFindFirstOrThrowArgs>(args?: SelectSubset<T, campaign_translationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaign_translationsClient<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaign_translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_translationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.findMany()
     * 
     * // Get first 10 Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaign_translationsWithIdOnly = await prisma.campaign_translations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaign_translationsFindManyArgs>(args?: SelectSubset<T, campaign_translationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign_translations.
     * @param {campaign_translationsCreateArgs} args - Arguments to create a Campaign_translations.
     * @example
     * // Create one Campaign_translations
     * const Campaign_translations = await prisma.campaign_translations.create({
     *   data: {
     *     // ... data to create a Campaign_translations
     *   }
     * })
     * 
     */
    create<T extends campaign_translationsCreateArgs>(args: SelectSubset<T, campaign_translationsCreateArgs<ExtArgs>>): Prisma__campaign_translationsClient<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaign_translations.
     * @param {campaign_translationsCreateManyArgs} args - Arguments to create many Campaign_translations.
     * @example
     * // Create many Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaign_translationsCreateManyArgs>(args?: SelectSubset<T, campaign_translationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaign_translations and returns the data saved in the database.
     * @param {campaign_translationsCreateManyAndReturnArgs} args - Arguments to create many Campaign_translations.
     * @example
     * // Create many Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaign_translations and only return the `id`
     * const campaign_translationsWithIdOnly = await prisma.campaign_translations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaign_translationsCreateManyAndReturnArgs>(args?: SelectSubset<T, campaign_translationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign_translations.
     * @param {campaign_translationsDeleteArgs} args - Arguments to delete one Campaign_translations.
     * @example
     * // Delete one Campaign_translations
     * const Campaign_translations = await prisma.campaign_translations.delete({
     *   where: {
     *     // ... filter to delete one Campaign_translations
     *   }
     * })
     * 
     */
    delete<T extends campaign_translationsDeleteArgs>(args: SelectSubset<T, campaign_translationsDeleteArgs<ExtArgs>>): Prisma__campaign_translationsClient<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign_translations.
     * @param {campaign_translationsUpdateArgs} args - Arguments to update one Campaign_translations.
     * @example
     * // Update one Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaign_translationsUpdateArgs>(args: SelectSubset<T, campaign_translationsUpdateArgs<ExtArgs>>): Prisma__campaign_translationsClient<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaign_translations.
     * @param {campaign_translationsDeleteManyArgs} args - Arguments to filter Campaign_translations to delete.
     * @example
     * // Delete a few Campaign_translations
     * const { count } = await prisma.campaign_translations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaign_translationsDeleteManyArgs>(args?: SelectSubset<T, campaign_translationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaign_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_translationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaign_translationsUpdateManyArgs>(args: SelectSubset<T, campaign_translationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign_translations.
     * @param {campaign_translationsUpsertArgs} args - Arguments to update or create a Campaign_translations.
     * @example
     * // Update or create a Campaign_translations
     * const campaign_translations = await prisma.campaign_translations.upsert({
     *   create: {
     *     // ... data to create a Campaign_translations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign_translations we want to update
     *   }
     * })
     */
    upsert<T extends campaign_translationsUpsertArgs>(args: SelectSubset<T, campaign_translationsUpsertArgs<ExtArgs>>): Prisma__campaign_translationsClient<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaign_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_translationsCountArgs} args - Arguments to filter Campaign_translations to count.
     * @example
     * // Count the number of Campaign_translations
     * const count = await prisma.campaign_translations.count({
     *   where: {
     *     // ... the filter for the Campaign_translations we want to count
     *   }
     * })
    **/
    count<T extends campaign_translationsCountArgs>(
      args?: Subset<T, campaign_translationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Campaign_translationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_translationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Campaign_translationsAggregateArgs>(args: Subset<T, Campaign_translationsAggregateArgs>): Prisma.PrismaPromise<GetCampaign_translationsAggregateType<T>>

    /**
     * Group by Campaign_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_translationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaign_translationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaign_translationsGroupByArgs['orderBy'] }
        : { orderBy?: campaign_translationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaign_translationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaign_translationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaign_translations model
   */
  readonly fields: campaign_translationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaign_translations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaign_translationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends campaignsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, campaignsDefaultArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaign_translations model
   */ 
  interface campaign_translationsFieldRefs {
    readonly id: FieldRef<"campaign_translations", 'String'>
    readonly campaignId: FieldRef<"campaign_translations", 'String'>
    readonly locale: FieldRef<"campaign_translations", 'String'>
    readonly title: FieldRef<"campaign_translations", 'String'>
    readonly description: FieldRef<"campaign_translations", 'String'>
    readonly imageUrl: FieldRef<"campaign_translations", 'String'>
    readonly languageCode: FieldRef<"campaign_translations", 'String'>
    readonly name: FieldRef<"campaign_translations", 'String'>
    readonly deleted_at: FieldRef<"campaign_translations", 'DateTime'>
    readonly deleted_by: FieldRef<"campaign_translations", 'String'>
    readonly is_deleted: FieldRef<"campaign_translations", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * campaign_translations findUnique
   */
  export type campaign_translationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_translations to fetch.
     */
    where: campaign_translationsWhereUniqueInput
  }

  /**
   * campaign_translations findUniqueOrThrow
   */
  export type campaign_translationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_translations to fetch.
     */
    where: campaign_translationsWhereUniqueInput
  }

  /**
   * campaign_translations findFirst
   */
  export type campaign_translationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_translations to fetch.
     */
    where?: campaign_translationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_translations to fetch.
     */
    orderBy?: campaign_translationsOrderByWithRelationInput | campaign_translationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_translations.
     */
    cursor?: campaign_translationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_translations.
     */
    distinct?: Campaign_translationsScalarFieldEnum | Campaign_translationsScalarFieldEnum[]
  }

  /**
   * campaign_translations findFirstOrThrow
   */
  export type campaign_translationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_translations to fetch.
     */
    where?: campaign_translationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_translations to fetch.
     */
    orderBy?: campaign_translationsOrderByWithRelationInput | campaign_translationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_translations.
     */
    cursor?: campaign_translationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_translations.
     */
    distinct?: Campaign_translationsScalarFieldEnum | Campaign_translationsScalarFieldEnum[]
  }

  /**
   * campaign_translations findMany
   */
  export type campaign_translationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_translations to fetch.
     */
    where?: campaign_translationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_translations to fetch.
     */
    orderBy?: campaign_translationsOrderByWithRelationInput | campaign_translationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaign_translations.
     */
    cursor?: campaign_translationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_translations.
     */
    skip?: number
    distinct?: Campaign_translationsScalarFieldEnum | Campaign_translationsScalarFieldEnum[]
  }

  /**
   * campaign_translations create
   */
  export type campaign_translationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    /**
     * The data needed to create a campaign_translations.
     */
    data: XOR<campaign_translationsCreateInput, campaign_translationsUncheckedCreateInput>
  }

  /**
   * campaign_translations createMany
   */
  export type campaign_translationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaign_translations.
     */
    data: campaign_translationsCreateManyInput | campaign_translationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campaign_translations createManyAndReturn
   */
  export type campaign_translationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many campaign_translations.
     */
    data: campaign_translationsCreateManyInput | campaign_translationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * campaign_translations update
   */
  export type campaign_translationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    /**
     * The data needed to update a campaign_translations.
     */
    data: XOR<campaign_translationsUpdateInput, campaign_translationsUncheckedUpdateInput>
    /**
     * Choose, which campaign_translations to update.
     */
    where: campaign_translationsWhereUniqueInput
  }

  /**
   * campaign_translations updateMany
   */
  export type campaign_translationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaign_translations.
     */
    data: XOR<campaign_translationsUpdateManyMutationInput, campaign_translationsUncheckedUpdateManyInput>
    /**
     * Filter which campaign_translations to update
     */
    where?: campaign_translationsWhereInput
  }

  /**
   * campaign_translations upsert
   */
  export type campaign_translationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    /**
     * The filter to search for the campaign_translations to update in case it exists.
     */
    where: campaign_translationsWhereUniqueInput
    /**
     * In case the campaign_translations found by the `where` argument doesn't exist, create a new campaign_translations with this data.
     */
    create: XOR<campaign_translationsCreateInput, campaign_translationsUncheckedCreateInput>
    /**
     * In case the campaign_translations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaign_translationsUpdateInput, campaign_translationsUncheckedUpdateInput>
  }

  /**
   * campaign_translations delete
   */
  export type campaign_translationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    /**
     * Filter which campaign_translations to delete.
     */
    where: campaign_translationsWhereUniqueInput
  }

  /**
   * campaign_translations deleteMany
   */
  export type campaign_translationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_translations to delete
     */
    where?: campaign_translationsWhereInput
  }

  /**
   * campaign_translations without action
   */
  export type campaign_translationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
  }


  /**
   * Model campaign_usage_logs
   */

  export type AggregateCampaign_usage_logs = {
    _count: Campaign_usage_logsCountAggregateOutputType | null
    _min: Campaign_usage_logsMinAggregateOutputType | null
    _max: Campaign_usage_logsMaxAggregateOutputType | null
  }

  export type Campaign_usage_logsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    deviceId: string | null
    action: string | null
    createdAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_usage_logsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    deviceId: string | null
    action: string | null
    createdAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Campaign_usage_logsCountAggregateOutputType = {
    id: number
    campaignId: number
    userId: number
    deviceId: number
    action: number
    createdAt: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Campaign_usage_logsMinAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    deviceId?: true
    action?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_usage_logsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    deviceId?: true
    action?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Campaign_usage_logsCountAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    deviceId?: true
    action?: true
    createdAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Campaign_usage_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_usage_logs to aggregate.
     */
    where?: campaign_usage_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_usage_logs to fetch.
     */
    orderBy?: campaign_usage_logsOrderByWithRelationInput | campaign_usage_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaign_usage_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_usage_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_usage_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaign_usage_logs
    **/
    _count?: true | Campaign_usage_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Campaign_usage_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Campaign_usage_logsMaxAggregateInputType
  }

  export type GetCampaign_usage_logsAggregateType<T extends Campaign_usage_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign_usage_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign_usage_logs[P]>
      : GetScalarType<T[P], AggregateCampaign_usage_logs[P]>
  }




  export type campaign_usage_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaign_usage_logsWhereInput
    orderBy?: campaign_usage_logsOrderByWithAggregationInput | campaign_usage_logsOrderByWithAggregationInput[]
    by: Campaign_usage_logsScalarFieldEnum[] | Campaign_usage_logsScalarFieldEnum
    having?: campaign_usage_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Campaign_usage_logsCountAggregateInputType | true
    _min?: Campaign_usage_logsMinAggregateInputType
    _max?: Campaign_usage_logsMaxAggregateInputType
  }

  export type Campaign_usage_logsGroupByOutputType = {
    id: string
    campaignId: string
    userId: string | null
    deviceId: string | null
    action: string
    createdAt: Date
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Campaign_usage_logsCountAggregateOutputType | null
    _min: Campaign_usage_logsMinAggregateOutputType | null
    _max: Campaign_usage_logsMaxAggregateOutputType | null
  }

  type GetCampaign_usage_logsGroupByPayload<T extends campaign_usage_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Campaign_usage_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Campaign_usage_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Campaign_usage_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Campaign_usage_logsGroupByOutputType[P]>
        }
      >
    >


  export type campaign_usage_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    deviceId?: boolean
    action?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign_usage_logs"]>

  export type campaign_usage_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    deviceId?: boolean
    action?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign_usage_logs"]>

  export type campaign_usage_logsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    deviceId?: boolean
    action?: boolean
    createdAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type campaign_usage_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }
  export type campaign_usage_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | campaignsDefaultArgs<ExtArgs>
  }

  export type $campaign_usage_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaign_usage_logs"
    objects: {
      campaigns: Prisma.$campaignsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      userId: string | null
      deviceId: string | null
      action: string
      createdAt: Date
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["campaign_usage_logs"]>
    composites: {}
  }

  type campaign_usage_logsGetPayload<S extends boolean | null | undefined | campaign_usage_logsDefaultArgs> = $Result.GetResult<Prisma.$campaign_usage_logsPayload, S>

  type campaign_usage_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<campaign_usage_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Campaign_usage_logsCountAggregateInputType | true
    }

  export interface campaign_usage_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaign_usage_logs'], meta: { name: 'campaign_usage_logs' } }
    /**
     * Find zero or one Campaign_usage_logs that matches the filter.
     * @param {campaign_usage_logsFindUniqueArgs} args - Arguments to find a Campaign_usage_logs
     * @example
     * // Get one Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaign_usage_logsFindUniqueArgs>(args: SelectSubset<T, campaign_usage_logsFindUniqueArgs<ExtArgs>>): Prisma__campaign_usage_logsClient<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign_usage_logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {campaign_usage_logsFindUniqueOrThrowArgs} args - Arguments to find a Campaign_usage_logs
     * @example
     * // Get one Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaign_usage_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, campaign_usage_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaign_usage_logsClient<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign_usage_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_usage_logsFindFirstArgs} args - Arguments to find a Campaign_usage_logs
     * @example
     * // Get one Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaign_usage_logsFindFirstArgs>(args?: SelectSubset<T, campaign_usage_logsFindFirstArgs<ExtArgs>>): Prisma__campaign_usage_logsClient<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign_usage_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_usage_logsFindFirstOrThrowArgs} args - Arguments to find a Campaign_usage_logs
     * @example
     * // Get one Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaign_usage_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, campaign_usage_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaign_usage_logsClient<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaign_usage_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_usage_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.findMany()
     * 
     * // Get first 10 Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaign_usage_logsWithIdOnly = await prisma.campaign_usage_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaign_usage_logsFindManyArgs>(args?: SelectSubset<T, campaign_usage_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign_usage_logs.
     * @param {campaign_usage_logsCreateArgs} args - Arguments to create a Campaign_usage_logs.
     * @example
     * // Create one Campaign_usage_logs
     * const Campaign_usage_logs = await prisma.campaign_usage_logs.create({
     *   data: {
     *     // ... data to create a Campaign_usage_logs
     *   }
     * })
     * 
     */
    create<T extends campaign_usage_logsCreateArgs>(args: SelectSubset<T, campaign_usage_logsCreateArgs<ExtArgs>>): Prisma__campaign_usage_logsClient<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaign_usage_logs.
     * @param {campaign_usage_logsCreateManyArgs} args - Arguments to create many Campaign_usage_logs.
     * @example
     * // Create many Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaign_usage_logsCreateManyArgs>(args?: SelectSubset<T, campaign_usage_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaign_usage_logs and returns the data saved in the database.
     * @param {campaign_usage_logsCreateManyAndReturnArgs} args - Arguments to create many Campaign_usage_logs.
     * @example
     * // Create many Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaign_usage_logs and only return the `id`
     * const campaign_usage_logsWithIdOnly = await prisma.campaign_usage_logs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaign_usage_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, campaign_usage_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign_usage_logs.
     * @param {campaign_usage_logsDeleteArgs} args - Arguments to delete one Campaign_usage_logs.
     * @example
     * // Delete one Campaign_usage_logs
     * const Campaign_usage_logs = await prisma.campaign_usage_logs.delete({
     *   where: {
     *     // ... filter to delete one Campaign_usage_logs
     *   }
     * })
     * 
     */
    delete<T extends campaign_usage_logsDeleteArgs>(args: SelectSubset<T, campaign_usage_logsDeleteArgs<ExtArgs>>): Prisma__campaign_usage_logsClient<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign_usage_logs.
     * @param {campaign_usage_logsUpdateArgs} args - Arguments to update one Campaign_usage_logs.
     * @example
     * // Update one Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaign_usage_logsUpdateArgs>(args: SelectSubset<T, campaign_usage_logsUpdateArgs<ExtArgs>>): Prisma__campaign_usage_logsClient<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaign_usage_logs.
     * @param {campaign_usage_logsDeleteManyArgs} args - Arguments to filter Campaign_usage_logs to delete.
     * @example
     * // Delete a few Campaign_usage_logs
     * const { count } = await prisma.campaign_usage_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaign_usage_logsDeleteManyArgs>(args?: SelectSubset<T, campaign_usage_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaign_usage_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_usage_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaign_usage_logsUpdateManyArgs>(args: SelectSubset<T, campaign_usage_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign_usage_logs.
     * @param {campaign_usage_logsUpsertArgs} args - Arguments to update or create a Campaign_usage_logs.
     * @example
     * // Update or create a Campaign_usage_logs
     * const campaign_usage_logs = await prisma.campaign_usage_logs.upsert({
     *   create: {
     *     // ... data to create a Campaign_usage_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign_usage_logs we want to update
     *   }
     * })
     */
    upsert<T extends campaign_usage_logsUpsertArgs>(args: SelectSubset<T, campaign_usage_logsUpsertArgs<ExtArgs>>): Prisma__campaign_usage_logsClient<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaign_usage_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_usage_logsCountArgs} args - Arguments to filter Campaign_usage_logs to count.
     * @example
     * // Count the number of Campaign_usage_logs
     * const count = await prisma.campaign_usage_logs.count({
     *   where: {
     *     // ... the filter for the Campaign_usage_logs we want to count
     *   }
     * })
    **/
    count<T extends campaign_usage_logsCountArgs>(
      args?: Subset<T, campaign_usage_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Campaign_usage_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign_usage_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_usage_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Campaign_usage_logsAggregateArgs>(args: Subset<T, Campaign_usage_logsAggregateArgs>): Prisma.PrismaPromise<GetCampaign_usage_logsAggregateType<T>>

    /**
     * Group by Campaign_usage_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaign_usage_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaign_usage_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaign_usage_logsGroupByArgs['orderBy'] }
        : { orderBy?: campaign_usage_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaign_usage_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaign_usage_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaign_usage_logs model
   */
  readonly fields: campaign_usage_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaign_usage_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaign_usage_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends campaignsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, campaignsDefaultArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaign_usage_logs model
   */ 
  interface campaign_usage_logsFieldRefs {
    readonly id: FieldRef<"campaign_usage_logs", 'String'>
    readonly campaignId: FieldRef<"campaign_usage_logs", 'String'>
    readonly userId: FieldRef<"campaign_usage_logs", 'String'>
    readonly deviceId: FieldRef<"campaign_usage_logs", 'String'>
    readonly action: FieldRef<"campaign_usage_logs", 'String'>
    readonly createdAt: FieldRef<"campaign_usage_logs", 'DateTime'>
    readonly deleted_at: FieldRef<"campaign_usage_logs", 'DateTime'>
    readonly deleted_by: FieldRef<"campaign_usage_logs", 'String'>
    readonly is_deleted: FieldRef<"campaign_usage_logs", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * campaign_usage_logs findUnique
   */
  export type campaign_usage_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_usage_logs to fetch.
     */
    where: campaign_usage_logsWhereUniqueInput
  }

  /**
   * campaign_usage_logs findUniqueOrThrow
   */
  export type campaign_usage_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_usage_logs to fetch.
     */
    where: campaign_usage_logsWhereUniqueInput
  }

  /**
   * campaign_usage_logs findFirst
   */
  export type campaign_usage_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_usage_logs to fetch.
     */
    where?: campaign_usage_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_usage_logs to fetch.
     */
    orderBy?: campaign_usage_logsOrderByWithRelationInput | campaign_usage_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_usage_logs.
     */
    cursor?: campaign_usage_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_usage_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_usage_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_usage_logs.
     */
    distinct?: Campaign_usage_logsScalarFieldEnum | Campaign_usage_logsScalarFieldEnum[]
  }

  /**
   * campaign_usage_logs findFirstOrThrow
   */
  export type campaign_usage_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_usage_logs to fetch.
     */
    where?: campaign_usage_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_usage_logs to fetch.
     */
    orderBy?: campaign_usage_logsOrderByWithRelationInput | campaign_usage_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaign_usage_logs.
     */
    cursor?: campaign_usage_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_usage_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_usage_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaign_usage_logs.
     */
    distinct?: Campaign_usage_logsScalarFieldEnum | Campaign_usage_logsScalarFieldEnum[]
  }

  /**
   * campaign_usage_logs findMany
   */
  export type campaign_usage_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    /**
     * Filter, which campaign_usage_logs to fetch.
     */
    where?: campaign_usage_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaign_usage_logs to fetch.
     */
    orderBy?: campaign_usage_logsOrderByWithRelationInput | campaign_usage_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaign_usage_logs.
     */
    cursor?: campaign_usage_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaign_usage_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaign_usage_logs.
     */
    skip?: number
    distinct?: Campaign_usage_logsScalarFieldEnum | Campaign_usage_logsScalarFieldEnum[]
  }

  /**
   * campaign_usage_logs create
   */
  export type campaign_usage_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a campaign_usage_logs.
     */
    data: XOR<campaign_usage_logsCreateInput, campaign_usage_logsUncheckedCreateInput>
  }

  /**
   * campaign_usage_logs createMany
   */
  export type campaign_usage_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaign_usage_logs.
     */
    data: campaign_usage_logsCreateManyInput | campaign_usage_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campaign_usage_logs createManyAndReturn
   */
  export type campaign_usage_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many campaign_usage_logs.
     */
    data: campaign_usage_logsCreateManyInput | campaign_usage_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * campaign_usage_logs update
   */
  export type campaign_usage_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a campaign_usage_logs.
     */
    data: XOR<campaign_usage_logsUpdateInput, campaign_usage_logsUncheckedUpdateInput>
    /**
     * Choose, which campaign_usage_logs to update.
     */
    where: campaign_usage_logsWhereUniqueInput
  }

  /**
   * campaign_usage_logs updateMany
   */
  export type campaign_usage_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaign_usage_logs.
     */
    data: XOR<campaign_usage_logsUpdateManyMutationInput, campaign_usage_logsUncheckedUpdateManyInput>
    /**
     * Filter which campaign_usage_logs to update
     */
    where?: campaign_usage_logsWhereInput
  }

  /**
   * campaign_usage_logs upsert
   */
  export type campaign_usage_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the campaign_usage_logs to update in case it exists.
     */
    where: campaign_usage_logsWhereUniqueInput
    /**
     * In case the campaign_usage_logs found by the `where` argument doesn't exist, create a new campaign_usage_logs with this data.
     */
    create: XOR<campaign_usage_logsCreateInput, campaign_usage_logsUncheckedCreateInput>
    /**
     * In case the campaign_usage_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaign_usage_logsUpdateInput, campaign_usage_logsUncheckedUpdateInput>
  }

  /**
   * campaign_usage_logs delete
   */
  export type campaign_usage_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    /**
     * Filter which campaign_usage_logs to delete.
     */
    where: campaign_usage_logsWhereUniqueInput
  }

  /**
   * campaign_usage_logs deleteMany
   */
  export type campaign_usage_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaign_usage_logs to delete
     */
    where?: campaign_usage_logsWhereInput
  }

  /**
   * campaign_usage_logs without action
   */
  export type campaign_usage_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
  }


  /**
   * Model campaigns
   */

  export type AggregateCampaigns = {
    _count: CampaignsCountAggregateOutputType | null
    _avg: CampaignsAvgAggregateOutputType | null
    _sum: CampaignsSumAggregateOutputType | null
    _min: CampaignsMinAggregateOutputType | null
    _max: CampaignsMaxAggregateOutputType | null
  }

  export type CampaignsAvgAggregateOutputType = {
    priority: number | null
    discountValue: Decimal | null
    displayPriority: number | null
    maxUsageCount: number | null
  }

  export type CampaignsSumAggregateOutputType = {
    priority: number | null
    discountValue: Decimal | null
    displayPriority: number | null
    maxUsageCount: number | null
  }

  export type CampaignsMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    status: $Enums.CampaignStatus | null
    displayType: $Enums.CampaignDisplayType | null
    startDate: Date | null
    endDate: Date | null
    priority: number | null
    ctaType: $Enums.CampaignCtaType | null
    ctaAction: string | null
    ctaLabel: string | null
    discountType: string | null
    discountValue: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    displayPriority: number | null
    maxUsageCount: number | null
    name: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type CampaignsMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    status: $Enums.CampaignStatus | null
    displayType: $Enums.CampaignDisplayType | null
    startDate: Date | null
    endDate: Date | null
    priority: number | null
    ctaType: $Enums.CampaignCtaType | null
    ctaAction: string | null
    ctaLabel: string | null
    discountType: string | null
    discountValue: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    displayPriority: number | null
    maxUsageCount: number | null
    name: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type CampaignsCountAggregateOutputType = {
    id: number
    tenantId: number
    code: number
    status: number
    displayType: number
    startDate: number
    endDate: number
    priority: number
    ctaType: number
    ctaAction: number
    ctaLabel: number
    discountType: number
    discountValue: number
    createdAt: number
    updatedAt: number
    dayRestrictions: number
    description: number
    displayPriority: number
    maxUsageCount: number
    name: number
    timeRestrictions: number
    welcomeSettings: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type CampaignsAvgAggregateInputType = {
    priority?: true
    discountValue?: true
    displayPriority?: true
    maxUsageCount?: true
  }

  export type CampaignsSumAggregateInputType = {
    priority?: true
    discountValue?: true
    displayPriority?: true
    maxUsageCount?: true
  }

  export type CampaignsMinAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    status?: true
    displayType?: true
    startDate?: true
    endDate?: true
    priority?: true
    ctaType?: true
    ctaAction?: true
    ctaLabel?: true
    discountType?: true
    discountValue?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    displayPriority?: true
    maxUsageCount?: true
    name?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type CampaignsMaxAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    status?: true
    displayType?: true
    startDate?: true
    endDate?: true
    priority?: true
    ctaType?: true
    ctaAction?: true
    ctaLabel?: true
    discountType?: true
    discountValue?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    displayPriority?: true
    maxUsageCount?: true
    name?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type CampaignsCountAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    status?: true
    displayType?: true
    startDate?: true
    endDate?: true
    priority?: true
    ctaType?: true
    ctaAction?: true
    ctaLabel?: true
    discountType?: true
    discountValue?: true
    createdAt?: true
    updatedAt?: true
    dayRestrictions?: true
    description?: true
    displayPriority?: true
    maxUsageCount?: true
    name?: true
    timeRestrictions?: true
    welcomeSettings?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type CampaignsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaigns to aggregate.
     */
    where?: campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignsOrderByWithRelationInput | campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaigns
    **/
    _count?: true | CampaignsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignsMaxAggregateInputType
  }

  export type GetCampaignsAggregateType<T extends CampaignsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaigns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaigns[P]>
      : GetScalarType<T[P], AggregateCampaigns[P]>
  }




  export type campaignsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignsWhereInput
    orderBy?: campaignsOrderByWithAggregationInput | campaignsOrderByWithAggregationInput[]
    by: CampaignsScalarFieldEnum[] | CampaignsScalarFieldEnum
    having?: campaignsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignsCountAggregateInputType | true
    _avg?: CampaignsAvgAggregateInputType
    _sum?: CampaignsSumAggregateInputType
    _min?: CampaignsMinAggregateInputType
    _max?: CampaignsMaxAggregateInputType
  }

  export type CampaignsGroupByOutputType = {
    id: string
    tenantId: string
    code: string
    status: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate: Date | null
    endDate: Date | null
    priority: number
    ctaType: $Enums.CampaignCtaType
    ctaAction: string | null
    ctaLabel: string | null
    discountType: string | null
    discountValue: Decimal | null
    createdAt: Date
    updatedAt: Date
    dayRestrictions: JsonValue | null
    description: string | null
    displayPriority: number
    maxUsageCount: number | null
    name: string
    timeRestrictions: JsonValue | null
    welcomeSettings: JsonValue | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: CampaignsCountAggregateOutputType | null
    _avg: CampaignsAvgAggregateOutputType | null
    _sum: CampaignsSumAggregateOutputType | null
    _min: CampaignsMinAggregateOutputType | null
    _max: CampaignsMaxAggregateOutputType | null
  }

  type GetCampaignsGroupByPayload<T extends campaignsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignsGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignsGroupByOutputType[P]>
        }
      >
    >


  export type campaignsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    status?: boolean
    displayType?: boolean
    startDate?: boolean
    endDate?: boolean
    priority?: boolean
    ctaType?: boolean
    ctaAction?: boolean
    ctaLabel?: boolean
    discountType?: boolean
    discountValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayRestrictions?: boolean
    description?: boolean
    displayPriority?: boolean
    maxUsageCount?: boolean
    name?: boolean
    timeRestrictions?: boolean
    welcomeSettings?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    campaign_category_relations?: boolean | campaigns$campaign_category_relationsArgs<ExtArgs>
    campaign_items?: boolean | campaigns$campaign_itemsArgs<ExtArgs>
    campaign_translations?: boolean | campaigns$campaign_translationsArgs<ExtArgs>
    campaign_usage_logs?: boolean | campaigns$campaign_usage_logsArgs<ExtArgs>
    _count?: boolean | CampaignsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaigns"]>

  export type campaignsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    status?: boolean
    displayType?: boolean
    startDate?: boolean
    endDate?: boolean
    priority?: boolean
    ctaType?: boolean
    ctaAction?: boolean
    ctaLabel?: boolean
    discountType?: boolean
    discountValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayRestrictions?: boolean
    description?: boolean
    displayPriority?: boolean
    maxUsageCount?: boolean
    name?: boolean
    timeRestrictions?: boolean
    welcomeSettings?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["campaigns"]>

  export type campaignsSelectScalar = {
    id?: boolean
    tenantId?: boolean
    code?: boolean
    status?: boolean
    displayType?: boolean
    startDate?: boolean
    endDate?: boolean
    priority?: boolean
    ctaType?: boolean
    ctaAction?: boolean
    ctaLabel?: boolean
    discountType?: boolean
    discountValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dayRestrictions?: boolean
    description?: boolean
    displayPriority?: boolean
    maxUsageCount?: boolean
    name?: boolean
    timeRestrictions?: boolean
    welcomeSettings?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type campaignsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign_category_relations?: boolean | campaigns$campaign_category_relationsArgs<ExtArgs>
    campaign_items?: boolean | campaigns$campaign_itemsArgs<ExtArgs>
    campaign_translations?: boolean | campaigns$campaign_translationsArgs<ExtArgs>
    campaign_usage_logs?: boolean | campaigns$campaign_usage_logsArgs<ExtArgs>
    _count?: boolean | CampaignsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type campaignsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $campaignsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaigns"
    objects: {
      campaign_category_relations: Prisma.$campaign_category_relationsPayload<ExtArgs>[]
      campaign_items: Prisma.$campaign_itemsPayload<ExtArgs>[]
      campaign_translations: Prisma.$campaign_translationsPayload<ExtArgs>[]
      campaign_usage_logs: Prisma.$campaign_usage_logsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      code: string
      status: $Enums.CampaignStatus
      displayType: $Enums.CampaignDisplayType
      startDate: Date | null
      endDate: Date | null
      priority: number
      ctaType: $Enums.CampaignCtaType
      ctaAction: string | null
      ctaLabel: string | null
      discountType: string | null
      discountValue: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
      dayRestrictions: Prisma.JsonValue | null
      description: string | null
      displayPriority: number
      maxUsageCount: number | null
      name: string
      timeRestrictions: Prisma.JsonValue | null
      welcomeSettings: Prisma.JsonValue | null
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["campaigns"]>
    composites: {}
  }

  type campaignsGetPayload<S extends boolean | null | undefined | campaignsDefaultArgs> = $Result.GetResult<Prisma.$campaignsPayload, S>

  type campaignsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<campaignsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignsCountAggregateInputType | true
    }

  export interface campaignsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaigns'], meta: { name: 'campaigns' } }
    /**
     * Find zero or one Campaigns that matches the filter.
     * @param {campaignsFindUniqueArgs} args - Arguments to find a Campaigns
     * @example
     * // Get one Campaigns
     * const campaigns = await prisma.campaigns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaignsFindUniqueArgs>(args: SelectSubset<T, campaignsFindUniqueArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaigns that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {campaignsFindUniqueOrThrowArgs} args - Arguments to find a Campaigns
     * @example
     * // Get one Campaigns
     * const campaigns = await prisma.campaigns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaignsFindUniqueOrThrowArgs>(args: SelectSubset<T, campaignsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsFindFirstArgs} args - Arguments to find a Campaigns
     * @example
     * // Get one Campaigns
     * const campaigns = await prisma.campaigns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaignsFindFirstArgs>(args?: SelectSubset<T, campaignsFindFirstArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaigns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsFindFirstOrThrowArgs} args - Arguments to find a Campaigns
     * @example
     * // Get one Campaigns
     * const campaigns = await prisma.campaigns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaignsFindFirstOrThrowArgs>(args?: SelectSubset<T, campaignsFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaigns.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaigns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignsWithIdOnly = await prisma.campaigns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaignsFindManyArgs>(args?: SelectSubset<T, campaignsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaigns.
     * @param {campaignsCreateArgs} args - Arguments to create a Campaigns.
     * @example
     * // Create one Campaigns
     * const Campaigns = await prisma.campaigns.create({
     *   data: {
     *     // ... data to create a Campaigns
     *   }
     * })
     * 
     */
    create<T extends campaignsCreateArgs>(args: SelectSubset<T, campaignsCreateArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {campaignsCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaigns = await prisma.campaigns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaignsCreateManyArgs>(args?: SelectSubset<T, campaignsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {campaignsCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaigns = await prisma.campaigns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignsWithIdOnly = await prisma.campaigns.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaignsCreateManyAndReturnArgs>(args?: SelectSubset<T, campaignsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaigns.
     * @param {campaignsDeleteArgs} args - Arguments to delete one Campaigns.
     * @example
     * // Delete one Campaigns
     * const Campaigns = await prisma.campaigns.delete({
     *   where: {
     *     // ... filter to delete one Campaigns
     *   }
     * })
     * 
     */
    delete<T extends campaignsDeleteArgs>(args: SelectSubset<T, campaignsDeleteArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaigns.
     * @param {campaignsUpdateArgs} args - Arguments to update one Campaigns.
     * @example
     * // Update one Campaigns
     * const campaigns = await prisma.campaigns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaignsUpdateArgs>(args: SelectSubset<T, campaignsUpdateArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {campaignsDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaigns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaignsDeleteManyArgs>(args?: SelectSubset<T, campaignsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaigns = await prisma.campaigns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaignsUpdateManyArgs>(args: SelectSubset<T, campaignsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaigns.
     * @param {campaignsUpsertArgs} args - Arguments to update or create a Campaigns.
     * @example
     * // Update or create a Campaigns
     * const campaigns = await prisma.campaigns.upsert({
     *   create: {
     *     // ... data to create a Campaigns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaigns we want to update
     *   }
     * })
     */
    upsert<T extends campaignsUpsertArgs>(args: SelectSubset<T, campaignsUpsertArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaigns.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends campaignsCountArgs>(
      args?: Subset<T, campaignsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignsAggregateArgs>(args: Subset<T, CampaignsAggregateArgs>): Prisma.PrismaPromise<GetCampaignsAggregateType<T>>

    /**
     * Group by Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaignsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaignsGroupByArgs['orderBy'] }
        : { orderBy?: campaignsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaignsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaigns model
   */
  readonly fields: campaignsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaigns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaignsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign_category_relations<T extends campaigns$campaign_category_relationsArgs<ExtArgs> = {}>(args?: Subset<T, campaigns$campaign_category_relationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_category_relationsPayload<ExtArgs>, T, "findMany"> | Null>
    campaign_items<T extends campaigns$campaign_itemsArgs<ExtArgs> = {}>(args?: Subset<T, campaigns$campaign_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_itemsPayload<ExtArgs>, T, "findMany"> | Null>
    campaign_translations<T extends campaigns$campaign_translationsArgs<ExtArgs> = {}>(args?: Subset<T, campaigns$campaign_translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_translationsPayload<ExtArgs>, T, "findMany"> | Null>
    campaign_usage_logs<T extends campaigns$campaign_usage_logsArgs<ExtArgs> = {}>(args?: Subset<T, campaigns$campaign_usage_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaign_usage_logsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaigns model
   */ 
  interface campaignsFieldRefs {
    readonly id: FieldRef<"campaigns", 'String'>
    readonly tenantId: FieldRef<"campaigns", 'String'>
    readonly code: FieldRef<"campaigns", 'String'>
    readonly status: FieldRef<"campaigns", 'CampaignStatus'>
    readonly displayType: FieldRef<"campaigns", 'CampaignDisplayType'>
    readonly startDate: FieldRef<"campaigns", 'DateTime'>
    readonly endDate: FieldRef<"campaigns", 'DateTime'>
    readonly priority: FieldRef<"campaigns", 'Int'>
    readonly ctaType: FieldRef<"campaigns", 'CampaignCtaType'>
    readonly ctaAction: FieldRef<"campaigns", 'String'>
    readonly ctaLabel: FieldRef<"campaigns", 'String'>
    readonly discountType: FieldRef<"campaigns", 'String'>
    readonly discountValue: FieldRef<"campaigns", 'Decimal'>
    readonly createdAt: FieldRef<"campaigns", 'DateTime'>
    readonly updatedAt: FieldRef<"campaigns", 'DateTime'>
    readonly dayRestrictions: FieldRef<"campaigns", 'Json'>
    readonly description: FieldRef<"campaigns", 'String'>
    readonly displayPriority: FieldRef<"campaigns", 'Int'>
    readonly maxUsageCount: FieldRef<"campaigns", 'Int'>
    readonly name: FieldRef<"campaigns", 'String'>
    readonly timeRestrictions: FieldRef<"campaigns", 'Json'>
    readonly welcomeSettings: FieldRef<"campaigns", 'Json'>
    readonly deleted_at: FieldRef<"campaigns", 'DateTime'>
    readonly deleted_by: FieldRef<"campaigns", 'String'>
    readonly is_deleted: FieldRef<"campaigns", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * campaigns findUnique
   */
  export type campaignsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where: campaignsWhereUniqueInput
  }

  /**
   * campaigns findUniqueOrThrow
   */
  export type campaignsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where: campaignsWhereUniqueInput
  }

  /**
   * campaigns findFirst
   */
  export type campaignsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where?: campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignsOrderByWithRelationInput | campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaigns.
     */
    cursor?: campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaigns.
     */
    distinct?: CampaignsScalarFieldEnum | CampaignsScalarFieldEnum[]
  }

  /**
   * campaigns findFirstOrThrow
   */
  export type campaignsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where?: campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignsOrderByWithRelationInput | campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaigns.
     */
    cursor?: campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaigns.
     */
    distinct?: CampaignsScalarFieldEnum | CampaignsScalarFieldEnum[]
  }

  /**
   * campaigns findMany
   */
  export type campaignsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where?: campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignsOrderByWithRelationInput | campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaigns.
     */
    cursor?: campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    distinct?: CampaignsScalarFieldEnum | CampaignsScalarFieldEnum[]
  }

  /**
   * campaigns create
   */
  export type campaignsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * The data needed to create a campaigns.
     */
    data: XOR<campaignsCreateInput, campaignsUncheckedCreateInput>
  }

  /**
   * campaigns createMany
   */
  export type campaignsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaigns.
     */
    data: campaignsCreateManyInput | campaignsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campaigns createManyAndReturn
   */
  export type campaignsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many campaigns.
     */
    data: campaignsCreateManyInput | campaignsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campaigns update
   */
  export type campaignsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * The data needed to update a campaigns.
     */
    data: XOR<campaignsUpdateInput, campaignsUncheckedUpdateInput>
    /**
     * Choose, which campaigns to update.
     */
    where: campaignsWhereUniqueInput
  }

  /**
   * campaigns updateMany
   */
  export type campaignsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaigns.
     */
    data: XOR<campaignsUpdateManyMutationInput, campaignsUncheckedUpdateManyInput>
    /**
     * Filter which campaigns to update
     */
    where?: campaignsWhereInput
  }

  /**
   * campaigns upsert
   */
  export type campaignsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * The filter to search for the campaigns to update in case it exists.
     */
    where: campaignsWhereUniqueInput
    /**
     * In case the campaigns found by the `where` argument doesn't exist, create a new campaigns with this data.
     */
    create: XOR<campaignsCreateInput, campaignsUncheckedCreateInput>
    /**
     * In case the campaigns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaignsUpdateInput, campaignsUncheckedUpdateInput>
  }

  /**
   * campaigns delete
   */
  export type campaignsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter which campaigns to delete.
     */
    where: campaignsWhereUniqueInput
  }

  /**
   * campaigns deleteMany
   */
  export type campaignsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaigns to delete
     */
    where?: campaignsWhereInput
  }

  /**
   * campaigns.campaign_category_relations
   */
  export type campaigns$campaign_category_relationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_category_relations
     */
    select?: campaign_category_relationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_category_relationsInclude<ExtArgs> | null
    where?: campaign_category_relationsWhereInput
    orderBy?: campaign_category_relationsOrderByWithRelationInput | campaign_category_relationsOrderByWithRelationInput[]
    cursor?: campaign_category_relationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Campaign_category_relationsScalarFieldEnum | Campaign_category_relationsScalarFieldEnum[]
  }

  /**
   * campaigns.campaign_items
   */
  export type campaigns$campaign_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_items
     */
    select?: campaign_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_itemsInclude<ExtArgs> | null
    where?: campaign_itemsWhereInput
    orderBy?: campaign_itemsOrderByWithRelationInput | campaign_itemsOrderByWithRelationInput[]
    cursor?: campaign_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Campaign_itemsScalarFieldEnum | Campaign_itemsScalarFieldEnum[]
  }

  /**
   * campaigns.campaign_translations
   */
  export type campaigns$campaign_translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_translations
     */
    select?: campaign_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_translationsInclude<ExtArgs> | null
    where?: campaign_translationsWhereInput
    orderBy?: campaign_translationsOrderByWithRelationInput | campaign_translationsOrderByWithRelationInput[]
    cursor?: campaign_translationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Campaign_translationsScalarFieldEnum | Campaign_translationsScalarFieldEnum[]
  }

  /**
   * campaigns.campaign_usage_logs
   */
  export type campaigns$campaign_usage_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaign_usage_logs
     */
    select?: campaign_usage_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaign_usage_logsInclude<ExtArgs> | null
    where?: campaign_usage_logsWhereInput
    orderBy?: campaign_usage_logsOrderByWithRelationInput | campaign_usage_logsOrderByWithRelationInput[]
    cursor?: campaign_usage_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Campaign_usage_logsScalarFieldEnum | Campaign_usage_logsScalarFieldEnum[]
  }

  /**
   * campaigns without action
   */
  export type campaignsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
  }


  /**
   * Model customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    total_points: number | null
    total_stays: number | null
  }

  export type CustomersSumAggregateOutputType = {
    total_points: number | null
    total_stays: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    birth_date: Date | null
    member_id: string | null
    rank_id: string | null
    total_points: number | null
    total_stays: number | null
    origin_system: string | null
    synced_at: Date | null
    updated_by_system: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    is_deleted: boolean | null
    deleted_by: string | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    birth_date: Date | null
    member_id: string | null
    rank_id: string | null
    total_points: number | null
    total_stays: number | null
    origin_system: string | null
    synced_at: Date | null
    updated_by_system: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    is_deleted: boolean | null
    deleted_by: string | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    tenant_id: number
    name: number
    email: number
    phone: number
    address: number
    birth_date: number
    member_id: number
    rank_id: number
    total_points: number
    total_stays: number
    pms_updatable_fields: number
    origin_system: number
    synced_at: number
    updated_by_system: number
    preferences: number
    created_at: number
    updated_at: number
    deleted_at: number
    is_deleted: number
    deleted_by: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    total_points?: true
    total_stays?: true
  }

  export type CustomersSumAggregateInputType = {
    total_points?: true
    total_stays?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    tenant_id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    birth_date?: true
    member_id?: true
    rank_id?: true
    total_points?: true
    total_stays?: true
    origin_system?: true
    synced_at?: true
    updated_by_system?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    is_deleted?: true
    deleted_by?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    birth_date?: true
    member_id?: true
    rank_id?: true
    total_points?: true
    total_stays?: true
    origin_system?: true
    synced_at?: true
    updated_by_system?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    is_deleted?: true
    deleted_by?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    tenant_id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    birth_date?: true
    member_id?: true
    rank_id?: true
    total_points?: true
    total_stays?: true
    pms_updatable_fields?: true
    origin_system?: true
    synced_at?: true
    updated_by_system?: true
    preferences?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    is_deleted?: true
    deleted_by?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to aggregate.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type customersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput
    orderBy?: customersOrderByWithAggregationInput | customersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: customersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: string
    tenant_id: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    birth_date: Date | null
    member_id: string | null
    rank_id: string | null
    total_points: number
    total_stays: number
    pms_updatable_fields: string[]
    origin_system: string
    synced_at: Date
    updated_by_system: string
    preferences: JsonValue
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    is_deleted: boolean
    deleted_by: string | null
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends customersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type customersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birth_date?: boolean
    member_id?: boolean
    rank_id?: boolean
    total_points?: boolean
    total_stays?: boolean
    pms_updatable_fields?: boolean
    origin_system?: boolean
    synced_at?: boolean
    updated_by_system?: boolean
    preferences?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    deleted_by?: boolean
    reservations?: boolean | customers$reservationsArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type customersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birth_date?: boolean
    member_id?: boolean
    rank_id?: boolean
    total_points?: boolean
    total_stays?: boolean
    pms_updatable_fields?: boolean
    origin_system?: boolean
    synced_at?: boolean
    updated_by_system?: boolean
    preferences?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    deleted_by?: boolean
  }, ExtArgs["result"]["customers"]>

  export type customersSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    birth_date?: boolean
    member_id?: boolean
    rank_id?: boolean
    total_points?: boolean
    total_stays?: boolean
    pms_updatable_fields?: boolean
    origin_system?: boolean
    synced_at?: boolean
    updated_by_system?: boolean
    preferences?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    deleted_by?: boolean
  }

  export type customersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | customers$reservationsArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $customersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customers"
    objects: {
      reservations: Prisma.$reservationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      birth_date: Date | null
      member_id: string | null
      rank_id: string | null
      total_points: number
      total_stays: number
      pms_updatable_fields: string[]
      origin_system: string
      synced_at: Date
      updated_by_system: string
      preferences: Prisma.JsonValue
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      is_deleted: boolean
      deleted_by: string | null
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type customersGetPayload<S extends boolean | null | undefined | customersDefaultArgs> = $Result.GetResult<Prisma.$customersPayload, S>

  type customersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<customersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface customersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customers'], meta: { name: 'customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {customersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customersFindUniqueArgs>(args: SelectSubset<T, customersFindUniqueArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {customersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customersFindUniqueOrThrowArgs>(args: SelectSubset<T, customersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customersFindFirstArgs>(args?: SelectSubset<T, customersFindFirstArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customersFindFirstOrThrowArgs>(args?: SelectSubset<T, customersFindFirstOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customersFindManyArgs>(args?: SelectSubset<T, customersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customers.
     * @param {customersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends customersCreateArgs>(args: SelectSubset<T, customersCreateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {customersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customersCreateManyArgs>(args?: SelectSubset<T, customersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customersCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customersCreateManyAndReturnArgs>(args?: SelectSubset<T, customersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customers.
     * @param {customersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends customersDeleteArgs>(args: SelectSubset<T, customersDeleteArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customers.
     * @param {customersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customersUpdateArgs>(args: SelectSubset<T, customersUpdateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {customersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customersDeleteManyArgs>(args?: SelectSubset<T, customersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customersUpdateManyArgs>(args: SelectSubset<T, customersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {customersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends customersUpsertArgs>(args: SelectSubset<T, customersUpsertArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customersCountArgs>(
      args?: Subset<T, customersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customersGroupByArgs['orderBy'] }
        : { orderBy?: customersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customers model
   */
  readonly fields: customersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservations<T extends customers$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, customers$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customers model
   */ 
  interface customersFieldRefs {
    readonly id: FieldRef<"customers", 'String'>
    readonly tenant_id: FieldRef<"customers", 'String'>
    readonly name: FieldRef<"customers", 'String'>
    readonly email: FieldRef<"customers", 'String'>
    readonly phone: FieldRef<"customers", 'String'>
    readonly address: FieldRef<"customers", 'String'>
    readonly birth_date: FieldRef<"customers", 'DateTime'>
    readonly member_id: FieldRef<"customers", 'String'>
    readonly rank_id: FieldRef<"customers", 'String'>
    readonly total_points: FieldRef<"customers", 'Int'>
    readonly total_stays: FieldRef<"customers", 'Int'>
    readonly pms_updatable_fields: FieldRef<"customers", 'String[]'>
    readonly origin_system: FieldRef<"customers", 'String'>
    readonly synced_at: FieldRef<"customers", 'DateTime'>
    readonly updated_by_system: FieldRef<"customers", 'String'>
    readonly preferences: FieldRef<"customers", 'Json'>
    readonly created_at: FieldRef<"customers", 'DateTime'>
    readonly updated_at: FieldRef<"customers", 'DateTime'>
    readonly deleted_at: FieldRef<"customers", 'DateTime'>
    readonly is_deleted: FieldRef<"customers", 'Boolean'>
    readonly deleted_by: FieldRef<"customers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * customers findUnique
   */
  export type customersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findUniqueOrThrow
   */
  export type customersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findFirst
   */
  export type customersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findFirstOrThrow
   */
  export type customersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findMany
   */
  export type customersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers create
   */
  export type customersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to create a customers.
     */
    data: XOR<customersCreateInput, customersUncheckedCreateInput>
  }

  /**
   * customers createMany
   */
  export type customersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customers createManyAndReturn
   */
  export type customersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customers update
   */
  export type customersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to update a customers.
     */
    data: XOR<customersUpdateInput, customersUncheckedUpdateInput>
    /**
     * Choose, which customers to update.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers updateMany
   */
  export type customersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput
  }

  /**
   * customers upsert
   */
  export type customersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The filter to search for the customers to update in case it exists.
     */
    where: customersWhereUniqueInput
    /**
     * In case the customers found by the `where` argument doesn't exist, create a new customers with this data.
     */
    create: XOR<customersCreateInput, customersUncheckedCreateInput>
    /**
     * In case the customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customersUpdateInput, customersUncheckedUpdateInput>
  }

  /**
   * customers delete
   */
  export type customersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter which customers to delete.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers deleteMany
   */
  export type customersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customersWhereInput
  }

  /**
   * customers.reservations
   */
  export type customers$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    where?: reservationsWhereInput
    orderBy?: reservationsOrderByWithRelationInput | reservationsOrderByWithRelationInput[]
    cursor?: reservationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationsScalarFieldEnum | ReservationsScalarFieldEnum[]
  }

  /**
   * customers without action
   */
  export type customersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
  }


  /**
   * Model device_rooms
   */

  export type AggregateDevice_rooms = {
    _count: Device_roomsCountAggregateOutputType | null
    _avg: Device_roomsAvgAggregateOutputType | null
    _sum: Device_roomsSumAggregateOutputType | null
    _min: Device_roomsMinAggregateOutputType | null
    _max: Device_roomsMaxAggregateOutputType | null
  }

  export type Device_roomsAvgAggregateOutputType = {
    id: number | null
  }

  export type Device_roomsSumAggregateOutputType = {
    id: number | null
  }

  export type Device_roomsMinAggregateOutputType = {
    id: number | null
    tenantId: string | null
    roomId: string | null
    roomName: string | null
    deviceId: string | null
    deviceType: string | null
    placeId: string | null
    status: string | null
    ipAddress: string | null
    macAddress: string | null
    lastUsedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    deleted_by: string | null
  }

  export type Device_roomsMaxAggregateOutputType = {
    id: number | null
    tenantId: string | null
    roomId: string | null
    roomName: string | null
    deviceId: string | null
    deviceType: string | null
    placeId: string | null
    status: string | null
    ipAddress: string | null
    macAddress: string | null
    lastUsedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    is_deleted: boolean | null
    deleted_at: Date | null
    deleted_by: string | null
  }

  export type Device_roomsCountAggregateOutputType = {
    id: number
    tenantId: number
    roomId: number
    roomName: number
    deviceId: number
    deviceType: number
    placeId: number
    status: number
    ipAddress: number
    macAddress: number
    lastUsedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    is_deleted: number
    deleted_at: number
    deleted_by: number
    _all: number
  }


  export type Device_roomsAvgAggregateInputType = {
    id?: true
  }

  export type Device_roomsSumAggregateInputType = {
    id?: true
  }

  export type Device_roomsMinAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    roomName?: true
    deviceId?: true
    deviceType?: true
    placeId?: true
    status?: true
    ipAddress?: true
    macAddress?: true
    lastUsedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    is_deleted?: true
    deleted_at?: true
    deleted_by?: true
  }

  export type Device_roomsMaxAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    roomName?: true
    deviceId?: true
    deviceType?: true
    placeId?: true
    status?: true
    ipAddress?: true
    macAddress?: true
    lastUsedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    is_deleted?: true
    deleted_at?: true
    deleted_by?: true
  }

  export type Device_roomsCountAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    roomName?: true
    deviceId?: true
    deviceType?: true
    placeId?: true
    status?: true
    ipAddress?: true
    macAddress?: true
    lastUsedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    is_deleted?: true
    deleted_at?: true
    deleted_by?: true
    _all?: true
  }

  export type Device_roomsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device_rooms to aggregate.
     */
    where?: device_roomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_rooms to fetch.
     */
    orderBy?: device_roomsOrderByWithRelationInput | device_roomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: device_roomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned device_rooms
    **/
    _count?: true | Device_roomsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Device_roomsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Device_roomsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Device_roomsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Device_roomsMaxAggregateInputType
  }

  export type GetDevice_roomsAggregateType<T extends Device_roomsAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice_rooms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice_rooms[P]>
      : GetScalarType<T[P], AggregateDevice_rooms[P]>
  }




  export type device_roomsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: device_roomsWhereInput
    orderBy?: device_roomsOrderByWithAggregationInput | device_roomsOrderByWithAggregationInput[]
    by: Device_roomsScalarFieldEnum[] | Device_roomsScalarFieldEnum
    having?: device_roomsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Device_roomsCountAggregateInputType | true
    _avg?: Device_roomsAvgAggregateInputType
    _sum?: Device_roomsSumAggregateInputType
    _min?: Device_roomsMinAggregateInputType
    _max?: Device_roomsMaxAggregateInputType
  }

  export type Device_roomsGroupByOutputType = {
    id: number
    tenantId: string
    roomId: string
    roomName: string | null
    deviceId: string | null
    deviceType: string | null
    placeId: string | null
    status: string | null
    ipAddress: string | null
    macAddress: string | null
    lastUsedAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    is_deleted: boolean
    deleted_at: Date | null
    deleted_by: string | null
    _count: Device_roomsCountAggregateOutputType | null
    _avg: Device_roomsAvgAggregateOutputType | null
    _sum: Device_roomsSumAggregateOutputType | null
    _min: Device_roomsMinAggregateOutputType | null
    _max: Device_roomsMaxAggregateOutputType | null
  }

  type GetDevice_roomsGroupByPayload<T extends device_roomsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Device_roomsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Device_roomsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Device_roomsGroupByOutputType[P]>
            : GetScalarType<T[P], Device_roomsGroupByOutputType[P]>
        }
      >
    >


  export type device_roomsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    roomName?: boolean
    deviceId?: boolean
    deviceType?: boolean
    placeId?: boolean
    status?: boolean
    ipAddress?: boolean
    macAddress?: boolean
    lastUsedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device_rooms"]>

  export type device_roomsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    roomName?: boolean
    deviceId?: boolean
    deviceType?: boolean
    placeId?: boolean
    status?: boolean
    ipAddress?: boolean
    macAddress?: boolean
    lastUsedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device_rooms"]>

  export type device_roomsSelectScalar = {
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    roomName?: boolean
    deviceId?: boolean
    deviceType?: boolean
    placeId?: boolean
    status?: boolean
    ipAddress?: boolean
    macAddress?: boolean
    lastUsedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
  }

  export type device_roomsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type device_roomsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $device_roomsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "device_rooms"
    objects: {
      Tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tenantId: string
      roomId: string
      roomName: string | null
      deviceId: string | null
      deviceType: string | null
      placeId: string | null
      status: string | null
      ipAddress: string | null
      macAddress: string | null
      lastUsedAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      is_deleted: boolean
      deleted_at: Date | null
      deleted_by: string | null
    }, ExtArgs["result"]["device_rooms"]>
    composites: {}
  }

  type device_roomsGetPayload<S extends boolean | null | undefined | device_roomsDefaultArgs> = $Result.GetResult<Prisma.$device_roomsPayload, S>

  type device_roomsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<device_roomsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Device_roomsCountAggregateInputType | true
    }

  export interface device_roomsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['device_rooms'], meta: { name: 'device_rooms' } }
    /**
     * Find zero or one Device_rooms that matches the filter.
     * @param {device_roomsFindUniqueArgs} args - Arguments to find a Device_rooms
     * @example
     * // Get one Device_rooms
     * const device_rooms = await prisma.device_rooms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends device_roomsFindUniqueArgs>(args: SelectSubset<T, device_roomsFindUniqueArgs<ExtArgs>>): Prisma__device_roomsClient<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Device_rooms that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {device_roomsFindUniqueOrThrowArgs} args - Arguments to find a Device_rooms
     * @example
     * // Get one Device_rooms
     * const device_rooms = await prisma.device_rooms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends device_roomsFindUniqueOrThrowArgs>(args: SelectSubset<T, device_roomsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__device_roomsClient<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Device_rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_roomsFindFirstArgs} args - Arguments to find a Device_rooms
     * @example
     * // Get one Device_rooms
     * const device_rooms = await prisma.device_rooms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends device_roomsFindFirstArgs>(args?: SelectSubset<T, device_roomsFindFirstArgs<ExtArgs>>): Prisma__device_roomsClient<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Device_rooms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_roomsFindFirstOrThrowArgs} args - Arguments to find a Device_rooms
     * @example
     * // Get one Device_rooms
     * const device_rooms = await prisma.device_rooms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends device_roomsFindFirstOrThrowArgs>(args?: SelectSubset<T, device_roomsFindFirstOrThrowArgs<ExtArgs>>): Prisma__device_roomsClient<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Device_rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_roomsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Device_rooms
     * const device_rooms = await prisma.device_rooms.findMany()
     * 
     * // Get first 10 Device_rooms
     * const device_rooms = await prisma.device_rooms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const device_roomsWithIdOnly = await prisma.device_rooms.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends device_roomsFindManyArgs>(args?: SelectSubset<T, device_roomsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Device_rooms.
     * @param {device_roomsCreateArgs} args - Arguments to create a Device_rooms.
     * @example
     * // Create one Device_rooms
     * const Device_rooms = await prisma.device_rooms.create({
     *   data: {
     *     // ... data to create a Device_rooms
     *   }
     * })
     * 
     */
    create<T extends device_roomsCreateArgs>(args: SelectSubset<T, device_roomsCreateArgs<ExtArgs>>): Prisma__device_roomsClient<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Device_rooms.
     * @param {device_roomsCreateManyArgs} args - Arguments to create many Device_rooms.
     * @example
     * // Create many Device_rooms
     * const device_rooms = await prisma.device_rooms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends device_roomsCreateManyArgs>(args?: SelectSubset<T, device_roomsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Device_rooms and returns the data saved in the database.
     * @param {device_roomsCreateManyAndReturnArgs} args - Arguments to create many Device_rooms.
     * @example
     * // Create many Device_rooms
     * const device_rooms = await prisma.device_rooms.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Device_rooms and only return the `id`
     * const device_roomsWithIdOnly = await prisma.device_rooms.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends device_roomsCreateManyAndReturnArgs>(args?: SelectSubset<T, device_roomsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Device_rooms.
     * @param {device_roomsDeleteArgs} args - Arguments to delete one Device_rooms.
     * @example
     * // Delete one Device_rooms
     * const Device_rooms = await prisma.device_rooms.delete({
     *   where: {
     *     // ... filter to delete one Device_rooms
     *   }
     * })
     * 
     */
    delete<T extends device_roomsDeleteArgs>(args: SelectSubset<T, device_roomsDeleteArgs<ExtArgs>>): Prisma__device_roomsClient<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Device_rooms.
     * @param {device_roomsUpdateArgs} args - Arguments to update one Device_rooms.
     * @example
     * // Update one Device_rooms
     * const device_rooms = await prisma.device_rooms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends device_roomsUpdateArgs>(args: SelectSubset<T, device_roomsUpdateArgs<ExtArgs>>): Prisma__device_roomsClient<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Device_rooms.
     * @param {device_roomsDeleteManyArgs} args - Arguments to filter Device_rooms to delete.
     * @example
     * // Delete a few Device_rooms
     * const { count } = await prisma.device_rooms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends device_roomsDeleteManyArgs>(args?: SelectSubset<T, device_roomsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Device_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_roomsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Device_rooms
     * const device_rooms = await prisma.device_rooms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends device_roomsUpdateManyArgs>(args: SelectSubset<T, device_roomsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device_rooms.
     * @param {device_roomsUpsertArgs} args - Arguments to update or create a Device_rooms.
     * @example
     * // Update or create a Device_rooms
     * const device_rooms = await prisma.device_rooms.upsert({
     *   create: {
     *     // ... data to create a Device_rooms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device_rooms we want to update
     *   }
     * })
     */
    upsert<T extends device_roomsUpsertArgs>(args: SelectSubset<T, device_roomsUpsertArgs<ExtArgs>>): Prisma__device_roomsClient<$Result.GetResult<Prisma.$device_roomsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Device_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_roomsCountArgs} args - Arguments to filter Device_rooms to count.
     * @example
     * // Count the number of Device_rooms
     * const count = await prisma.device_rooms.count({
     *   where: {
     *     // ... the filter for the Device_rooms we want to count
     *   }
     * })
    **/
    count<T extends device_roomsCountArgs>(
      args?: Subset<T, device_roomsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Device_roomsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Device_roomsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Device_roomsAggregateArgs>(args: Subset<T, Device_roomsAggregateArgs>): Prisma.PrismaPromise<GetDevice_roomsAggregateType<T>>

    /**
     * Group by Device_rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_roomsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends device_roomsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: device_roomsGroupByArgs['orderBy'] }
        : { orderBy?: device_roomsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, device_roomsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevice_roomsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the device_rooms model
   */
  readonly fields: device_roomsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for device_rooms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__device_roomsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the device_rooms model
   */ 
  interface device_roomsFieldRefs {
    readonly id: FieldRef<"device_rooms", 'Int'>
    readonly tenantId: FieldRef<"device_rooms", 'String'>
    readonly roomId: FieldRef<"device_rooms", 'String'>
    readonly roomName: FieldRef<"device_rooms", 'String'>
    readonly deviceId: FieldRef<"device_rooms", 'String'>
    readonly deviceType: FieldRef<"device_rooms", 'String'>
    readonly placeId: FieldRef<"device_rooms", 'String'>
    readonly status: FieldRef<"device_rooms", 'String'>
    readonly ipAddress: FieldRef<"device_rooms", 'String'>
    readonly macAddress: FieldRef<"device_rooms", 'String'>
    readonly lastUsedAt: FieldRef<"device_rooms", 'DateTime'>
    readonly isActive: FieldRef<"device_rooms", 'Boolean'>
    readonly createdAt: FieldRef<"device_rooms", 'DateTime'>
    readonly updatedAt: FieldRef<"device_rooms", 'DateTime'>
    readonly is_deleted: FieldRef<"device_rooms", 'Boolean'>
    readonly deleted_at: FieldRef<"device_rooms", 'DateTime'>
    readonly deleted_by: FieldRef<"device_rooms", 'String'>
  }
    

  // Custom InputTypes
  /**
   * device_rooms findUnique
   */
  export type device_roomsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    /**
     * Filter, which device_rooms to fetch.
     */
    where: device_roomsWhereUniqueInput
  }

  /**
   * device_rooms findUniqueOrThrow
   */
  export type device_roomsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    /**
     * Filter, which device_rooms to fetch.
     */
    where: device_roomsWhereUniqueInput
  }

  /**
   * device_rooms findFirst
   */
  export type device_roomsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    /**
     * Filter, which device_rooms to fetch.
     */
    where?: device_roomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_rooms to fetch.
     */
    orderBy?: device_roomsOrderByWithRelationInput | device_roomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for device_rooms.
     */
    cursor?: device_roomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of device_rooms.
     */
    distinct?: Device_roomsScalarFieldEnum | Device_roomsScalarFieldEnum[]
  }

  /**
   * device_rooms findFirstOrThrow
   */
  export type device_roomsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    /**
     * Filter, which device_rooms to fetch.
     */
    where?: device_roomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_rooms to fetch.
     */
    orderBy?: device_roomsOrderByWithRelationInput | device_roomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for device_rooms.
     */
    cursor?: device_roomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of device_rooms.
     */
    distinct?: Device_roomsScalarFieldEnum | Device_roomsScalarFieldEnum[]
  }

  /**
   * device_rooms findMany
   */
  export type device_roomsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    /**
     * Filter, which device_rooms to fetch.
     */
    where?: device_roomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_rooms to fetch.
     */
    orderBy?: device_roomsOrderByWithRelationInput | device_roomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing device_rooms.
     */
    cursor?: device_roomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_rooms.
     */
    skip?: number
    distinct?: Device_roomsScalarFieldEnum | Device_roomsScalarFieldEnum[]
  }

  /**
   * device_rooms create
   */
  export type device_roomsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    /**
     * The data needed to create a device_rooms.
     */
    data: XOR<device_roomsCreateInput, device_roomsUncheckedCreateInput>
  }

  /**
   * device_rooms createMany
   */
  export type device_roomsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many device_rooms.
     */
    data: device_roomsCreateManyInput | device_roomsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * device_rooms createManyAndReturn
   */
  export type device_roomsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many device_rooms.
     */
    data: device_roomsCreateManyInput | device_roomsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * device_rooms update
   */
  export type device_roomsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    /**
     * The data needed to update a device_rooms.
     */
    data: XOR<device_roomsUpdateInput, device_roomsUncheckedUpdateInput>
    /**
     * Choose, which device_rooms to update.
     */
    where: device_roomsWhereUniqueInput
  }

  /**
   * device_rooms updateMany
   */
  export type device_roomsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update device_rooms.
     */
    data: XOR<device_roomsUpdateManyMutationInput, device_roomsUncheckedUpdateManyInput>
    /**
     * Filter which device_rooms to update
     */
    where?: device_roomsWhereInput
  }

  /**
   * device_rooms upsert
   */
  export type device_roomsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    /**
     * The filter to search for the device_rooms to update in case it exists.
     */
    where: device_roomsWhereUniqueInput
    /**
     * In case the device_rooms found by the `where` argument doesn't exist, create a new device_rooms with this data.
     */
    create: XOR<device_roomsCreateInput, device_roomsUncheckedCreateInput>
    /**
     * In case the device_rooms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<device_roomsUpdateInput, device_roomsUncheckedUpdateInput>
  }

  /**
   * device_rooms delete
   */
  export type device_roomsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
    /**
     * Filter which device_rooms to delete.
     */
    where: device_roomsWhereUniqueInput
  }

  /**
   * device_rooms deleteMany
   */
  export type device_roomsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device_rooms to delete
     */
    where?: device_roomsWhereInput
  }

  /**
   * device_rooms without action
   */
  export type device_roomsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_rooms
     */
    select?: device_roomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: device_roomsInclude<ExtArgs> | null
  }


  /**
   * Model device_video_caches
   */

  export type AggregateDevice_video_caches = {
    _count: Device_video_cachesCountAggregateOutputType | null
    _min: Device_video_cachesMinAggregateOutputType | null
    _max: Device_video_cachesMaxAggregateOutputType | null
  }

  export type Device_video_cachesMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    lastShownAt: Date | null
    updatedAt: Date | null
    lastViewedAt: Date | null
    userId: string | null
    viewed: boolean | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Device_video_cachesMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    lastShownAt: Date | null
    updatedAt: Date | null
    lastViewedAt: Date | null
    userId: string | null
    viewed: boolean | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Device_video_cachesCountAggregateOutputType = {
    id: number
    deviceId: number
    videoIds: number
    lastShownAt: number
    updatedAt: number
    lastViewedAt: number
    userId: number
    viewed: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Device_video_cachesMinAggregateInputType = {
    id?: true
    deviceId?: true
    lastShownAt?: true
    updatedAt?: true
    lastViewedAt?: true
    userId?: true
    viewed?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Device_video_cachesMaxAggregateInputType = {
    id?: true
    deviceId?: true
    lastShownAt?: true
    updatedAt?: true
    lastViewedAt?: true
    userId?: true
    viewed?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Device_video_cachesCountAggregateInputType = {
    id?: true
    deviceId?: true
    videoIds?: true
    lastShownAt?: true
    updatedAt?: true
    lastViewedAt?: true
    userId?: true
    viewed?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Device_video_cachesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device_video_caches to aggregate.
     */
    where?: device_video_cachesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_video_caches to fetch.
     */
    orderBy?: device_video_cachesOrderByWithRelationInput | device_video_cachesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: device_video_cachesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_video_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_video_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned device_video_caches
    **/
    _count?: true | Device_video_cachesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Device_video_cachesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Device_video_cachesMaxAggregateInputType
  }

  export type GetDevice_video_cachesAggregateType<T extends Device_video_cachesAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice_video_caches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice_video_caches[P]>
      : GetScalarType<T[P], AggregateDevice_video_caches[P]>
  }




  export type device_video_cachesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: device_video_cachesWhereInput
    orderBy?: device_video_cachesOrderByWithAggregationInput | device_video_cachesOrderByWithAggregationInput[]
    by: Device_video_cachesScalarFieldEnum[] | Device_video_cachesScalarFieldEnum
    having?: device_video_cachesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Device_video_cachesCountAggregateInputType | true
    _min?: Device_video_cachesMinAggregateInputType
    _max?: Device_video_cachesMaxAggregateInputType
  }

  export type Device_video_cachesGroupByOutputType = {
    id: string
    deviceId: string
    videoIds: string[]
    lastShownAt: Date
    updatedAt: Date
    lastViewedAt: Date | null
    userId: string | null
    viewed: boolean
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Device_video_cachesCountAggregateOutputType | null
    _min: Device_video_cachesMinAggregateOutputType | null
    _max: Device_video_cachesMaxAggregateOutputType | null
  }

  type GetDevice_video_cachesGroupByPayload<T extends device_video_cachesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Device_video_cachesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Device_video_cachesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Device_video_cachesGroupByOutputType[P]>
            : GetScalarType<T[P], Device_video_cachesGroupByOutputType[P]>
        }
      >
    >


  export type device_video_cachesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    videoIds?: boolean
    lastShownAt?: boolean
    updatedAt?: boolean
    lastViewedAt?: boolean
    userId?: boolean
    viewed?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["device_video_caches"]>

  export type device_video_cachesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    videoIds?: boolean
    lastShownAt?: boolean
    updatedAt?: boolean
    lastViewedAt?: boolean
    userId?: boolean
    viewed?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["device_video_caches"]>

  export type device_video_cachesSelectScalar = {
    id?: boolean
    deviceId?: boolean
    videoIds?: boolean
    lastShownAt?: boolean
    updatedAt?: boolean
    lastViewedAt?: boolean
    userId?: boolean
    viewed?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }


  export type $device_video_cachesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "device_video_caches"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      videoIds: string[]
      lastShownAt: Date
      updatedAt: Date
      lastViewedAt: Date | null
      userId: string | null
      viewed: boolean
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["device_video_caches"]>
    composites: {}
  }

  type device_video_cachesGetPayload<S extends boolean | null | undefined | device_video_cachesDefaultArgs> = $Result.GetResult<Prisma.$device_video_cachesPayload, S>

  type device_video_cachesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<device_video_cachesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Device_video_cachesCountAggregateInputType | true
    }

  export interface device_video_cachesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['device_video_caches'], meta: { name: 'device_video_caches' } }
    /**
     * Find zero or one Device_video_caches that matches the filter.
     * @param {device_video_cachesFindUniqueArgs} args - Arguments to find a Device_video_caches
     * @example
     * // Get one Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends device_video_cachesFindUniqueArgs>(args: SelectSubset<T, device_video_cachesFindUniqueArgs<ExtArgs>>): Prisma__device_video_cachesClient<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Device_video_caches that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {device_video_cachesFindUniqueOrThrowArgs} args - Arguments to find a Device_video_caches
     * @example
     * // Get one Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends device_video_cachesFindUniqueOrThrowArgs>(args: SelectSubset<T, device_video_cachesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__device_video_cachesClient<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Device_video_caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_video_cachesFindFirstArgs} args - Arguments to find a Device_video_caches
     * @example
     * // Get one Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends device_video_cachesFindFirstArgs>(args?: SelectSubset<T, device_video_cachesFindFirstArgs<ExtArgs>>): Prisma__device_video_cachesClient<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Device_video_caches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_video_cachesFindFirstOrThrowArgs} args - Arguments to find a Device_video_caches
     * @example
     * // Get one Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends device_video_cachesFindFirstOrThrowArgs>(args?: SelectSubset<T, device_video_cachesFindFirstOrThrowArgs<ExtArgs>>): Prisma__device_video_cachesClient<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Device_video_caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_video_cachesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.findMany()
     * 
     * // Get first 10 Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const device_video_cachesWithIdOnly = await prisma.device_video_caches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends device_video_cachesFindManyArgs>(args?: SelectSubset<T, device_video_cachesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Device_video_caches.
     * @param {device_video_cachesCreateArgs} args - Arguments to create a Device_video_caches.
     * @example
     * // Create one Device_video_caches
     * const Device_video_caches = await prisma.device_video_caches.create({
     *   data: {
     *     // ... data to create a Device_video_caches
     *   }
     * })
     * 
     */
    create<T extends device_video_cachesCreateArgs>(args: SelectSubset<T, device_video_cachesCreateArgs<ExtArgs>>): Prisma__device_video_cachesClient<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Device_video_caches.
     * @param {device_video_cachesCreateManyArgs} args - Arguments to create many Device_video_caches.
     * @example
     * // Create many Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends device_video_cachesCreateManyArgs>(args?: SelectSubset<T, device_video_cachesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Device_video_caches and returns the data saved in the database.
     * @param {device_video_cachesCreateManyAndReturnArgs} args - Arguments to create many Device_video_caches.
     * @example
     * // Create many Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Device_video_caches and only return the `id`
     * const device_video_cachesWithIdOnly = await prisma.device_video_caches.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends device_video_cachesCreateManyAndReturnArgs>(args?: SelectSubset<T, device_video_cachesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Device_video_caches.
     * @param {device_video_cachesDeleteArgs} args - Arguments to delete one Device_video_caches.
     * @example
     * // Delete one Device_video_caches
     * const Device_video_caches = await prisma.device_video_caches.delete({
     *   where: {
     *     // ... filter to delete one Device_video_caches
     *   }
     * })
     * 
     */
    delete<T extends device_video_cachesDeleteArgs>(args: SelectSubset<T, device_video_cachesDeleteArgs<ExtArgs>>): Prisma__device_video_cachesClient<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Device_video_caches.
     * @param {device_video_cachesUpdateArgs} args - Arguments to update one Device_video_caches.
     * @example
     * // Update one Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends device_video_cachesUpdateArgs>(args: SelectSubset<T, device_video_cachesUpdateArgs<ExtArgs>>): Prisma__device_video_cachesClient<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Device_video_caches.
     * @param {device_video_cachesDeleteManyArgs} args - Arguments to filter Device_video_caches to delete.
     * @example
     * // Delete a few Device_video_caches
     * const { count } = await prisma.device_video_caches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends device_video_cachesDeleteManyArgs>(args?: SelectSubset<T, device_video_cachesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Device_video_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_video_cachesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends device_video_cachesUpdateManyArgs>(args: SelectSubset<T, device_video_cachesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device_video_caches.
     * @param {device_video_cachesUpsertArgs} args - Arguments to update or create a Device_video_caches.
     * @example
     * // Update or create a Device_video_caches
     * const device_video_caches = await prisma.device_video_caches.upsert({
     *   create: {
     *     // ... data to create a Device_video_caches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device_video_caches we want to update
     *   }
     * })
     */
    upsert<T extends device_video_cachesUpsertArgs>(args: SelectSubset<T, device_video_cachesUpsertArgs<ExtArgs>>): Prisma__device_video_cachesClient<$Result.GetResult<Prisma.$device_video_cachesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Device_video_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_video_cachesCountArgs} args - Arguments to filter Device_video_caches to count.
     * @example
     * // Count the number of Device_video_caches
     * const count = await prisma.device_video_caches.count({
     *   where: {
     *     // ... the filter for the Device_video_caches we want to count
     *   }
     * })
    **/
    count<T extends device_video_cachesCountArgs>(
      args?: Subset<T, device_video_cachesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Device_video_cachesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device_video_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Device_video_cachesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Device_video_cachesAggregateArgs>(args: Subset<T, Device_video_cachesAggregateArgs>): Prisma.PrismaPromise<GetDevice_video_cachesAggregateType<T>>

    /**
     * Group by Device_video_caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {device_video_cachesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends device_video_cachesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: device_video_cachesGroupByArgs['orderBy'] }
        : { orderBy?: device_video_cachesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, device_video_cachesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevice_video_cachesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the device_video_caches model
   */
  readonly fields: device_video_cachesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for device_video_caches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__device_video_cachesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the device_video_caches model
   */ 
  interface device_video_cachesFieldRefs {
    readonly id: FieldRef<"device_video_caches", 'String'>
    readonly deviceId: FieldRef<"device_video_caches", 'String'>
    readonly videoIds: FieldRef<"device_video_caches", 'String[]'>
    readonly lastShownAt: FieldRef<"device_video_caches", 'DateTime'>
    readonly updatedAt: FieldRef<"device_video_caches", 'DateTime'>
    readonly lastViewedAt: FieldRef<"device_video_caches", 'DateTime'>
    readonly userId: FieldRef<"device_video_caches", 'String'>
    readonly viewed: FieldRef<"device_video_caches", 'Boolean'>
    readonly deleted_at: FieldRef<"device_video_caches", 'DateTime'>
    readonly deleted_by: FieldRef<"device_video_caches", 'String'>
    readonly is_deleted: FieldRef<"device_video_caches", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * device_video_caches findUnique
   */
  export type device_video_cachesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
    /**
     * Filter, which device_video_caches to fetch.
     */
    where: device_video_cachesWhereUniqueInput
  }

  /**
   * device_video_caches findUniqueOrThrow
   */
  export type device_video_cachesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
    /**
     * Filter, which device_video_caches to fetch.
     */
    where: device_video_cachesWhereUniqueInput
  }

  /**
   * device_video_caches findFirst
   */
  export type device_video_cachesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
    /**
     * Filter, which device_video_caches to fetch.
     */
    where?: device_video_cachesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_video_caches to fetch.
     */
    orderBy?: device_video_cachesOrderByWithRelationInput | device_video_cachesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for device_video_caches.
     */
    cursor?: device_video_cachesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_video_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_video_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of device_video_caches.
     */
    distinct?: Device_video_cachesScalarFieldEnum | Device_video_cachesScalarFieldEnum[]
  }

  /**
   * device_video_caches findFirstOrThrow
   */
  export type device_video_cachesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
    /**
     * Filter, which device_video_caches to fetch.
     */
    where?: device_video_cachesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_video_caches to fetch.
     */
    orderBy?: device_video_cachesOrderByWithRelationInput | device_video_cachesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for device_video_caches.
     */
    cursor?: device_video_cachesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_video_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_video_caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of device_video_caches.
     */
    distinct?: Device_video_cachesScalarFieldEnum | Device_video_cachesScalarFieldEnum[]
  }

  /**
   * device_video_caches findMany
   */
  export type device_video_cachesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
    /**
     * Filter, which device_video_caches to fetch.
     */
    where?: device_video_cachesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of device_video_caches to fetch.
     */
    orderBy?: device_video_cachesOrderByWithRelationInput | device_video_cachesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing device_video_caches.
     */
    cursor?: device_video_cachesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` device_video_caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` device_video_caches.
     */
    skip?: number
    distinct?: Device_video_cachesScalarFieldEnum | Device_video_cachesScalarFieldEnum[]
  }

  /**
   * device_video_caches create
   */
  export type device_video_cachesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
    /**
     * The data needed to create a device_video_caches.
     */
    data: XOR<device_video_cachesCreateInput, device_video_cachesUncheckedCreateInput>
  }

  /**
   * device_video_caches createMany
   */
  export type device_video_cachesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many device_video_caches.
     */
    data: device_video_cachesCreateManyInput | device_video_cachesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * device_video_caches createManyAndReturn
   */
  export type device_video_cachesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many device_video_caches.
     */
    data: device_video_cachesCreateManyInput | device_video_cachesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * device_video_caches update
   */
  export type device_video_cachesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
    /**
     * The data needed to update a device_video_caches.
     */
    data: XOR<device_video_cachesUpdateInput, device_video_cachesUncheckedUpdateInput>
    /**
     * Choose, which device_video_caches to update.
     */
    where: device_video_cachesWhereUniqueInput
  }

  /**
   * device_video_caches updateMany
   */
  export type device_video_cachesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update device_video_caches.
     */
    data: XOR<device_video_cachesUpdateManyMutationInput, device_video_cachesUncheckedUpdateManyInput>
    /**
     * Filter which device_video_caches to update
     */
    where?: device_video_cachesWhereInput
  }

  /**
   * device_video_caches upsert
   */
  export type device_video_cachesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
    /**
     * The filter to search for the device_video_caches to update in case it exists.
     */
    where: device_video_cachesWhereUniqueInput
    /**
     * In case the device_video_caches found by the `where` argument doesn't exist, create a new device_video_caches with this data.
     */
    create: XOR<device_video_cachesCreateInput, device_video_cachesUncheckedCreateInput>
    /**
     * In case the device_video_caches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<device_video_cachesUpdateInput, device_video_cachesUncheckedUpdateInput>
  }

  /**
   * device_video_caches delete
   */
  export type device_video_cachesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
    /**
     * Filter which device_video_caches to delete.
     */
    where: device_video_cachesWhereUniqueInput
  }

  /**
   * device_video_caches deleteMany
   */
  export type device_video_cachesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which device_video_caches to delete
     */
    where?: device_video_cachesWhereInput
  }

  /**
   * device_video_caches without action
   */
  export type device_video_cachesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the device_video_caches
     */
    select?: device_video_cachesSelect<ExtArgs> | null
  }


  /**
   * Model notification_templates
   */

  export type AggregateNotification_templates = {
    _count: Notification_templatesCountAggregateOutputType | null
    _min: Notification_templatesMinAggregateOutputType | null
    _max: Notification_templatesMaxAggregateOutputType | null
  }

  export type Notification_templatesMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    type: string | null
    code: string | null
    subject: string | null
    content: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    body: string | null
    html: boolean | null
    locale: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Notification_templatesMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    type: string | null
    code: string | null
    subject: string | null
    content: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    body: string | null
    html: boolean | null
    locale: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Notification_templatesCountAggregateOutputType = {
    id: number
    tenant_id: number
    type: number
    code: number
    subject: number
    content: number
    variables: number
    is_active: number
    created_at: number
    updated_at: number
    body: number
    html: number
    locale: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Notification_templatesMinAggregateInputType = {
    id?: true
    tenant_id?: true
    type?: true
    code?: true
    subject?: true
    content?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    body?: true
    html?: true
    locale?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Notification_templatesMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    type?: true
    code?: true
    subject?: true
    content?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    body?: true
    html?: true
    locale?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Notification_templatesCountAggregateInputType = {
    id?: true
    tenant_id?: true
    type?: true
    code?: true
    subject?: true
    content?: true
    variables?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    body?: true
    html?: true
    locale?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Notification_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_templates to aggregate.
     */
    where?: notification_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_templates to fetch.
     */
    orderBy?: notification_templatesOrderByWithRelationInput | notification_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notification_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notification_templates
    **/
    _count?: true | Notification_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Notification_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Notification_templatesMaxAggregateInputType
  }

  export type GetNotification_templatesAggregateType<T extends Notification_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification_templates[P]>
      : GetScalarType<T[P], AggregateNotification_templates[P]>
  }




  export type notification_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notification_templatesWhereInput
    orderBy?: notification_templatesOrderByWithAggregationInput | notification_templatesOrderByWithAggregationInput[]
    by: Notification_templatesScalarFieldEnum[] | Notification_templatesScalarFieldEnum
    having?: notification_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Notification_templatesCountAggregateInputType | true
    _min?: Notification_templatesMinAggregateInputType
    _max?: Notification_templatesMaxAggregateInputType
  }

  export type Notification_templatesGroupByOutputType = {
    id: string
    tenant_id: string
    type: string
    code: string
    subject: string | null
    content: string
    variables: string[]
    is_active: boolean
    created_at: Date
    updated_at: Date
    body: string
    html: boolean
    locale: string
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Notification_templatesCountAggregateOutputType | null
    _min: Notification_templatesMinAggregateOutputType | null
    _max: Notification_templatesMaxAggregateOutputType | null
  }

  type GetNotification_templatesGroupByPayload<T extends notification_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Notification_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Notification_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Notification_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Notification_templatesGroupByOutputType[P]>
        }
      >
    >


  export type notification_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    type?: boolean
    code?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    body?: boolean
    html?: boolean
    locale?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["notification_templates"]>

  export type notification_templatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    type?: boolean
    code?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    body?: boolean
    html?: boolean
    locale?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["notification_templates"]>

  export type notification_templatesSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    type?: boolean
    code?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    body?: boolean
    html?: boolean
    locale?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }


  export type $notification_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification_templates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      type: string
      code: string
      subject: string | null
      content: string
      variables: string[]
      is_active: boolean
      created_at: Date
      updated_at: Date
      body: string
      html: boolean
      locale: string
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["notification_templates"]>
    composites: {}
  }

  type notification_templatesGetPayload<S extends boolean | null | undefined | notification_templatesDefaultArgs> = $Result.GetResult<Prisma.$notification_templatesPayload, S>

  type notification_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notification_templatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Notification_templatesCountAggregateInputType | true
    }

  export interface notification_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification_templates'], meta: { name: 'notification_templates' } }
    /**
     * Find zero or one Notification_templates that matches the filter.
     * @param {notification_templatesFindUniqueArgs} args - Arguments to find a Notification_templates
     * @example
     * // Get one Notification_templates
     * const notification_templates = await prisma.notification_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notification_templatesFindUniqueArgs>(args: SelectSubset<T, notification_templatesFindUniqueArgs<ExtArgs>>): Prisma__notification_templatesClient<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification_templates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notification_templatesFindUniqueOrThrowArgs} args - Arguments to find a Notification_templates
     * @example
     * // Get one Notification_templates
     * const notification_templates = await prisma.notification_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notification_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, notification_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notification_templatesClient<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_templatesFindFirstArgs} args - Arguments to find a Notification_templates
     * @example
     * // Get one Notification_templates
     * const notification_templates = await prisma.notification_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notification_templatesFindFirstArgs>(args?: SelectSubset<T, notification_templatesFindFirstArgs<ExtArgs>>): Prisma__notification_templatesClient<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_templatesFindFirstOrThrowArgs} args - Arguments to find a Notification_templates
     * @example
     * // Get one Notification_templates
     * const notification_templates = await prisma.notification_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notification_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, notification_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notification_templatesClient<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notification_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notification_templates
     * const notification_templates = await prisma.notification_templates.findMany()
     * 
     * // Get first 10 Notification_templates
     * const notification_templates = await prisma.notification_templates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notification_templatesWithIdOnly = await prisma.notification_templates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notification_templatesFindManyArgs>(args?: SelectSubset<T, notification_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification_templates.
     * @param {notification_templatesCreateArgs} args - Arguments to create a Notification_templates.
     * @example
     * // Create one Notification_templates
     * const Notification_templates = await prisma.notification_templates.create({
     *   data: {
     *     // ... data to create a Notification_templates
     *   }
     * })
     * 
     */
    create<T extends notification_templatesCreateArgs>(args: SelectSubset<T, notification_templatesCreateArgs<ExtArgs>>): Prisma__notification_templatesClient<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notification_templates.
     * @param {notification_templatesCreateManyArgs} args - Arguments to create many Notification_templates.
     * @example
     * // Create many Notification_templates
     * const notification_templates = await prisma.notification_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notification_templatesCreateManyArgs>(args?: SelectSubset<T, notification_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notification_templates and returns the data saved in the database.
     * @param {notification_templatesCreateManyAndReturnArgs} args - Arguments to create many Notification_templates.
     * @example
     * // Create many Notification_templates
     * const notification_templates = await prisma.notification_templates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notification_templates and only return the `id`
     * const notification_templatesWithIdOnly = await prisma.notification_templates.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notification_templatesCreateManyAndReturnArgs>(args?: SelectSubset<T, notification_templatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification_templates.
     * @param {notification_templatesDeleteArgs} args - Arguments to delete one Notification_templates.
     * @example
     * // Delete one Notification_templates
     * const Notification_templates = await prisma.notification_templates.delete({
     *   where: {
     *     // ... filter to delete one Notification_templates
     *   }
     * })
     * 
     */
    delete<T extends notification_templatesDeleteArgs>(args: SelectSubset<T, notification_templatesDeleteArgs<ExtArgs>>): Prisma__notification_templatesClient<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification_templates.
     * @param {notification_templatesUpdateArgs} args - Arguments to update one Notification_templates.
     * @example
     * // Update one Notification_templates
     * const notification_templates = await prisma.notification_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notification_templatesUpdateArgs>(args: SelectSubset<T, notification_templatesUpdateArgs<ExtArgs>>): Prisma__notification_templatesClient<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notification_templates.
     * @param {notification_templatesDeleteManyArgs} args - Arguments to filter Notification_templates to delete.
     * @example
     * // Delete a few Notification_templates
     * const { count } = await prisma.notification_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notification_templatesDeleteManyArgs>(args?: SelectSubset<T, notification_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notification_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notification_templates
     * const notification_templates = await prisma.notification_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notification_templatesUpdateManyArgs>(args: SelectSubset<T, notification_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification_templates.
     * @param {notification_templatesUpsertArgs} args - Arguments to update or create a Notification_templates.
     * @example
     * // Update or create a Notification_templates
     * const notification_templates = await prisma.notification_templates.upsert({
     *   create: {
     *     // ... data to create a Notification_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification_templates we want to update
     *   }
     * })
     */
    upsert<T extends notification_templatesUpsertArgs>(args: SelectSubset<T, notification_templatesUpsertArgs<ExtArgs>>): Prisma__notification_templatesClient<$Result.GetResult<Prisma.$notification_templatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notification_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_templatesCountArgs} args - Arguments to filter Notification_templates to count.
     * @example
     * // Count the number of Notification_templates
     * const count = await prisma.notification_templates.count({
     *   where: {
     *     // ... the filter for the Notification_templates we want to count
     *   }
     * })
    **/
    count<T extends notification_templatesCountArgs>(
      args?: Subset<T, notification_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Notification_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Notification_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Notification_templatesAggregateArgs>(args: Subset<T, Notification_templatesAggregateArgs>): Prisma.PrismaPromise<GetNotification_templatesAggregateType<T>>

    /**
     * Group by Notification_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notification_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notification_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notification_templatesGroupByArgs['orderBy'] }
        : { orderBy?: notification_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notification_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotification_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification_templates model
   */
  readonly fields: notification_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notification_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification_templates model
   */ 
  interface notification_templatesFieldRefs {
    readonly id: FieldRef<"notification_templates", 'String'>
    readonly tenant_id: FieldRef<"notification_templates", 'String'>
    readonly type: FieldRef<"notification_templates", 'String'>
    readonly code: FieldRef<"notification_templates", 'String'>
    readonly subject: FieldRef<"notification_templates", 'String'>
    readonly content: FieldRef<"notification_templates", 'String'>
    readonly variables: FieldRef<"notification_templates", 'String[]'>
    readonly is_active: FieldRef<"notification_templates", 'Boolean'>
    readonly created_at: FieldRef<"notification_templates", 'DateTime'>
    readonly updated_at: FieldRef<"notification_templates", 'DateTime'>
    readonly body: FieldRef<"notification_templates", 'String'>
    readonly html: FieldRef<"notification_templates", 'Boolean'>
    readonly locale: FieldRef<"notification_templates", 'String'>
    readonly deleted_at: FieldRef<"notification_templates", 'DateTime'>
    readonly deleted_by: FieldRef<"notification_templates", 'String'>
    readonly is_deleted: FieldRef<"notification_templates", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * notification_templates findUnique
   */
  export type notification_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
    /**
     * Filter, which notification_templates to fetch.
     */
    where: notification_templatesWhereUniqueInput
  }

  /**
   * notification_templates findUniqueOrThrow
   */
  export type notification_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
    /**
     * Filter, which notification_templates to fetch.
     */
    where: notification_templatesWhereUniqueInput
  }

  /**
   * notification_templates findFirst
   */
  export type notification_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
    /**
     * Filter, which notification_templates to fetch.
     */
    where?: notification_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_templates to fetch.
     */
    orderBy?: notification_templatesOrderByWithRelationInput | notification_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_templates.
     */
    cursor?: notification_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_templates.
     */
    distinct?: Notification_templatesScalarFieldEnum | Notification_templatesScalarFieldEnum[]
  }

  /**
   * notification_templates findFirstOrThrow
   */
  export type notification_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
    /**
     * Filter, which notification_templates to fetch.
     */
    where?: notification_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_templates to fetch.
     */
    orderBy?: notification_templatesOrderByWithRelationInput | notification_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notification_templates.
     */
    cursor?: notification_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notification_templates.
     */
    distinct?: Notification_templatesScalarFieldEnum | Notification_templatesScalarFieldEnum[]
  }

  /**
   * notification_templates findMany
   */
  export type notification_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
    /**
     * Filter, which notification_templates to fetch.
     */
    where?: notification_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notification_templates to fetch.
     */
    orderBy?: notification_templatesOrderByWithRelationInput | notification_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notification_templates.
     */
    cursor?: notification_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notification_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notification_templates.
     */
    skip?: number
    distinct?: Notification_templatesScalarFieldEnum | Notification_templatesScalarFieldEnum[]
  }

  /**
   * notification_templates create
   */
  export type notification_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
    /**
     * The data needed to create a notification_templates.
     */
    data: XOR<notification_templatesCreateInput, notification_templatesUncheckedCreateInput>
  }

  /**
   * notification_templates createMany
   */
  export type notification_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notification_templates.
     */
    data: notification_templatesCreateManyInput | notification_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification_templates createManyAndReturn
   */
  export type notification_templatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many notification_templates.
     */
    data: notification_templatesCreateManyInput | notification_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification_templates update
   */
  export type notification_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
    /**
     * The data needed to update a notification_templates.
     */
    data: XOR<notification_templatesUpdateInput, notification_templatesUncheckedUpdateInput>
    /**
     * Choose, which notification_templates to update.
     */
    where: notification_templatesWhereUniqueInput
  }

  /**
   * notification_templates updateMany
   */
  export type notification_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notification_templates.
     */
    data: XOR<notification_templatesUpdateManyMutationInput, notification_templatesUncheckedUpdateManyInput>
    /**
     * Filter which notification_templates to update
     */
    where?: notification_templatesWhereInput
  }

  /**
   * notification_templates upsert
   */
  export type notification_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
    /**
     * The filter to search for the notification_templates to update in case it exists.
     */
    where: notification_templatesWhereUniqueInput
    /**
     * In case the notification_templates found by the `where` argument doesn't exist, create a new notification_templates with this data.
     */
    create: XOR<notification_templatesCreateInput, notification_templatesUncheckedCreateInput>
    /**
     * In case the notification_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notification_templatesUpdateInput, notification_templatesUncheckedUpdateInput>
  }

  /**
   * notification_templates delete
   */
  export type notification_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
    /**
     * Filter which notification_templates to delete.
     */
    where: notification_templatesWhereUniqueInput
  }

  /**
   * notification_templates deleteMany
   */
  export type notification_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification_templates to delete
     */
    where?: notification_templatesWhereInput
  }

  /**
   * notification_templates without action
   */
  export type notification_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification_templates
     */
    select?: notification_templatesSelect<ExtArgs> | null
  }


  /**
   * Model page_histories
   */

  export type AggregatePage_histories = {
    _count: Page_historiesCountAggregateOutputType | null
    _avg: Page_historiesAvgAggregateOutputType | null
    _sum: Page_historiesSumAggregateOutputType | null
    _min: Page_historiesMinAggregateOutputType | null
    _max: Page_historiesMaxAggregateOutputType | null
  }

  export type Page_historiesAvgAggregateOutputType = {
    Version: number | null
  }

  export type Page_historiesSumAggregateOutputType = {
    Version: number | null
  }

  export type Page_historiesMinAggregateOutputType = {
    Id: string | null
    PageId: string | null
    Html: string | null
    Css: string | null
    Content: string | null
    Template: string | null
    Version: number | null
    CreatedAt: Date | null
    CreatedBy: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Page_historiesMaxAggregateOutputType = {
    Id: string | null
    PageId: string | null
    Html: string | null
    Css: string | null
    Content: string | null
    Template: string | null
    Version: number | null
    CreatedAt: Date | null
    CreatedBy: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Page_historiesCountAggregateOutputType = {
    Id: number
    PageId: number
    Html: number
    Css: number
    Content: number
    Template: number
    Version: number
    CreatedAt: number
    CreatedBy: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Page_historiesAvgAggregateInputType = {
    Version?: true
  }

  export type Page_historiesSumAggregateInputType = {
    Version?: true
  }

  export type Page_historiesMinAggregateInputType = {
    Id?: true
    PageId?: true
    Html?: true
    Css?: true
    Content?: true
    Template?: true
    Version?: true
    CreatedAt?: true
    CreatedBy?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Page_historiesMaxAggregateInputType = {
    Id?: true
    PageId?: true
    Html?: true
    Css?: true
    Content?: true
    Template?: true
    Version?: true
    CreatedAt?: true
    CreatedBy?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Page_historiesCountAggregateInputType = {
    Id?: true
    PageId?: true
    Html?: true
    Css?: true
    Content?: true
    Template?: true
    Version?: true
    CreatedAt?: true
    CreatedBy?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Page_historiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which page_histories to aggregate.
     */
    where?: page_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of page_histories to fetch.
     */
    orderBy?: page_historiesOrderByWithRelationInput | page_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: page_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` page_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` page_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned page_histories
    **/
    _count?: true | Page_historiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Page_historiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Page_historiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Page_historiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Page_historiesMaxAggregateInputType
  }

  export type GetPage_historiesAggregateType<T extends Page_historiesAggregateArgs> = {
        [P in keyof T & keyof AggregatePage_histories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage_histories[P]>
      : GetScalarType<T[P], AggregatePage_histories[P]>
  }




  export type page_historiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: page_historiesWhereInput
    orderBy?: page_historiesOrderByWithAggregationInput | page_historiesOrderByWithAggregationInput[]
    by: Page_historiesScalarFieldEnum[] | Page_historiesScalarFieldEnum
    having?: page_historiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Page_historiesCountAggregateInputType | true
    _avg?: Page_historiesAvgAggregateInputType
    _sum?: Page_historiesSumAggregateInputType
    _min?: Page_historiesMinAggregateInputType
    _max?: Page_historiesMaxAggregateInputType
  }

  export type Page_historiesGroupByOutputType = {
    Id: string
    PageId: string
    Html: string | null
    Css: string | null
    Content: string | null
    Template: string | null
    Version: number
    CreatedAt: Date
    CreatedBy: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Page_historiesCountAggregateOutputType | null
    _avg: Page_historiesAvgAggregateOutputType | null
    _sum: Page_historiesSumAggregateOutputType | null
    _min: Page_historiesMinAggregateOutputType | null
    _max: Page_historiesMaxAggregateOutputType | null
  }

  type GetPage_historiesGroupByPayload<T extends page_historiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Page_historiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Page_historiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Page_historiesGroupByOutputType[P]>
            : GetScalarType<T[P], Page_historiesGroupByOutputType[P]>
        }
      >
    >


  export type page_historiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    PageId?: boolean
    Html?: boolean
    Css?: boolean
    Content?: boolean
    Template?: boolean
    Version?: boolean
    CreatedAt?: boolean
    CreatedBy?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    pages?: boolean | pagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page_histories"]>

  export type page_historiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    PageId?: boolean
    Html?: boolean
    Css?: boolean
    Content?: boolean
    Template?: boolean
    Version?: boolean
    CreatedAt?: boolean
    CreatedBy?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    pages?: boolean | pagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page_histories"]>

  export type page_historiesSelectScalar = {
    Id?: boolean
    PageId?: boolean
    Html?: boolean
    Css?: boolean
    Content?: boolean
    Template?: boolean
    Version?: boolean
    CreatedAt?: boolean
    CreatedBy?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type page_historiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | pagesDefaultArgs<ExtArgs>
  }
  export type page_historiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | pagesDefaultArgs<ExtArgs>
  }

  export type $page_historiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "page_histories"
    objects: {
      pages: Prisma.$pagesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: string
      PageId: string
      Html: string | null
      Css: string | null
      Content: string | null
      Template: string | null
      Version: number
      CreatedAt: Date
      CreatedBy: string | null
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["page_histories"]>
    composites: {}
  }

  type page_historiesGetPayload<S extends boolean | null | undefined | page_historiesDefaultArgs> = $Result.GetResult<Prisma.$page_historiesPayload, S>

  type page_historiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<page_historiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Page_historiesCountAggregateInputType | true
    }

  export interface page_historiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['page_histories'], meta: { name: 'page_histories' } }
    /**
     * Find zero or one Page_histories that matches the filter.
     * @param {page_historiesFindUniqueArgs} args - Arguments to find a Page_histories
     * @example
     * // Get one Page_histories
     * const page_histories = await prisma.page_histories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends page_historiesFindUniqueArgs>(args: SelectSubset<T, page_historiesFindUniqueArgs<ExtArgs>>): Prisma__page_historiesClient<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Page_histories that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {page_historiesFindUniqueOrThrowArgs} args - Arguments to find a Page_histories
     * @example
     * // Get one Page_histories
     * const page_histories = await prisma.page_histories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends page_historiesFindUniqueOrThrowArgs>(args: SelectSubset<T, page_historiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__page_historiesClient<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Page_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {page_historiesFindFirstArgs} args - Arguments to find a Page_histories
     * @example
     * // Get one Page_histories
     * const page_histories = await prisma.page_histories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends page_historiesFindFirstArgs>(args?: SelectSubset<T, page_historiesFindFirstArgs<ExtArgs>>): Prisma__page_historiesClient<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Page_histories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {page_historiesFindFirstOrThrowArgs} args - Arguments to find a Page_histories
     * @example
     * // Get one Page_histories
     * const page_histories = await prisma.page_histories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends page_historiesFindFirstOrThrowArgs>(args?: SelectSubset<T, page_historiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__page_historiesClient<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Page_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {page_historiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Page_histories
     * const page_histories = await prisma.page_histories.findMany()
     * 
     * // Get first 10 Page_histories
     * const page_histories = await prisma.page_histories.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const page_historiesWithIdOnly = await prisma.page_histories.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends page_historiesFindManyArgs>(args?: SelectSubset<T, page_historiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Page_histories.
     * @param {page_historiesCreateArgs} args - Arguments to create a Page_histories.
     * @example
     * // Create one Page_histories
     * const Page_histories = await prisma.page_histories.create({
     *   data: {
     *     // ... data to create a Page_histories
     *   }
     * })
     * 
     */
    create<T extends page_historiesCreateArgs>(args: SelectSubset<T, page_historiesCreateArgs<ExtArgs>>): Prisma__page_historiesClient<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Page_histories.
     * @param {page_historiesCreateManyArgs} args - Arguments to create many Page_histories.
     * @example
     * // Create many Page_histories
     * const page_histories = await prisma.page_histories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends page_historiesCreateManyArgs>(args?: SelectSubset<T, page_historiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Page_histories and returns the data saved in the database.
     * @param {page_historiesCreateManyAndReturnArgs} args - Arguments to create many Page_histories.
     * @example
     * // Create many Page_histories
     * const page_histories = await prisma.page_histories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Page_histories and only return the `Id`
     * const page_historiesWithIdOnly = await prisma.page_histories.createManyAndReturn({ 
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends page_historiesCreateManyAndReturnArgs>(args?: SelectSubset<T, page_historiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Page_histories.
     * @param {page_historiesDeleteArgs} args - Arguments to delete one Page_histories.
     * @example
     * // Delete one Page_histories
     * const Page_histories = await prisma.page_histories.delete({
     *   where: {
     *     // ... filter to delete one Page_histories
     *   }
     * })
     * 
     */
    delete<T extends page_historiesDeleteArgs>(args: SelectSubset<T, page_historiesDeleteArgs<ExtArgs>>): Prisma__page_historiesClient<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Page_histories.
     * @param {page_historiesUpdateArgs} args - Arguments to update one Page_histories.
     * @example
     * // Update one Page_histories
     * const page_histories = await prisma.page_histories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends page_historiesUpdateArgs>(args: SelectSubset<T, page_historiesUpdateArgs<ExtArgs>>): Prisma__page_historiesClient<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Page_histories.
     * @param {page_historiesDeleteManyArgs} args - Arguments to filter Page_histories to delete.
     * @example
     * // Delete a few Page_histories
     * const { count } = await prisma.page_histories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends page_historiesDeleteManyArgs>(args?: SelectSubset<T, page_historiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Page_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {page_historiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Page_histories
     * const page_histories = await prisma.page_histories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends page_historiesUpdateManyArgs>(args: SelectSubset<T, page_historiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Page_histories.
     * @param {page_historiesUpsertArgs} args - Arguments to update or create a Page_histories.
     * @example
     * // Update or create a Page_histories
     * const page_histories = await prisma.page_histories.upsert({
     *   create: {
     *     // ... data to create a Page_histories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page_histories we want to update
     *   }
     * })
     */
    upsert<T extends page_historiesUpsertArgs>(args: SelectSubset<T, page_historiesUpsertArgs<ExtArgs>>): Prisma__page_historiesClient<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Page_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {page_historiesCountArgs} args - Arguments to filter Page_histories to count.
     * @example
     * // Count the number of Page_histories
     * const count = await prisma.page_histories.count({
     *   where: {
     *     // ... the filter for the Page_histories we want to count
     *   }
     * })
    **/
    count<T extends page_historiesCountArgs>(
      args?: Subset<T, page_historiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Page_historiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Page_historiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Page_historiesAggregateArgs>(args: Subset<T, Page_historiesAggregateArgs>): Prisma.PrismaPromise<GetPage_historiesAggregateType<T>>

    /**
     * Group by Page_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {page_historiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends page_historiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: page_historiesGroupByArgs['orderBy'] }
        : { orderBy?: page_historiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, page_historiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPage_historiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the page_histories model
   */
  readonly fields: page_historiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for page_histories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__page_historiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pages<T extends pagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pagesDefaultArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the page_histories model
   */ 
  interface page_historiesFieldRefs {
    readonly Id: FieldRef<"page_histories", 'String'>
    readonly PageId: FieldRef<"page_histories", 'String'>
    readonly Html: FieldRef<"page_histories", 'String'>
    readonly Css: FieldRef<"page_histories", 'String'>
    readonly Content: FieldRef<"page_histories", 'String'>
    readonly Template: FieldRef<"page_histories", 'String'>
    readonly Version: FieldRef<"page_histories", 'Int'>
    readonly CreatedAt: FieldRef<"page_histories", 'DateTime'>
    readonly CreatedBy: FieldRef<"page_histories", 'String'>
    readonly deleted_at: FieldRef<"page_histories", 'DateTime'>
    readonly deleted_by: FieldRef<"page_histories", 'String'>
    readonly is_deleted: FieldRef<"page_histories", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * page_histories findUnique
   */
  export type page_historiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    /**
     * Filter, which page_histories to fetch.
     */
    where: page_historiesWhereUniqueInput
  }

  /**
   * page_histories findUniqueOrThrow
   */
  export type page_historiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    /**
     * Filter, which page_histories to fetch.
     */
    where: page_historiesWhereUniqueInput
  }

  /**
   * page_histories findFirst
   */
  export type page_historiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    /**
     * Filter, which page_histories to fetch.
     */
    where?: page_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of page_histories to fetch.
     */
    orderBy?: page_historiesOrderByWithRelationInput | page_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for page_histories.
     */
    cursor?: page_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` page_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` page_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of page_histories.
     */
    distinct?: Page_historiesScalarFieldEnum | Page_historiesScalarFieldEnum[]
  }

  /**
   * page_histories findFirstOrThrow
   */
  export type page_historiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    /**
     * Filter, which page_histories to fetch.
     */
    where?: page_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of page_histories to fetch.
     */
    orderBy?: page_historiesOrderByWithRelationInput | page_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for page_histories.
     */
    cursor?: page_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` page_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` page_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of page_histories.
     */
    distinct?: Page_historiesScalarFieldEnum | Page_historiesScalarFieldEnum[]
  }

  /**
   * page_histories findMany
   */
  export type page_historiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    /**
     * Filter, which page_histories to fetch.
     */
    where?: page_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of page_histories to fetch.
     */
    orderBy?: page_historiesOrderByWithRelationInput | page_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing page_histories.
     */
    cursor?: page_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` page_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` page_histories.
     */
    skip?: number
    distinct?: Page_historiesScalarFieldEnum | Page_historiesScalarFieldEnum[]
  }

  /**
   * page_histories create
   */
  export type page_historiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    /**
     * The data needed to create a page_histories.
     */
    data: XOR<page_historiesCreateInput, page_historiesUncheckedCreateInput>
  }

  /**
   * page_histories createMany
   */
  export type page_historiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many page_histories.
     */
    data: page_historiesCreateManyInput | page_historiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * page_histories createManyAndReturn
   */
  export type page_historiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many page_histories.
     */
    data: page_historiesCreateManyInput | page_historiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * page_histories update
   */
  export type page_historiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    /**
     * The data needed to update a page_histories.
     */
    data: XOR<page_historiesUpdateInput, page_historiesUncheckedUpdateInput>
    /**
     * Choose, which page_histories to update.
     */
    where: page_historiesWhereUniqueInput
  }

  /**
   * page_histories updateMany
   */
  export type page_historiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update page_histories.
     */
    data: XOR<page_historiesUpdateManyMutationInput, page_historiesUncheckedUpdateManyInput>
    /**
     * Filter which page_histories to update
     */
    where?: page_historiesWhereInput
  }

  /**
   * page_histories upsert
   */
  export type page_historiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    /**
     * The filter to search for the page_histories to update in case it exists.
     */
    where: page_historiesWhereUniqueInput
    /**
     * In case the page_histories found by the `where` argument doesn't exist, create a new page_histories with this data.
     */
    create: XOR<page_historiesCreateInput, page_historiesUncheckedCreateInput>
    /**
     * In case the page_histories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<page_historiesUpdateInput, page_historiesUncheckedUpdateInput>
  }

  /**
   * page_histories delete
   */
  export type page_historiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    /**
     * Filter which page_histories to delete.
     */
    where: page_historiesWhereUniqueInput
  }

  /**
   * page_histories deleteMany
   */
  export type page_historiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which page_histories to delete
     */
    where?: page_historiesWhereInput
  }

  /**
   * page_histories without action
   */
  export type page_historiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
  }


  /**
   * Model pages
   */

  export type AggregatePages = {
    _count: PagesCountAggregateOutputType | null
    _avg: PagesAvgAggregateOutputType | null
    _sum: PagesSumAggregateOutputType | null
    _min: PagesMinAggregateOutputType | null
    _max: PagesMaxAggregateOutputType | null
  }

  export type PagesAvgAggregateOutputType = {
    Version: number | null
  }

  export type PagesSumAggregateOutputType = {
    Version: number | null
  }

  export type PagesMinAggregateOutputType = {
    Id: string | null
    TenantId: string | null
    Slug: string | null
    Title: string | null
    Html: string | null
    Css: string | null
    Content: string | null
    Template: string | null
    IsPublished: boolean | null
    PublishedAt: Date | null
    Version: number | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type PagesMaxAggregateOutputType = {
    Id: string | null
    TenantId: string | null
    Slug: string | null
    Title: string | null
    Html: string | null
    Css: string | null
    Content: string | null
    Template: string | null
    IsPublished: boolean | null
    PublishedAt: Date | null
    Version: number | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type PagesCountAggregateOutputType = {
    Id: number
    TenantId: number
    Slug: number
    Title: number
    Html: number
    Css: number
    Content: number
    Template: number
    IsPublished: number
    PublishedAt: number
    Version: number
    CreatedAt: number
    UpdatedAt: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type PagesAvgAggregateInputType = {
    Version?: true
  }

  export type PagesSumAggregateInputType = {
    Version?: true
  }

  export type PagesMinAggregateInputType = {
    Id?: true
    TenantId?: true
    Slug?: true
    Title?: true
    Html?: true
    Css?: true
    Content?: true
    Template?: true
    IsPublished?: true
    PublishedAt?: true
    Version?: true
    CreatedAt?: true
    UpdatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type PagesMaxAggregateInputType = {
    Id?: true
    TenantId?: true
    Slug?: true
    Title?: true
    Html?: true
    Css?: true
    Content?: true
    Template?: true
    IsPublished?: true
    PublishedAt?: true
    Version?: true
    CreatedAt?: true
    UpdatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type PagesCountAggregateInputType = {
    Id?: true
    TenantId?: true
    Slug?: true
    Title?: true
    Html?: true
    Css?: true
    Content?: true
    Template?: true
    IsPublished?: true
    PublishedAt?: true
    Version?: true
    CreatedAt?: true
    UpdatedAt?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type PagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pages to aggregate.
     */
    where?: pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pages to fetch.
     */
    orderBy?: pagesOrderByWithRelationInput | pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pages
    **/
    _count?: true | PagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagesMaxAggregateInputType
  }

  export type GetPagesAggregateType<T extends PagesAggregateArgs> = {
        [P in keyof T & keyof AggregatePages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePages[P]>
      : GetScalarType<T[P], AggregatePages[P]>
  }




  export type pagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagesWhereInput
    orderBy?: pagesOrderByWithAggregationInput | pagesOrderByWithAggregationInput[]
    by: PagesScalarFieldEnum[] | PagesScalarFieldEnum
    having?: pagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagesCountAggregateInputType | true
    _avg?: PagesAvgAggregateInputType
    _sum?: PagesSumAggregateInputType
    _min?: PagesMinAggregateInputType
    _max?: PagesMaxAggregateInputType
  }

  export type PagesGroupByOutputType = {
    Id: string
    TenantId: string
    Slug: string
    Title: string
    Html: string | null
    Css: string | null
    Content: string | null
    Template: string | null
    IsPublished: boolean
    PublishedAt: Date | null
    Version: number
    CreatedAt: Date
    UpdatedAt: Date
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: PagesCountAggregateOutputType | null
    _avg: PagesAvgAggregateOutputType | null
    _sum: PagesSumAggregateOutputType | null
    _min: PagesMinAggregateOutputType | null
    _max: PagesMaxAggregateOutputType | null
  }

  type GetPagesGroupByPayload<T extends pagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagesGroupByOutputType[P]>
            : GetScalarType<T[P], PagesGroupByOutputType[P]>
        }
      >
    >


  export type pagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    TenantId?: boolean
    Slug?: boolean
    Title?: boolean
    Html?: boolean
    Css?: boolean
    Content?: boolean
    Template?: boolean
    IsPublished?: boolean
    PublishedAt?: boolean
    Version?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    page_histories?: boolean | pages$page_historiesArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | PagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pages"]>

  export type pagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    TenantId?: boolean
    Slug?: boolean
    Title?: boolean
    Html?: boolean
    Css?: boolean
    Content?: boolean
    Template?: boolean
    IsPublished?: boolean
    PublishedAt?: boolean
    Version?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pages"]>

  export type pagesSelectScalar = {
    Id?: boolean
    TenantId?: boolean
    Slug?: boolean
    Title?: boolean
    Html?: boolean
    Css?: boolean
    Content?: boolean
    Template?: boolean
    IsPublished?: boolean
    PublishedAt?: boolean
    Version?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type pagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page_histories?: boolean | pages$page_historiesArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | PagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type pagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $pagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pages"
    objects: {
      page_histories: Prisma.$page_historiesPayload<ExtArgs>[]
      Tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: string
      TenantId: string
      Slug: string
      Title: string
      Html: string | null
      Css: string | null
      Content: string | null
      Template: string | null
      IsPublished: boolean
      PublishedAt: Date | null
      Version: number
      CreatedAt: Date
      UpdatedAt: Date
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["pages"]>
    composites: {}
  }

  type pagesGetPayload<S extends boolean | null | undefined | pagesDefaultArgs> = $Result.GetResult<Prisma.$pagesPayload, S>

  type pagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagesCountAggregateInputType | true
    }

  export interface pagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pages'], meta: { name: 'pages' } }
    /**
     * Find zero or one Pages that matches the filter.
     * @param {pagesFindUniqueArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pagesFindUniqueArgs>(args: SelectSubset<T, pagesFindUniqueArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pages that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pagesFindUniqueOrThrowArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pagesFindUniqueOrThrowArgs>(args: SelectSubset<T, pagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesFindFirstArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pagesFindFirstArgs>(args?: SelectSubset<T, pagesFindFirstArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesFindFirstOrThrowArgs} args - Arguments to find a Pages
     * @example
     * // Get one Pages
     * const pages = await prisma.pages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pagesFindFirstOrThrowArgs>(args?: SelectSubset<T, pagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.pages.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.pages.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const pagesWithIdOnly = await prisma.pages.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends pagesFindManyArgs>(args?: SelectSubset<T, pagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pages.
     * @param {pagesCreateArgs} args - Arguments to create a Pages.
     * @example
     * // Create one Pages
     * const Pages = await prisma.pages.create({
     *   data: {
     *     // ... data to create a Pages
     *   }
     * })
     * 
     */
    create<T extends pagesCreateArgs>(args: SelectSubset<T, pagesCreateArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pages.
     * @param {pagesCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const pages = await prisma.pages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pagesCreateManyArgs>(args?: SelectSubset<T, pagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {pagesCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const pages = await prisma.pages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `Id`
     * const pagesWithIdOnly = await prisma.pages.createManyAndReturn({ 
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pagesCreateManyAndReturnArgs>(args?: SelectSubset<T, pagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pages.
     * @param {pagesDeleteArgs} args - Arguments to delete one Pages.
     * @example
     * // Delete one Pages
     * const Pages = await prisma.pages.delete({
     *   where: {
     *     // ... filter to delete one Pages
     *   }
     * })
     * 
     */
    delete<T extends pagesDeleteArgs>(args: SelectSubset<T, pagesDeleteArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pages.
     * @param {pagesUpdateArgs} args - Arguments to update one Pages.
     * @example
     * // Update one Pages
     * const pages = await prisma.pages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pagesUpdateArgs>(args: SelectSubset<T, pagesUpdateArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pages.
     * @param {pagesDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.pages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pagesDeleteManyArgs>(args?: SelectSubset<T, pagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const pages = await prisma.pages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pagesUpdateManyArgs>(args: SelectSubset<T, pagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pages.
     * @param {pagesUpsertArgs} args - Arguments to update or create a Pages.
     * @example
     * // Update or create a Pages
     * const pages = await prisma.pages.upsert({
     *   create: {
     *     // ... data to create a Pages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pages we want to update
     *   }
     * })
     */
    upsert<T extends pagesUpsertArgs>(args: SelectSubset<T, pagesUpsertArgs<ExtArgs>>): Prisma__pagesClient<$Result.GetResult<Prisma.$pagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.pages.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends pagesCountArgs>(
      args?: Subset<T, pagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagesAggregateArgs>(args: Subset<T, PagesAggregateArgs>): Prisma.PrismaPromise<GetPagesAggregateType<T>>

    /**
     * Group by Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pagesGroupByArgs['orderBy'] }
        : { orderBy?: pagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pages model
   */
  readonly fields: pagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    page_histories<T extends pages$page_historiesArgs<ExtArgs> = {}>(args?: Subset<T, pages$page_historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$page_historiesPayload<ExtArgs>, T, "findMany"> | Null>
    Tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pages model
   */ 
  interface pagesFieldRefs {
    readonly Id: FieldRef<"pages", 'String'>
    readonly TenantId: FieldRef<"pages", 'String'>
    readonly Slug: FieldRef<"pages", 'String'>
    readonly Title: FieldRef<"pages", 'String'>
    readonly Html: FieldRef<"pages", 'String'>
    readonly Css: FieldRef<"pages", 'String'>
    readonly Content: FieldRef<"pages", 'String'>
    readonly Template: FieldRef<"pages", 'String'>
    readonly IsPublished: FieldRef<"pages", 'Boolean'>
    readonly PublishedAt: FieldRef<"pages", 'DateTime'>
    readonly Version: FieldRef<"pages", 'Int'>
    readonly CreatedAt: FieldRef<"pages", 'DateTime'>
    readonly UpdatedAt: FieldRef<"pages", 'DateTime'>
    readonly deleted_at: FieldRef<"pages", 'DateTime'>
    readonly deleted_by: FieldRef<"pages", 'String'>
    readonly is_deleted: FieldRef<"pages", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * pages findUnique
   */
  export type pagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where: pagesWhereUniqueInput
  }

  /**
   * pages findUniqueOrThrow
   */
  export type pagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where: pagesWhereUniqueInput
  }

  /**
   * pages findFirst
   */
  export type pagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where?: pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pages to fetch.
     */
    orderBy?: pagesOrderByWithRelationInput | pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pages.
     */
    cursor?: pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pages.
     */
    distinct?: PagesScalarFieldEnum | PagesScalarFieldEnum[]
  }

  /**
   * pages findFirstOrThrow
   */
  export type pagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where?: pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pages to fetch.
     */
    orderBy?: pagesOrderByWithRelationInput | pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pages.
     */
    cursor?: pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pages.
     */
    distinct?: PagesScalarFieldEnum | PagesScalarFieldEnum[]
  }

  /**
   * pages findMany
   */
  export type pagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    /**
     * Filter, which pages to fetch.
     */
    where?: pagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pages to fetch.
     */
    orderBy?: pagesOrderByWithRelationInput | pagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pages.
     */
    cursor?: pagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pages.
     */
    skip?: number
    distinct?: PagesScalarFieldEnum | PagesScalarFieldEnum[]
  }

  /**
   * pages create
   */
  export type pagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    /**
     * The data needed to create a pages.
     */
    data: XOR<pagesCreateInput, pagesUncheckedCreateInput>
  }

  /**
   * pages createMany
   */
  export type pagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pages.
     */
    data: pagesCreateManyInput | pagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pages createManyAndReturn
   */
  export type pagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many pages.
     */
    data: pagesCreateManyInput | pagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pages update
   */
  export type pagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    /**
     * The data needed to update a pages.
     */
    data: XOR<pagesUpdateInput, pagesUncheckedUpdateInput>
    /**
     * Choose, which pages to update.
     */
    where: pagesWhereUniqueInput
  }

  /**
   * pages updateMany
   */
  export type pagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pages.
     */
    data: XOR<pagesUpdateManyMutationInput, pagesUncheckedUpdateManyInput>
    /**
     * Filter which pages to update
     */
    where?: pagesWhereInput
  }

  /**
   * pages upsert
   */
  export type pagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    /**
     * The filter to search for the pages to update in case it exists.
     */
    where: pagesWhereUniqueInput
    /**
     * In case the pages found by the `where` argument doesn't exist, create a new pages with this data.
     */
    create: XOR<pagesCreateInput, pagesUncheckedCreateInput>
    /**
     * In case the pages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pagesUpdateInput, pagesUncheckedUpdateInput>
  }

  /**
   * pages delete
   */
  export type pagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
    /**
     * Filter which pages to delete.
     */
    where: pagesWhereUniqueInput
  }

  /**
   * pages deleteMany
   */
  export type pagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pages to delete
     */
    where?: pagesWhereInput
  }

  /**
   * pages.page_histories
   */
  export type pages$page_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the page_histories
     */
    select?: page_historiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: page_historiesInclude<ExtArgs> | null
    where?: page_historiesWhereInput
    orderBy?: page_historiesOrderByWithRelationInput | page_historiesOrderByWithRelationInput[]
    cursor?: page_historiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Page_historiesScalarFieldEnum | Page_historiesScalarFieldEnum[]
  }

  /**
   * pages without action
   */
  export type pagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pages
     */
    select?: pagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagesInclude<ExtArgs> | null
  }


  /**
   * Model reservations
   */

  export type AggregateReservations = {
    _count: ReservationsCountAggregateOutputType | null
    _avg: ReservationsAvgAggregateOutputType | null
    _sum: ReservationsSumAggregateOutputType | null
    _min: ReservationsMinAggregateOutputType | null
    _max: ReservationsMaxAggregateOutputType | null
  }

  export type ReservationsAvgAggregateOutputType = {
    adult_count: number | null
    child_count: number | null
    total_amount: Decimal | null
    deposit_amount: Decimal | null
  }

  export type ReservationsSumAggregateOutputType = {
    adult_count: number | null
    child_count: number | null
    total_amount: Decimal | null
    deposit_amount: Decimal | null
  }

  export type ReservationsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    customer_id: string | null
    guest_name: string | null
    guest_phone: string | null
    guest_email: string | null
    checkin_date: Date | null
    checkout_date: Date | null
    adult_count: number | null
    child_count: number | null
    room_type: string | null
    room_number: string | null
    total_amount: Decimal | null
    deposit_amount: Decimal | null
    status: string | null
    origin: string | null
    ota_id: string | null
    confirmation_number: string | null
    special_requests: string | null
    internal_notes: string | null
    origin_system: string | null
    synced_at: Date | null
    updated_by_system: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    is_deleted: boolean | null
    deleted_by: string | null
  }

  export type ReservationsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    customer_id: string | null
    guest_name: string | null
    guest_phone: string | null
    guest_email: string | null
    checkin_date: Date | null
    checkout_date: Date | null
    adult_count: number | null
    child_count: number | null
    room_type: string | null
    room_number: string | null
    total_amount: Decimal | null
    deposit_amount: Decimal | null
    status: string | null
    origin: string | null
    ota_id: string | null
    confirmation_number: string | null
    special_requests: string | null
    internal_notes: string | null
    origin_system: string | null
    synced_at: Date | null
    updated_by_system: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    is_deleted: boolean | null
    deleted_by: string | null
  }

  export type ReservationsCountAggregateOutputType = {
    id: number
    tenant_id: number
    customer_id: number
    guest_name: number
    guest_phone: number
    guest_email: number
    checkin_date: number
    checkout_date: number
    adult_count: number
    child_count: number
    room_type: number
    room_number: number
    total_amount: number
    deposit_amount: number
    status: number
    origin: number
    ota_id: number
    confirmation_number: number
    special_requests: number
    internal_notes: number
    origin_system: number
    synced_at: number
    updated_by_system: number
    created_at: number
    updated_at: number
    deleted_at: number
    is_deleted: number
    deleted_by: number
    _all: number
  }


  export type ReservationsAvgAggregateInputType = {
    adult_count?: true
    child_count?: true
    total_amount?: true
    deposit_amount?: true
  }

  export type ReservationsSumAggregateInputType = {
    adult_count?: true
    child_count?: true
    total_amount?: true
    deposit_amount?: true
  }

  export type ReservationsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    customer_id?: true
    guest_name?: true
    guest_phone?: true
    guest_email?: true
    checkin_date?: true
    checkout_date?: true
    adult_count?: true
    child_count?: true
    room_type?: true
    room_number?: true
    total_amount?: true
    deposit_amount?: true
    status?: true
    origin?: true
    ota_id?: true
    confirmation_number?: true
    special_requests?: true
    internal_notes?: true
    origin_system?: true
    synced_at?: true
    updated_by_system?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    is_deleted?: true
    deleted_by?: true
  }

  export type ReservationsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    customer_id?: true
    guest_name?: true
    guest_phone?: true
    guest_email?: true
    checkin_date?: true
    checkout_date?: true
    adult_count?: true
    child_count?: true
    room_type?: true
    room_number?: true
    total_amount?: true
    deposit_amount?: true
    status?: true
    origin?: true
    ota_id?: true
    confirmation_number?: true
    special_requests?: true
    internal_notes?: true
    origin_system?: true
    synced_at?: true
    updated_by_system?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    is_deleted?: true
    deleted_by?: true
  }

  export type ReservationsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    customer_id?: true
    guest_name?: true
    guest_phone?: true
    guest_email?: true
    checkin_date?: true
    checkout_date?: true
    adult_count?: true
    child_count?: true
    room_type?: true
    room_number?: true
    total_amount?: true
    deposit_amount?: true
    status?: true
    origin?: true
    ota_id?: true
    confirmation_number?: true
    special_requests?: true
    internal_notes?: true
    origin_system?: true
    synced_at?: true
    updated_by_system?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    is_deleted?: true
    deleted_by?: true
    _all?: true
  }

  export type ReservationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reservations to aggregate.
     */
    where?: reservationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: reservationsOrderByWithRelationInput | reservationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reservationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reservations
    **/
    _count?: true | ReservationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationsMaxAggregateInputType
  }

  export type GetReservationsAggregateType<T extends ReservationsAggregateArgs> = {
        [P in keyof T & keyof AggregateReservations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservations[P]>
      : GetScalarType<T[P], AggregateReservations[P]>
  }




  export type reservationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reservationsWhereInput
    orderBy?: reservationsOrderByWithAggregationInput | reservationsOrderByWithAggregationInput[]
    by: ReservationsScalarFieldEnum[] | ReservationsScalarFieldEnum
    having?: reservationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationsCountAggregateInputType | true
    _avg?: ReservationsAvgAggregateInputType
    _sum?: ReservationsSumAggregateInputType
    _min?: ReservationsMinAggregateInputType
    _max?: ReservationsMaxAggregateInputType
  }

  export type ReservationsGroupByOutputType = {
    id: string
    tenant_id: string
    customer_id: string | null
    guest_name: string
    guest_phone: string | null
    guest_email: string | null
    checkin_date: Date
    checkout_date: Date
    adult_count: number
    child_count: number
    room_type: string
    room_number: string | null
    total_amount: Decimal
    deposit_amount: Decimal
    status: string
    origin: string
    ota_id: string | null
    confirmation_number: string
    special_requests: string | null
    internal_notes: string | null
    origin_system: string
    synced_at: Date
    updated_by_system: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    is_deleted: boolean
    deleted_by: string | null
    _count: ReservationsCountAggregateOutputType | null
    _avg: ReservationsAvgAggregateOutputType | null
    _sum: ReservationsSumAggregateOutputType | null
    _min: ReservationsMinAggregateOutputType | null
    _max: ReservationsMaxAggregateOutputType | null
  }

  type GetReservationsGroupByPayload<T extends reservationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationsGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationsGroupByOutputType[P]>
        }
      >
    >


  export type reservationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    customer_id?: boolean
    guest_name?: boolean
    guest_phone?: boolean
    guest_email?: boolean
    checkin_date?: boolean
    checkout_date?: boolean
    adult_count?: boolean
    child_count?: boolean
    room_type?: boolean
    room_number?: boolean
    total_amount?: boolean
    deposit_amount?: boolean
    status?: boolean
    origin?: boolean
    ota_id?: boolean
    confirmation_number?: boolean
    special_requests?: boolean
    internal_notes?: boolean
    origin_system?: boolean
    synced_at?: boolean
    updated_by_system?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    deleted_by?: boolean
    customers?: boolean | reservations$customersArgs<ExtArgs>
  }, ExtArgs["result"]["reservations"]>

  export type reservationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    customer_id?: boolean
    guest_name?: boolean
    guest_phone?: boolean
    guest_email?: boolean
    checkin_date?: boolean
    checkout_date?: boolean
    adult_count?: boolean
    child_count?: boolean
    room_type?: boolean
    room_number?: boolean
    total_amount?: boolean
    deposit_amount?: boolean
    status?: boolean
    origin?: boolean
    ota_id?: boolean
    confirmation_number?: boolean
    special_requests?: boolean
    internal_notes?: boolean
    origin_system?: boolean
    synced_at?: boolean
    updated_by_system?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    deleted_by?: boolean
    customers?: boolean | reservations$customersArgs<ExtArgs>
  }, ExtArgs["result"]["reservations"]>

  export type reservationsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    customer_id?: boolean
    guest_name?: boolean
    guest_phone?: boolean
    guest_email?: boolean
    checkin_date?: boolean
    checkout_date?: boolean
    adult_count?: boolean
    child_count?: boolean
    room_type?: boolean
    room_number?: boolean
    total_amount?: boolean
    deposit_amount?: boolean
    status?: boolean
    origin?: boolean
    ota_id?: boolean
    confirmation_number?: boolean
    special_requests?: boolean
    internal_notes?: boolean
    origin_system?: boolean
    synced_at?: boolean
    updated_by_system?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    is_deleted?: boolean
    deleted_by?: boolean
  }

  export type reservationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | reservations$customersArgs<ExtArgs>
  }
  export type reservationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | reservations$customersArgs<ExtArgs>
  }

  export type $reservationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reservations"
    objects: {
      customers: Prisma.$customersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      customer_id: string | null
      guest_name: string
      guest_phone: string | null
      guest_email: string | null
      checkin_date: Date
      checkout_date: Date
      adult_count: number
      child_count: number
      room_type: string
      room_number: string | null
      total_amount: Prisma.Decimal
      deposit_amount: Prisma.Decimal
      status: string
      origin: string
      ota_id: string | null
      confirmation_number: string
      special_requests: string | null
      internal_notes: string | null
      origin_system: string
      synced_at: Date
      updated_by_system: string
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
      is_deleted: boolean
      deleted_by: string | null
    }, ExtArgs["result"]["reservations"]>
    composites: {}
  }

  type reservationsGetPayload<S extends boolean | null | undefined | reservationsDefaultArgs> = $Result.GetResult<Prisma.$reservationsPayload, S>

  type reservationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reservationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReservationsCountAggregateInputType | true
    }

  export interface reservationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reservations'], meta: { name: 'reservations' } }
    /**
     * Find zero or one Reservations that matches the filter.
     * @param {reservationsFindUniqueArgs} args - Arguments to find a Reservations
     * @example
     * // Get one Reservations
     * const reservations = await prisma.reservations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reservationsFindUniqueArgs>(args: SelectSubset<T, reservationsFindUniqueArgs<ExtArgs>>): Prisma__reservationsClient<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reservations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {reservationsFindUniqueOrThrowArgs} args - Arguments to find a Reservations
     * @example
     * // Get one Reservations
     * const reservations = await prisma.reservations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reservationsFindUniqueOrThrowArgs>(args: SelectSubset<T, reservationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reservationsClient<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsFindFirstArgs} args - Arguments to find a Reservations
     * @example
     * // Get one Reservations
     * const reservations = await prisma.reservations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reservationsFindFirstArgs>(args?: SelectSubset<T, reservationsFindFirstArgs<ExtArgs>>): Prisma__reservationsClient<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reservations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsFindFirstOrThrowArgs} args - Arguments to find a Reservations
     * @example
     * // Get one Reservations
     * const reservations = await prisma.reservations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reservationsFindFirstOrThrowArgs>(args?: SelectSubset<T, reservationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reservationsClient<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservations.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationsWithIdOnly = await prisma.reservations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reservationsFindManyArgs>(args?: SelectSubset<T, reservationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reservations.
     * @param {reservationsCreateArgs} args - Arguments to create a Reservations.
     * @example
     * // Create one Reservations
     * const Reservations = await prisma.reservations.create({
     *   data: {
     *     // ... data to create a Reservations
     *   }
     * })
     * 
     */
    create<T extends reservationsCreateArgs>(args: SelectSubset<T, reservationsCreateArgs<ExtArgs>>): Prisma__reservationsClient<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reservations.
     * @param {reservationsCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservations = await prisma.reservations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reservationsCreateManyArgs>(args?: SelectSubset<T, reservationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {reservationsCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservations = await prisma.reservations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationsWithIdOnly = await prisma.reservations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reservationsCreateManyAndReturnArgs>(args?: SelectSubset<T, reservationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reservations.
     * @param {reservationsDeleteArgs} args - Arguments to delete one Reservations.
     * @example
     * // Delete one Reservations
     * const Reservations = await prisma.reservations.delete({
     *   where: {
     *     // ... filter to delete one Reservations
     *   }
     * })
     * 
     */
    delete<T extends reservationsDeleteArgs>(args: SelectSubset<T, reservationsDeleteArgs<ExtArgs>>): Prisma__reservationsClient<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reservations.
     * @param {reservationsUpdateArgs} args - Arguments to update one Reservations.
     * @example
     * // Update one Reservations
     * const reservations = await prisma.reservations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reservationsUpdateArgs>(args: SelectSubset<T, reservationsUpdateArgs<ExtArgs>>): Prisma__reservationsClient<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reservations.
     * @param {reservationsDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reservationsDeleteManyArgs>(args?: SelectSubset<T, reservationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservations = await prisma.reservations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reservationsUpdateManyArgs>(args: SelectSubset<T, reservationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservations.
     * @param {reservationsUpsertArgs} args - Arguments to update or create a Reservations.
     * @example
     * // Update or create a Reservations
     * const reservations = await prisma.reservations.upsert({
     *   create: {
     *     // ... data to create a Reservations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservations we want to update
     *   }
     * })
     */
    upsert<T extends reservationsUpsertArgs>(args: SelectSubset<T, reservationsUpsertArgs<ExtArgs>>): Prisma__reservationsClient<$Result.GetResult<Prisma.$reservationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservations.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends reservationsCountArgs>(
      args?: Subset<T, reservationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationsAggregateArgs>(args: Subset<T, ReservationsAggregateArgs>): Prisma.PrismaPromise<GetReservationsAggregateType<T>>

    /**
     * Group by Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reservationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reservationsGroupByArgs['orderBy'] }
        : { orderBy?: reservationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reservationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reservations model
   */
  readonly fields: reservationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reservations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reservationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends reservations$customersArgs<ExtArgs> = {}>(args?: Subset<T, reservations$customersArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reservations model
   */ 
  interface reservationsFieldRefs {
    readonly id: FieldRef<"reservations", 'String'>
    readonly tenant_id: FieldRef<"reservations", 'String'>
    readonly customer_id: FieldRef<"reservations", 'String'>
    readonly guest_name: FieldRef<"reservations", 'String'>
    readonly guest_phone: FieldRef<"reservations", 'String'>
    readonly guest_email: FieldRef<"reservations", 'String'>
    readonly checkin_date: FieldRef<"reservations", 'DateTime'>
    readonly checkout_date: FieldRef<"reservations", 'DateTime'>
    readonly adult_count: FieldRef<"reservations", 'Int'>
    readonly child_count: FieldRef<"reservations", 'Int'>
    readonly room_type: FieldRef<"reservations", 'String'>
    readonly room_number: FieldRef<"reservations", 'String'>
    readonly total_amount: FieldRef<"reservations", 'Decimal'>
    readonly deposit_amount: FieldRef<"reservations", 'Decimal'>
    readonly status: FieldRef<"reservations", 'String'>
    readonly origin: FieldRef<"reservations", 'String'>
    readonly ota_id: FieldRef<"reservations", 'String'>
    readonly confirmation_number: FieldRef<"reservations", 'String'>
    readonly special_requests: FieldRef<"reservations", 'String'>
    readonly internal_notes: FieldRef<"reservations", 'String'>
    readonly origin_system: FieldRef<"reservations", 'String'>
    readonly synced_at: FieldRef<"reservations", 'DateTime'>
    readonly updated_by_system: FieldRef<"reservations", 'String'>
    readonly created_at: FieldRef<"reservations", 'DateTime'>
    readonly updated_at: FieldRef<"reservations", 'DateTime'>
    readonly deleted_at: FieldRef<"reservations", 'DateTime'>
    readonly is_deleted: FieldRef<"reservations", 'Boolean'>
    readonly deleted_by: FieldRef<"reservations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * reservations findUnique
   */
  export type reservationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    /**
     * Filter, which reservations to fetch.
     */
    where: reservationsWhereUniqueInput
  }

  /**
   * reservations findUniqueOrThrow
   */
  export type reservationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    /**
     * Filter, which reservations to fetch.
     */
    where: reservationsWhereUniqueInput
  }

  /**
   * reservations findFirst
   */
  export type reservationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    /**
     * Filter, which reservations to fetch.
     */
    where?: reservationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: reservationsOrderByWithRelationInput | reservationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservations.
     */
    cursor?: reservationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservations.
     */
    distinct?: ReservationsScalarFieldEnum | ReservationsScalarFieldEnum[]
  }

  /**
   * reservations findFirstOrThrow
   */
  export type reservationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    /**
     * Filter, which reservations to fetch.
     */
    where?: reservationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: reservationsOrderByWithRelationInput | reservationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservations.
     */
    cursor?: reservationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservations.
     */
    distinct?: ReservationsScalarFieldEnum | ReservationsScalarFieldEnum[]
  }

  /**
   * reservations findMany
   */
  export type reservationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    /**
     * Filter, which reservations to fetch.
     */
    where?: reservationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     */
    orderBy?: reservationsOrderByWithRelationInput | reservationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reservations.
     */
    cursor?: reservationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     */
    skip?: number
    distinct?: ReservationsScalarFieldEnum | ReservationsScalarFieldEnum[]
  }

  /**
   * reservations create
   */
  export type reservationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    /**
     * The data needed to create a reservations.
     */
    data: XOR<reservationsCreateInput, reservationsUncheckedCreateInput>
  }

  /**
   * reservations createMany
   */
  export type reservationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reservations.
     */
    data: reservationsCreateManyInput | reservationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reservations createManyAndReturn
   */
  export type reservationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many reservations.
     */
    data: reservationsCreateManyInput | reservationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reservations update
   */
  export type reservationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    /**
     * The data needed to update a reservations.
     */
    data: XOR<reservationsUpdateInput, reservationsUncheckedUpdateInput>
    /**
     * Choose, which reservations to update.
     */
    where: reservationsWhereUniqueInput
  }

  /**
   * reservations updateMany
   */
  export type reservationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reservations.
     */
    data: XOR<reservationsUpdateManyMutationInput, reservationsUncheckedUpdateManyInput>
    /**
     * Filter which reservations to update
     */
    where?: reservationsWhereInput
  }

  /**
   * reservations upsert
   */
  export type reservationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    /**
     * The filter to search for the reservations to update in case it exists.
     */
    where: reservationsWhereUniqueInput
    /**
     * In case the reservations found by the `where` argument doesn't exist, create a new reservations with this data.
     */
    create: XOR<reservationsCreateInput, reservationsUncheckedCreateInput>
    /**
     * In case the reservations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reservationsUpdateInput, reservationsUncheckedUpdateInput>
  }

  /**
   * reservations delete
   */
  export type reservationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
    /**
     * Filter which reservations to delete.
     */
    where: reservationsWhereUniqueInput
  }

  /**
   * reservations deleteMany
   */
  export type reservationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reservations to delete
     */
    where?: reservationsWhereInput
  }

  /**
   * reservations.customers
   */
  export type reservations$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    where?: customersWhereInput
  }

  /**
   * reservations without action
   */
  export type reservationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reservations
     */
    select?: reservationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reservationsInclude<ExtArgs> | null
  }


  /**
   * Model response_node_translations
   */

  export type AggregateResponse_node_translations = {
    _count: Response_node_translationsCountAggregateOutputType | null
    _min: Response_node_translationsMinAggregateOutputType | null
    _max: Response_node_translationsMaxAggregateOutputType | null
  }

  export type Response_node_translationsMinAggregateOutputType = {
    id: string | null
    nodeId: string | null
    locale: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    language: string | null
    title: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Response_node_translationsMaxAggregateOutputType = {
    id: string | null
    nodeId: string | null
    locale: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    language: string | null
    title: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Response_node_translationsCountAggregateOutputType = {
    id: number
    nodeId: number
    locale: number
    content: number
    createdAt: number
    updatedAt: number
    answer: number
    language: number
    title: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Response_node_translationsMinAggregateInputType = {
    id?: true
    nodeId?: true
    locale?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    language?: true
    title?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Response_node_translationsMaxAggregateInputType = {
    id?: true
    nodeId?: true
    locale?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    language?: true
    title?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Response_node_translationsCountAggregateInputType = {
    id?: true
    nodeId?: true
    locale?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    answer?: true
    language?: true
    title?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Response_node_translationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_node_translations to aggregate.
     */
    where?: response_node_translationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_node_translations to fetch.
     */
    orderBy?: response_node_translationsOrderByWithRelationInput | response_node_translationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: response_node_translationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_node_translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_node_translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned response_node_translations
    **/
    _count?: true | Response_node_translationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Response_node_translationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Response_node_translationsMaxAggregateInputType
  }

  export type GetResponse_node_translationsAggregateType<T extends Response_node_translationsAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse_node_translations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse_node_translations[P]>
      : GetScalarType<T[P], AggregateResponse_node_translations[P]>
  }




  export type response_node_translationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_node_translationsWhereInput
    orderBy?: response_node_translationsOrderByWithAggregationInput | response_node_translationsOrderByWithAggregationInput[]
    by: Response_node_translationsScalarFieldEnum[] | Response_node_translationsScalarFieldEnum
    having?: response_node_translationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Response_node_translationsCountAggregateInputType | true
    _min?: Response_node_translationsMinAggregateInputType
    _max?: Response_node_translationsMaxAggregateInputType
  }

  export type Response_node_translationsGroupByOutputType = {
    id: string
    nodeId: string
    locale: string
    content: string | null
    createdAt: Date
    updatedAt: Date
    answer: JsonValue | null
    language: string | null
    title: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Response_node_translationsCountAggregateOutputType | null
    _min: Response_node_translationsMinAggregateOutputType | null
    _max: Response_node_translationsMaxAggregateOutputType | null
  }

  type GetResponse_node_translationsGroupByPayload<T extends response_node_translationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Response_node_translationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Response_node_translationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Response_node_translationsGroupByOutputType[P]>
            : GetScalarType<T[P], Response_node_translationsGroupByOutputType[P]>
        }
      >
    >


  export type response_node_translationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    locale?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answer?: boolean
    language?: boolean
    title?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    response_nodes?: boolean | response_nodesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_node_translations"]>

  export type response_node_translationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    locale?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answer?: boolean
    language?: boolean
    title?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    response_nodes?: boolean | response_nodesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_node_translations"]>

  export type response_node_translationsSelectScalar = {
    id?: boolean
    nodeId?: boolean
    locale?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answer?: boolean
    language?: boolean
    title?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type response_node_translationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_nodes?: boolean | response_nodesDefaultArgs<ExtArgs>
  }
  export type response_node_translationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_nodes?: boolean | response_nodesDefaultArgs<ExtArgs>
  }

  export type $response_node_translationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "response_node_translations"
    objects: {
      response_nodes: Prisma.$response_nodesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeId: string
      locale: string
      content: string | null
      createdAt: Date
      updatedAt: Date
      answer: Prisma.JsonValue | null
      language: string | null
      title: string | null
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["response_node_translations"]>
    composites: {}
  }

  type response_node_translationsGetPayload<S extends boolean | null | undefined | response_node_translationsDefaultArgs> = $Result.GetResult<Prisma.$response_node_translationsPayload, S>

  type response_node_translationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<response_node_translationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Response_node_translationsCountAggregateInputType | true
    }

  export interface response_node_translationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['response_node_translations'], meta: { name: 'response_node_translations' } }
    /**
     * Find zero or one Response_node_translations that matches the filter.
     * @param {response_node_translationsFindUniqueArgs} args - Arguments to find a Response_node_translations
     * @example
     * // Get one Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends response_node_translationsFindUniqueArgs>(args: SelectSubset<T, response_node_translationsFindUniqueArgs<ExtArgs>>): Prisma__response_node_translationsClient<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Response_node_translations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {response_node_translationsFindUniqueOrThrowArgs} args - Arguments to find a Response_node_translations
     * @example
     * // Get one Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends response_node_translationsFindUniqueOrThrowArgs>(args: SelectSubset<T, response_node_translationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__response_node_translationsClient<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Response_node_translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_node_translationsFindFirstArgs} args - Arguments to find a Response_node_translations
     * @example
     * // Get one Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends response_node_translationsFindFirstArgs>(args?: SelectSubset<T, response_node_translationsFindFirstArgs<ExtArgs>>): Prisma__response_node_translationsClient<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Response_node_translations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_node_translationsFindFirstOrThrowArgs} args - Arguments to find a Response_node_translations
     * @example
     * // Get one Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends response_node_translationsFindFirstOrThrowArgs>(args?: SelectSubset<T, response_node_translationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__response_node_translationsClient<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Response_node_translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_node_translationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.findMany()
     * 
     * // Get first 10 Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const response_node_translationsWithIdOnly = await prisma.response_node_translations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends response_node_translationsFindManyArgs>(args?: SelectSubset<T, response_node_translationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Response_node_translations.
     * @param {response_node_translationsCreateArgs} args - Arguments to create a Response_node_translations.
     * @example
     * // Create one Response_node_translations
     * const Response_node_translations = await prisma.response_node_translations.create({
     *   data: {
     *     // ... data to create a Response_node_translations
     *   }
     * })
     * 
     */
    create<T extends response_node_translationsCreateArgs>(args: SelectSubset<T, response_node_translationsCreateArgs<ExtArgs>>): Prisma__response_node_translationsClient<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Response_node_translations.
     * @param {response_node_translationsCreateManyArgs} args - Arguments to create many Response_node_translations.
     * @example
     * // Create many Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends response_node_translationsCreateManyArgs>(args?: SelectSubset<T, response_node_translationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Response_node_translations and returns the data saved in the database.
     * @param {response_node_translationsCreateManyAndReturnArgs} args - Arguments to create many Response_node_translations.
     * @example
     * // Create many Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Response_node_translations and only return the `id`
     * const response_node_translationsWithIdOnly = await prisma.response_node_translations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends response_node_translationsCreateManyAndReturnArgs>(args?: SelectSubset<T, response_node_translationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Response_node_translations.
     * @param {response_node_translationsDeleteArgs} args - Arguments to delete one Response_node_translations.
     * @example
     * // Delete one Response_node_translations
     * const Response_node_translations = await prisma.response_node_translations.delete({
     *   where: {
     *     // ... filter to delete one Response_node_translations
     *   }
     * })
     * 
     */
    delete<T extends response_node_translationsDeleteArgs>(args: SelectSubset<T, response_node_translationsDeleteArgs<ExtArgs>>): Prisma__response_node_translationsClient<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Response_node_translations.
     * @param {response_node_translationsUpdateArgs} args - Arguments to update one Response_node_translations.
     * @example
     * // Update one Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends response_node_translationsUpdateArgs>(args: SelectSubset<T, response_node_translationsUpdateArgs<ExtArgs>>): Prisma__response_node_translationsClient<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Response_node_translations.
     * @param {response_node_translationsDeleteManyArgs} args - Arguments to filter Response_node_translations to delete.
     * @example
     * // Delete a few Response_node_translations
     * const { count } = await prisma.response_node_translations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends response_node_translationsDeleteManyArgs>(args?: SelectSubset<T, response_node_translationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Response_node_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_node_translationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends response_node_translationsUpdateManyArgs>(args: SelectSubset<T, response_node_translationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Response_node_translations.
     * @param {response_node_translationsUpsertArgs} args - Arguments to update or create a Response_node_translations.
     * @example
     * // Update or create a Response_node_translations
     * const response_node_translations = await prisma.response_node_translations.upsert({
     *   create: {
     *     // ... data to create a Response_node_translations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response_node_translations we want to update
     *   }
     * })
     */
    upsert<T extends response_node_translationsUpsertArgs>(args: SelectSubset<T, response_node_translationsUpsertArgs<ExtArgs>>): Prisma__response_node_translationsClient<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Response_node_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_node_translationsCountArgs} args - Arguments to filter Response_node_translations to count.
     * @example
     * // Count the number of Response_node_translations
     * const count = await prisma.response_node_translations.count({
     *   where: {
     *     // ... the filter for the Response_node_translations we want to count
     *   }
     * })
    **/
    count<T extends response_node_translationsCountArgs>(
      args?: Subset<T, response_node_translationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Response_node_translationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response_node_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Response_node_translationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Response_node_translationsAggregateArgs>(args: Subset<T, Response_node_translationsAggregateArgs>): Prisma.PrismaPromise<GetResponse_node_translationsAggregateType<T>>

    /**
     * Group by Response_node_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_node_translationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends response_node_translationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: response_node_translationsGroupByArgs['orderBy'] }
        : { orderBy?: response_node_translationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, response_node_translationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponse_node_translationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the response_node_translations model
   */
  readonly fields: response_node_translationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for response_node_translations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__response_node_translationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response_nodes<T extends response_nodesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, response_nodesDefaultArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the response_node_translations model
   */ 
  interface response_node_translationsFieldRefs {
    readonly id: FieldRef<"response_node_translations", 'String'>
    readonly nodeId: FieldRef<"response_node_translations", 'String'>
    readonly locale: FieldRef<"response_node_translations", 'String'>
    readonly content: FieldRef<"response_node_translations", 'String'>
    readonly createdAt: FieldRef<"response_node_translations", 'DateTime'>
    readonly updatedAt: FieldRef<"response_node_translations", 'DateTime'>
    readonly answer: FieldRef<"response_node_translations", 'Json'>
    readonly language: FieldRef<"response_node_translations", 'String'>
    readonly title: FieldRef<"response_node_translations", 'String'>
    readonly deleted_at: FieldRef<"response_node_translations", 'DateTime'>
    readonly deleted_by: FieldRef<"response_node_translations", 'String'>
    readonly is_deleted: FieldRef<"response_node_translations", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * response_node_translations findUnique
   */
  export type response_node_translationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    /**
     * Filter, which response_node_translations to fetch.
     */
    where: response_node_translationsWhereUniqueInput
  }

  /**
   * response_node_translations findUniqueOrThrow
   */
  export type response_node_translationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    /**
     * Filter, which response_node_translations to fetch.
     */
    where: response_node_translationsWhereUniqueInput
  }

  /**
   * response_node_translations findFirst
   */
  export type response_node_translationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    /**
     * Filter, which response_node_translations to fetch.
     */
    where?: response_node_translationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_node_translations to fetch.
     */
    orderBy?: response_node_translationsOrderByWithRelationInput | response_node_translationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_node_translations.
     */
    cursor?: response_node_translationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_node_translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_node_translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_node_translations.
     */
    distinct?: Response_node_translationsScalarFieldEnum | Response_node_translationsScalarFieldEnum[]
  }

  /**
   * response_node_translations findFirstOrThrow
   */
  export type response_node_translationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    /**
     * Filter, which response_node_translations to fetch.
     */
    where?: response_node_translationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_node_translations to fetch.
     */
    orderBy?: response_node_translationsOrderByWithRelationInput | response_node_translationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_node_translations.
     */
    cursor?: response_node_translationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_node_translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_node_translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_node_translations.
     */
    distinct?: Response_node_translationsScalarFieldEnum | Response_node_translationsScalarFieldEnum[]
  }

  /**
   * response_node_translations findMany
   */
  export type response_node_translationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    /**
     * Filter, which response_node_translations to fetch.
     */
    where?: response_node_translationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_node_translations to fetch.
     */
    orderBy?: response_node_translationsOrderByWithRelationInput | response_node_translationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing response_node_translations.
     */
    cursor?: response_node_translationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_node_translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_node_translations.
     */
    skip?: number
    distinct?: Response_node_translationsScalarFieldEnum | Response_node_translationsScalarFieldEnum[]
  }

  /**
   * response_node_translations create
   */
  export type response_node_translationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    /**
     * The data needed to create a response_node_translations.
     */
    data: XOR<response_node_translationsCreateInput, response_node_translationsUncheckedCreateInput>
  }

  /**
   * response_node_translations createMany
   */
  export type response_node_translationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many response_node_translations.
     */
    data: response_node_translationsCreateManyInput | response_node_translationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * response_node_translations createManyAndReturn
   */
  export type response_node_translationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many response_node_translations.
     */
    data: response_node_translationsCreateManyInput | response_node_translationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * response_node_translations update
   */
  export type response_node_translationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    /**
     * The data needed to update a response_node_translations.
     */
    data: XOR<response_node_translationsUpdateInput, response_node_translationsUncheckedUpdateInput>
    /**
     * Choose, which response_node_translations to update.
     */
    where: response_node_translationsWhereUniqueInput
  }

  /**
   * response_node_translations updateMany
   */
  export type response_node_translationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update response_node_translations.
     */
    data: XOR<response_node_translationsUpdateManyMutationInput, response_node_translationsUncheckedUpdateManyInput>
    /**
     * Filter which response_node_translations to update
     */
    where?: response_node_translationsWhereInput
  }

  /**
   * response_node_translations upsert
   */
  export type response_node_translationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    /**
     * The filter to search for the response_node_translations to update in case it exists.
     */
    where: response_node_translationsWhereUniqueInput
    /**
     * In case the response_node_translations found by the `where` argument doesn't exist, create a new response_node_translations with this data.
     */
    create: XOR<response_node_translationsCreateInput, response_node_translationsUncheckedCreateInput>
    /**
     * In case the response_node_translations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<response_node_translationsUpdateInput, response_node_translationsUncheckedUpdateInput>
  }

  /**
   * response_node_translations delete
   */
  export type response_node_translationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    /**
     * Filter which response_node_translations to delete.
     */
    where: response_node_translationsWhereUniqueInput
  }

  /**
   * response_node_translations deleteMany
   */
  export type response_node_translationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_node_translations to delete
     */
    where?: response_node_translationsWhereInput
  }

  /**
   * response_node_translations without action
   */
  export type response_node_translationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
  }


  /**
   * Model response_nodes
   */

  export type AggregateResponse_nodes = {
    _count: Response_nodesCountAggregateOutputType | null
    _avg: Response_nodesAvgAggregateOutputType | null
    _sum: Response_nodesSumAggregateOutputType | null
    _min: Response_nodesMinAggregateOutputType | null
    _max: Response_nodesMaxAggregateOutputType | null
  }

  export type Response_nodesAvgAggregateOutputType = {
    position: number | null
    order: number | null
  }

  export type Response_nodesSumAggregateOutputType = {
    position: number | null
    order: number | null
  }

  export type Response_nodesMinAggregateOutputType = {
    id: string | null
    treeId: string | null
    nodeType: string | null
    content: string | null
    isRoot: boolean | null
    parentId: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    icon: string | null
    order: number | null
    title: string | null
    type: string | null
  }

  export type Response_nodesMaxAggregateOutputType = {
    id: string | null
    treeId: string | null
    nodeType: string | null
    content: string | null
    isRoot: boolean | null
    parentId: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    icon: string | null
    order: number | null
    title: string | null
    type: string | null
  }

  export type Response_nodesCountAggregateOutputType = {
    id: number
    treeId: number
    nodeType: number
    content: number
    metadata: number
    isRoot: number
    parentId: number
    position: number
    createdAt: number
    updatedAt: number
    answer: number
    description: number
    icon: number
    order: number
    title: number
    type: number
    _all: number
  }


  export type Response_nodesAvgAggregateInputType = {
    position?: true
    order?: true
  }

  export type Response_nodesSumAggregateInputType = {
    position?: true
    order?: true
  }

  export type Response_nodesMinAggregateInputType = {
    id?: true
    treeId?: true
    nodeType?: true
    content?: true
    isRoot?: true
    parentId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    icon?: true
    order?: true
    title?: true
    type?: true
  }

  export type Response_nodesMaxAggregateInputType = {
    id?: true
    treeId?: true
    nodeType?: true
    content?: true
    isRoot?: true
    parentId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    icon?: true
    order?: true
    title?: true
    type?: true
  }

  export type Response_nodesCountAggregateInputType = {
    id?: true
    treeId?: true
    nodeType?: true
    content?: true
    metadata?: true
    isRoot?: true
    parentId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    answer?: true
    description?: true
    icon?: true
    order?: true
    title?: true
    type?: true
    _all?: true
  }

  export type Response_nodesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_nodes to aggregate.
     */
    where?: response_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_nodes to fetch.
     */
    orderBy?: response_nodesOrderByWithRelationInput | response_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: response_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned response_nodes
    **/
    _count?: true | Response_nodesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Response_nodesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Response_nodesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Response_nodesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Response_nodesMaxAggregateInputType
  }

  export type GetResponse_nodesAggregateType<T extends Response_nodesAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse_nodes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse_nodes[P]>
      : GetScalarType<T[P], AggregateResponse_nodes[P]>
  }




  export type response_nodesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_nodesWhereInput
    orderBy?: response_nodesOrderByWithAggregationInput | response_nodesOrderByWithAggregationInput[]
    by: Response_nodesScalarFieldEnum[] | Response_nodesScalarFieldEnum
    having?: response_nodesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Response_nodesCountAggregateInputType | true
    _avg?: Response_nodesAvgAggregateInputType
    _sum?: Response_nodesSumAggregateInputType
    _min?: Response_nodesMinAggregateInputType
    _max?: Response_nodesMaxAggregateInputType
  }

  export type Response_nodesGroupByOutputType = {
    id: string
    treeId: string
    nodeType: string
    content: string | null
    metadata: JsonValue | null
    isRoot: boolean
    parentId: string | null
    position: number
    createdAt: Date
    updatedAt: Date
    answer: JsonValue | null
    description: string | null
    icon: string | null
    order: number
    title: string | null
    type: string | null
    _count: Response_nodesCountAggregateOutputType | null
    _avg: Response_nodesAvgAggregateOutputType | null
    _sum: Response_nodesSumAggregateOutputType | null
    _min: Response_nodesMinAggregateOutputType | null
    _max: Response_nodesMaxAggregateOutputType | null
  }

  type GetResponse_nodesGroupByPayload<T extends response_nodesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Response_nodesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Response_nodesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Response_nodesGroupByOutputType[P]>
            : GetScalarType<T[P], Response_nodesGroupByOutputType[P]>
        }
      >
    >


  export type response_nodesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    treeId?: boolean
    nodeType?: boolean
    content?: boolean
    metadata?: boolean
    isRoot?: boolean
    parentId?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answer?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    title?: boolean
    type?: boolean
    response_node_translations?: boolean | response_nodes$response_node_translationsArgs<ExtArgs>
    response_nodes?: boolean | response_nodes$response_nodesArgs<ExtArgs>
    other_response_nodes?: boolean | response_nodes$other_response_nodesArgs<ExtArgs>
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
    response_tree_history?: boolean | response_nodes$response_tree_historyArgs<ExtArgs>
    response_tree_sessions?: boolean | response_nodes$response_tree_sessionsArgs<ExtArgs>
    _count?: boolean | Response_nodesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_nodes"]>

  export type response_nodesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    treeId?: boolean
    nodeType?: boolean
    content?: boolean
    metadata?: boolean
    isRoot?: boolean
    parentId?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answer?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    title?: boolean
    type?: boolean
    response_nodes?: boolean | response_nodes$response_nodesArgs<ExtArgs>
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_nodes"]>

  export type response_nodesSelectScalar = {
    id?: boolean
    treeId?: boolean
    nodeType?: boolean
    content?: boolean
    metadata?: boolean
    isRoot?: boolean
    parentId?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answer?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    title?: boolean
    type?: boolean
  }

  export type response_nodesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_node_translations?: boolean | response_nodes$response_node_translationsArgs<ExtArgs>
    response_nodes?: boolean | response_nodes$response_nodesArgs<ExtArgs>
    other_response_nodes?: boolean | response_nodes$other_response_nodesArgs<ExtArgs>
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
    response_tree_history?: boolean | response_nodes$response_tree_historyArgs<ExtArgs>
    response_tree_sessions?: boolean | response_nodes$response_tree_sessionsArgs<ExtArgs>
    _count?: boolean | Response_nodesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type response_nodesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_nodes?: boolean | response_nodes$response_nodesArgs<ExtArgs>
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
  }

  export type $response_nodesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "response_nodes"
    objects: {
      response_node_translations: Prisma.$response_node_translationsPayload<ExtArgs>[]
      response_nodes: Prisma.$response_nodesPayload<ExtArgs> | null
      other_response_nodes: Prisma.$response_nodesPayload<ExtArgs>[]
      response_trees: Prisma.$response_treesPayload<ExtArgs>
      response_tree_history: Prisma.$response_tree_historyPayload<ExtArgs>[]
      response_tree_sessions: Prisma.$response_tree_sessionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      treeId: string
      nodeType: string
      content: string | null
      metadata: Prisma.JsonValue | null
      isRoot: boolean
      parentId: string | null
      position: number
      createdAt: Date
      updatedAt: Date
      answer: Prisma.JsonValue | null
      description: string | null
      icon: string | null
      order: number
      title: string | null
      type: string | null
    }, ExtArgs["result"]["response_nodes"]>
    composites: {}
  }

  type response_nodesGetPayload<S extends boolean | null | undefined | response_nodesDefaultArgs> = $Result.GetResult<Prisma.$response_nodesPayload, S>

  type response_nodesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<response_nodesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Response_nodesCountAggregateInputType | true
    }

  export interface response_nodesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['response_nodes'], meta: { name: 'response_nodes' } }
    /**
     * Find zero or one Response_nodes that matches the filter.
     * @param {response_nodesFindUniqueArgs} args - Arguments to find a Response_nodes
     * @example
     * // Get one Response_nodes
     * const response_nodes = await prisma.response_nodes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends response_nodesFindUniqueArgs>(args: SelectSubset<T, response_nodesFindUniqueArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Response_nodes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {response_nodesFindUniqueOrThrowArgs} args - Arguments to find a Response_nodes
     * @example
     * // Get one Response_nodes
     * const response_nodes = await prisma.response_nodes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends response_nodesFindUniqueOrThrowArgs>(args: SelectSubset<T, response_nodesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Response_nodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_nodesFindFirstArgs} args - Arguments to find a Response_nodes
     * @example
     * // Get one Response_nodes
     * const response_nodes = await prisma.response_nodes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends response_nodesFindFirstArgs>(args?: SelectSubset<T, response_nodesFindFirstArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Response_nodes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_nodesFindFirstOrThrowArgs} args - Arguments to find a Response_nodes
     * @example
     * // Get one Response_nodes
     * const response_nodes = await prisma.response_nodes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends response_nodesFindFirstOrThrowArgs>(args?: SelectSubset<T, response_nodesFindFirstOrThrowArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Response_nodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_nodesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Response_nodes
     * const response_nodes = await prisma.response_nodes.findMany()
     * 
     * // Get first 10 Response_nodes
     * const response_nodes = await prisma.response_nodes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const response_nodesWithIdOnly = await prisma.response_nodes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends response_nodesFindManyArgs>(args?: SelectSubset<T, response_nodesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Response_nodes.
     * @param {response_nodesCreateArgs} args - Arguments to create a Response_nodes.
     * @example
     * // Create one Response_nodes
     * const Response_nodes = await prisma.response_nodes.create({
     *   data: {
     *     // ... data to create a Response_nodes
     *   }
     * })
     * 
     */
    create<T extends response_nodesCreateArgs>(args: SelectSubset<T, response_nodesCreateArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Response_nodes.
     * @param {response_nodesCreateManyArgs} args - Arguments to create many Response_nodes.
     * @example
     * // Create many Response_nodes
     * const response_nodes = await prisma.response_nodes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends response_nodesCreateManyArgs>(args?: SelectSubset<T, response_nodesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Response_nodes and returns the data saved in the database.
     * @param {response_nodesCreateManyAndReturnArgs} args - Arguments to create many Response_nodes.
     * @example
     * // Create many Response_nodes
     * const response_nodes = await prisma.response_nodes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Response_nodes and only return the `id`
     * const response_nodesWithIdOnly = await prisma.response_nodes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends response_nodesCreateManyAndReturnArgs>(args?: SelectSubset<T, response_nodesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Response_nodes.
     * @param {response_nodesDeleteArgs} args - Arguments to delete one Response_nodes.
     * @example
     * // Delete one Response_nodes
     * const Response_nodes = await prisma.response_nodes.delete({
     *   where: {
     *     // ... filter to delete one Response_nodes
     *   }
     * })
     * 
     */
    delete<T extends response_nodesDeleteArgs>(args: SelectSubset<T, response_nodesDeleteArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Response_nodes.
     * @param {response_nodesUpdateArgs} args - Arguments to update one Response_nodes.
     * @example
     * // Update one Response_nodes
     * const response_nodes = await prisma.response_nodes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends response_nodesUpdateArgs>(args: SelectSubset<T, response_nodesUpdateArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Response_nodes.
     * @param {response_nodesDeleteManyArgs} args - Arguments to filter Response_nodes to delete.
     * @example
     * // Delete a few Response_nodes
     * const { count } = await prisma.response_nodes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends response_nodesDeleteManyArgs>(args?: SelectSubset<T, response_nodesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Response_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_nodesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Response_nodes
     * const response_nodes = await prisma.response_nodes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends response_nodesUpdateManyArgs>(args: SelectSubset<T, response_nodesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Response_nodes.
     * @param {response_nodesUpsertArgs} args - Arguments to update or create a Response_nodes.
     * @example
     * // Update or create a Response_nodes
     * const response_nodes = await prisma.response_nodes.upsert({
     *   create: {
     *     // ... data to create a Response_nodes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response_nodes we want to update
     *   }
     * })
     */
    upsert<T extends response_nodesUpsertArgs>(args: SelectSubset<T, response_nodesUpsertArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Response_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_nodesCountArgs} args - Arguments to filter Response_nodes to count.
     * @example
     * // Count the number of Response_nodes
     * const count = await prisma.response_nodes.count({
     *   where: {
     *     // ... the filter for the Response_nodes we want to count
     *   }
     * })
    **/
    count<T extends response_nodesCountArgs>(
      args?: Subset<T, response_nodesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Response_nodesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Response_nodesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Response_nodesAggregateArgs>(args: Subset<T, Response_nodesAggregateArgs>): Prisma.PrismaPromise<GetResponse_nodesAggregateType<T>>

    /**
     * Group by Response_nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_nodesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends response_nodesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: response_nodesGroupByArgs['orderBy'] }
        : { orderBy?: response_nodesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, response_nodesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponse_nodesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the response_nodes model
   */
  readonly fields: response_nodesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for response_nodes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__response_nodesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response_node_translations<T extends response_nodes$response_node_translationsArgs<ExtArgs> = {}>(args?: Subset<T, response_nodes$response_node_translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_node_translationsPayload<ExtArgs>, T, "findMany"> | Null>
    response_nodes<T extends response_nodes$response_nodesArgs<ExtArgs> = {}>(args?: Subset<T, response_nodes$response_nodesArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    other_response_nodes<T extends response_nodes$other_response_nodesArgs<ExtArgs> = {}>(args?: Subset<T, response_nodes$other_response_nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findMany"> | Null>
    response_trees<T extends response_treesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, response_treesDefaultArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    response_tree_history<T extends response_nodes$response_tree_historyArgs<ExtArgs> = {}>(args?: Subset<T, response_nodes$response_tree_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "findMany"> | Null>
    response_tree_sessions<T extends response_nodes$response_tree_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, response_nodes$response_tree_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the response_nodes model
   */ 
  interface response_nodesFieldRefs {
    readonly id: FieldRef<"response_nodes", 'String'>
    readonly treeId: FieldRef<"response_nodes", 'String'>
    readonly nodeType: FieldRef<"response_nodes", 'String'>
    readonly content: FieldRef<"response_nodes", 'String'>
    readonly metadata: FieldRef<"response_nodes", 'Json'>
    readonly isRoot: FieldRef<"response_nodes", 'Boolean'>
    readonly parentId: FieldRef<"response_nodes", 'String'>
    readonly position: FieldRef<"response_nodes", 'Int'>
    readonly createdAt: FieldRef<"response_nodes", 'DateTime'>
    readonly updatedAt: FieldRef<"response_nodes", 'DateTime'>
    readonly answer: FieldRef<"response_nodes", 'Json'>
    readonly description: FieldRef<"response_nodes", 'String'>
    readonly icon: FieldRef<"response_nodes", 'String'>
    readonly order: FieldRef<"response_nodes", 'Int'>
    readonly title: FieldRef<"response_nodes", 'String'>
    readonly type: FieldRef<"response_nodes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * response_nodes findUnique
   */
  export type response_nodesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    /**
     * Filter, which response_nodes to fetch.
     */
    where: response_nodesWhereUniqueInput
  }

  /**
   * response_nodes findUniqueOrThrow
   */
  export type response_nodesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    /**
     * Filter, which response_nodes to fetch.
     */
    where: response_nodesWhereUniqueInput
  }

  /**
   * response_nodes findFirst
   */
  export type response_nodesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    /**
     * Filter, which response_nodes to fetch.
     */
    where?: response_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_nodes to fetch.
     */
    orderBy?: response_nodesOrderByWithRelationInput | response_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_nodes.
     */
    cursor?: response_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_nodes.
     */
    distinct?: Response_nodesScalarFieldEnum | Response_nodesScalarFieldEnum[]
  }

  /**
   * response_nodes findFirstOrThrow
   */
  export type response_nodesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    /**
     * Filter, which response_nodes to fetch.
     */
    where?: response_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_nodes to fetch.
     */
    orderBy?: response_nodesOrderByWithRelationInput | response_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_nodes.
     */
    cursor?: response_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_nodes.
     */
    distinct?: Response_nodesScalarFieldEnum | Response_nodesScalarFieldEnum[]
  }

  /**
   * response_nodes findMany
   */
  export type response_nodesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    /**
     * Filter, which response_nodes to fetch.
     */
    where?: response_nodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_nodes to fetch.
     */
    orderBy?: response_nodesOrderByWithRelationInput | response_nodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing response_nodes.
     */
    cursor?: response_nodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_nodes.
     */
    skip?: number
    distinct?: Response_nodesScalarFieldEnum | Response_nodesScalarFieldEnum[]
  }

  /**
   * response_nodes create
   */
  export type response_nodesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    /**
     * The data needed to create a response_nodes.
     */
    data: XOR<response_nodesCreateInput, response_nodesUncheckedCreateInput>
  }

  /**
   * response_nodes createMany
   */
  export type response_nodesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many response_nodes.
     */
    data: response_nodesCreateManyInput | response_nodesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * response_nodes createManyAndReturn
   */
  export type response_nodesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many response_nodes.
     */
    data: response_nodesCreateManyInput | response_nodesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * response_nodes update
   */
  export type response_nodesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    /**
     * The data needed to update a response_nodes.
     */
    data: XOR<response_nodesUpdateInput, response_nodesUncheckedUpdateInput>
    /**
     * Choose, which response_nodes to update.
     */
    where: response_nodesWhereUniqueInput
  }

  /**
   * response_nodes updateMany
   */
  export type response_nodesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update response_nodes.
     */
    data: XOR<response_nodesUpdateManyMutationInput, response_nodesUncheckedUpdateManyInput>
    /**
     * Filter which response_nodes to update
     */
    where?: response_nodesWhereInput
  }

  /**
   * response_nodes upsert
   */
  export type response_nodesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    /**
     * The filter to search for the response_nodes to update in case it exists.
     */
    where: response_nodesWhereUniqueInput
    /**
     * In case the response_nodes found by the `where` argument doesn't exist, create a new response_nodes with this data.
     */
    create: XOR<response_nodesCreateInput, response_nodesUncheckedCreateInput>
    /**
     * In case the response_nodes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<response_nodesUpdateInput, response_nodesUncheckedUpdateInput>
  }

  /**
   * response_nodes delete
   */
  export type response_nodesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    /**
     * Filter which response_nodes to delete.
     */
    where: response_nodesWhereUniqueInput
  }

  /**
   * response_nodes deleteMany
   */
  export type response_nodesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_nodes to delete
     */
    where?: response_nodesWhereInput
  }

  /**
   * response_nodes.response_node_translations
   */
  export type response_nodes$response_node_translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_node_translations
     */
    select?: response_node_translationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_node_translationsInclude<ExtArgs> | null
    where?: response_node_translationsWhereInput
    orderBy?: response_node_translationsOrderByWithRelationInput | response_node_translationsOrderByWithRelationInput[]
    cursor?: response_node_translationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Response_node_translationsScalarFieldEnum | Response_node_translationsScalarFieldEnum[]
  }

  /**
   * response_nodes.response_nodes
   */
  export type response_nodes$response_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    where?: response_nodesWhereInput
  }

  /**
   * response_nodes.other_response_nodes
   */
  export type response_nodes$other_response_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    where?: response_nodesWhereInput
    orderBy?: response_nodesOrderByWithRelationInput | response_nodesOrderByWithRelationInput[]
    cursor?: response_nodesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Response_nodesScalarFieldEnum | Response_nodesScalarFieldEnum[]
  }

  /**
   * response_nodes.response_tree_history
   */
  export type response_nodes$response_tree_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    where?: response_tree_historyWhereInput
    orderBy?: response_tree_historyOrderByWithRelationInput | response_tree_historyOrderByWithRelationInput[]
    cursor?: response_tree_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Response_tree_historyScalarFieldEnum | Response_tree_historyScalarFieldEnum[]
  }

  /**
   * response_nodes.response_tree_sessions
   */
  export type response_nodes$response_tree_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    where?: response_tree_sessionsWhereInput
    orderBy?: response_tree_sessionsOrderByWithRelationInput | response_tree_sessionsOrderByWithRelationInput[]
    cursor?: response_tree_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Response_tree_sessionsScalarFieldEnum | Response_tree_sessionsScalarFieldEnum[]
  }

  /**
   * response_nodes without action
   */
  export type response_nodesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
  }


  /**
   * Model response_tree_history
   */

  export type AggregateResponse_tree_history = {
    _count: Response_tree_historyCountAggregateOutputType | null
    _min: Response_tree_historyMinAggregateOutputType | null
    _max: Response_tree_historyMaxAggregateOutputType | null
  }

  export type Response_tree_historyMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    nodeId: string | null
    response: string | null
    createdAt: Date | null
    action: string | null
    timestamp: Date | null
  }

  export type Response_tree_historyMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    nodeId: string | null
    response: string | null
    createdAt: Date | null
    action: string | null
    timestamp: Date | null
  }

  export type Response_tree_historyCountAggregateOutputType = {
    id: number
    sessionId: number
    nodeId: number
    response: number
    metadata: number
    createdAt: number
    action: number
    timestamp: number
    _all: number
  }


  export type Response_tree_historyMinAggregateInputType = {
    id?: true
    sessionId?: true
    nodeId?: true
    response?: true
    createdAt?: true
    action?: true
    timestamp?: true
  }

  export type Response_tree_historyMaxAggregateInputType = {
    id?: true
    sessionId?: true
    nodeId?: true
    response?: true
    createdAt?: true
    action?: true
    timestamp?: true
  }

  export type Response_tree_historyCountAggregateInputType = {
    id?: true
    sessionId?: true
    nodeId?: true
    response?: true
    metadata?: true
    createdAt?: true
    action?: true
    timestamp?: true
    _all?: true
  }

  export type Response_tree_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_tree_history to aggregate.
     */
    where?: response_tree_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_histories to fetch.
     */
    orderBy?: response_tree_historyOrderByWithRelationInput | response_tree_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: response_tree_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned response_tree_histories
    **/
    _count?: true | Response_tree_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Response_tree_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Response_tree_historyMaxAggregateInputType
  }

  export type GetResponse_tree_historyAggregateType<T extends Response_tree_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse_tree_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse_tree_history[P]>
      : GetScalarType<T[P], AggregateResponse_tree_history[P]>
  }




  export type response_tree_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_historyWhereInput
    orderBy?: response_tree_historyOrderByWithAggregationInput | response_tree_historyOrderByWithAggregationInput[]
    by: Response_tree_historyScalarFieldEnum[] | Response_tree_historyScalarFieldEnum
    having?: response_tree_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Response_tree_historyCountAggregateInputType | true
    _min?: Response_tree_historyMinAggregateInputType
    _max?: Response_tree_historyMaxAggregateInputType
  }

  export type Response_tree_historyGroupByOutputType = {
    id: string
    sessionId: string
    nodeId: string
    response: string | null
    metadata: JsonValue | null
    createdAt: Date
    action: string | null
    timestamp: Date
    _count: Response_tree_historyCountAggregateOutputType | null
    _min: Response_tree_historyMinAggregateOutputType | null
    _max: Response_tree_historyMaxAggregateOutputType | null
  }

  type GetResponse_tree_historyGroupByPayload<T extends response_tree_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Response_tree_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Response_tree_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Response_tree_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Response_tree_historyGroupByOutputType[P]>
        }
      >
    >


  export type response_tree_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    nodeId?: boolean
    response?: boolean
    metadata?: boolean
    createdAt?: boolean
    action?: boolean
    timestamp?: boolean
    response_nodes?: boolean | response_nodesDefaultArgs<ExtArgs>
    response_tree_sessions?: boolean | response_tree_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_tree_history"]>

  export type response_tree_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    nodeId?: boolean
    response?: boolean
    metadata?: boolean
    createdAt?: boolean
    action?: boolean
    timestamp?: boolean
    response_nodes?: boolean | response_nodesDefaultArgs<ExtArgs>
    response_tree_sessions?: boolean | response_tree_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_tree_history"]>

  export type response_tree_historySelectScalar = {
    id?: boolean
    sessionId?: boolean
    nodeId?: boolean
    response?: boolean
    metadata?: boolean
    createdAt?: boolean
    action?: boolean
    timestamp?: boolean
  }

  export type response_tree_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_nodes?: boolean | response_nodesDefaultArgs<ExtArgs>
    response_tree_sessions?: boolean | response_tree_sessionsDefaultArgs<ExtArgs>
  }
  export type response_tree_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_nodes?: boolean | response_nodesDefaultArgs<ExtArgs>
    response_tree_sessions?: boolean | response_tree_sessionsDefaultArgs<ExtArgs>
  }

  export type $response_tree_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "response_tree_history"
    objects: {
      response_nodes: Prisma.$response_nodesPayload<ExtArgs>
      response_tree_sessions: Prisma.$response_tree_sessionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      nodeId: string
      response: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      action: string | null
      timestamp: Date
    }, ExtArgs["result"]["response_tree_history"]>
    composites: {}
  }

  type response_tree_historyGetPayload<S extends boolean | null | undefined | response_tree_historyDefaultArgs> = $Result.GetResult<Prisma.$response_tree_historyPayload, S>

  type response_tree_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<response_tree_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Response_tree_historyCountAggregateInputType | true
    }

  export interface response_tree_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['response_tree_history'], meta: { name: 'response_tree_history' } }
    /**
     * Find zero or one Response_tree_history that matches the filter.
     * @param {response_tree_historyFindUniqueArgs} args - Arguments to find a Response_tree_history
     * @example
     * // Get one Response_tree_history
     * const response_tree_history = await prisma.response_tree_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends response_tree_historyFindUniqueArgs>(args: SelectSubset<T, response_tree_historyFindUniqueArgs<ExtArgs>>): Prisma__response_tree_historyClient<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Response_tree_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {response_tree_historyFindUniqueOrThrowArgs} args - Arguments to find a Response_tree_history
     * @example
     * // Get one Response_tree_history
     * const response_tree_history = await prisma.response_tree_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends response_tree_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, response_tree_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__response_tree_historyClient<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Response_tree_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_historyFindFirstArgs} args - Arguments to find a Response_tree_history
     * @example
     * // Get one Response_tree_history
     * const response_tree_history = await prisma.response_tree_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends response_tree_historyFindFirstArgs>(args?: SelectSubset<T, response_tree_historyFindFirstArgs<ExtArgs>>): Prisma__response_tree_historyClient<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Response_tree_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_historyFindFirstOrThrowArgs} args - Arguments to find a Response_tree_history
     * @example
     * // Get one Response_tree_history
     * const response_tree_history = await prisma.response_tree_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends response_tree_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, response_tree_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__response_tree_historyClient<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Response_tree_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Response_tree_histories
     * const response_tree_histories = await prisma.response_tree_history.findMany()
     * 
     * // Get first 10 Response_tree_histories
     * const response_tree_histories = await prisma.response_tree_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const response_tree_historyWithIdOnly = await prisma.response_tree_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends response_tree_historyFindManyArgs>(args?: SelectSubset<T, response_tree_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Response_tree_history.
     * @param {response_tree_historyCreateArgs} args - Arguments to create a Response_tree_history.
     * @example
     * // Create one Response_tree_history
     * const Response_tree_history = await prisma.response_tree_history.create({
     *   data: {
     *     // ... data to create a Response_tree_history
     *   }
     * })
     * 
     */
    create<T extends response_tree_historyCreateArgs>(args: SelectSubset<T, response_tree_historyCreateArgs<ExtArgs>>): Prisma__response_tree_historyClient<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Response_tree_histories.
     * @param {response_tree_historyCreateManyArgs} args - Arguments to create many Response_tree_histories.
     * @example
     * // Create many Response_tree_histories
     * const response_tree_history = await prisma.response_tree_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends response_tree_historyCreateManyArgs>(args?: SelectSubset<T, response_tree_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Response_tree_histories and returns the data saved in the database.
     * @param {response_tree_historyCreateManyAndReturnArgs} args - Arguments to create many Response_tree_histories.
     * @example
     * // Create many Response_tree_histories
     * const response_tree_history = await prisma.response_tree_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Response_tree_histories and only return the `id`
     * const response_tree_historyWithIdOnly = await prisma.response_tree_history.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends response_tree_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, response_tree_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Response_tree_history.
     * @param {response_tree_historyDeleteArgs} args - Arguments to delete one Response_tree_history.
     * @example
     * // Delete one Response_tree_history
     * const Response_tree_history = await prisma.response_tree_history.delete({
     *   where: {
     *     // ... filter to delete one Response_tree_history
     *   }
     * })
     * 
     */
    delete<T extends response_tree_historyDeleteArgs>(args: SelectSubset<T, response_tree_historyDeleteArgs<ExtArgs>>): Prisma__response_tree_historyClient<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Response_tree_history.
     * @param {response_tree_historyUpdateArgs} args - Arguments to update one Response_tree_history.
     * @example
     * // Update one Response_tree_history
     * const response_tree_history = await prisma.response_tree_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends response_tree_historyUpdateArgs>(args: SelectSubset<T, response_tree_historyUpdateArgs<ExtArgs>>): Prisma__response_tree_historyClient<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Response_tree_histories.
     * @param {response_tree_historyDeleteManyArgs} args - Arguments to filter Response_tree_histories to delete.
     * @example
     * // Delete a few Response_tree_histories
     * const { count } = await prisma.response_tree_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends response_tree_historyDeleteManyArgs>(args?: SelectSubset<T, response_tree_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Response_tree_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Response_tree_histories
     * const response_tree_history = await prisma.response_tree_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends response_tree_historyUpdateManyArgs>(args: SelectSubset<T, response_tree_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Response_tree_history.
     * @param {response_tree_historyUpsertArgs} args - Arguments to update or create a Response_tree_history.
     * @example
     * // Update or create a Response_tree_history
     * const response_tree_history = await prisma.response_tree_history.upsert({
     *   create: {
     *     // ... data to create a Response_tree_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response_tree_history we want to update
     *   }
     * })
     */
    upsert<T extends response_tree_historyUpsertArgs>(args: SelectSubset<T, response_tree_historyUpsertArgs<ExtArgs>>): Prisma__response_tree_historyClient<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Response_tree_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_historyCountArgs} args - Arguments to filter Response_tree_histories to count.
     * @example
     * // Count the number of Response_tree_histories
     * const count = await prisma.response_tree_history.count({
     *   where: {
     *     // ... the filter for the Response_tree_histories we want to count
     *   }
     * })
    **/
    count<T extends response_tree_historyCountArgs>(
      args?: Subset<T, response_tree_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Response_tree_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response_tree_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Response_tree_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Response_tree_historyAggregateArgs>(args: Subset<T, Response_tree_historyAggregateArgs>): Prisma.PrismaPromise<GetResponse_tree_historyAggregateType<T>>

    /**
     * Group by Response_tree_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends response_tree_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: response_tree_historyGroupByArgs['orderBy'] }
        : { orderBy?: response_tree_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, response_tree_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponse_tree_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the response_tree_history model
   */
  readonly fields: response_tree_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for response_tree_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__response_tree_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response_nodes<T extends response_nodesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, response_nodesDefaultArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    response_tree_sessions<T extends response_tree_sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, response_tree_sessionsDefaultArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the response_tree_history model
   */ 
  interface response_tree_historyFieldRefs {
    readonly id: FieldRef<"response_tree_history", 'String'>
    readonly sessionId: FieldRef<"response_tree_history", 'String'>
    readonly nodeId: FieldRef<"response_tree_history", 'String'>
    readonly response: FieldRef<"response_tree_history", 'String'>
    readonly metadata: FieldRef<"response_tree_history", 'Json'>
    readonly createdAt: FieldRef<"response_tree_history", 'DateTime'>
    readonly action: FieldRef<"response_tree_history", 'String'>
    readonly timestamp: FieldRef<"response_tree_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * response_tree_history findUnique
   */
  export type response_tree_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_history to fetch.
     */
    where: response_tree_historyWhereUniqueInput
  }

  /**
   * response_tree_history findUniqueOrThrow
   */
  export type response_tree_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_history to fetch.
     */
    where: response_tree_historyWhereUniqueInput
  }

  /**
   * response_tree_history findFirst
   */
  export type response_tree_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_history to fetch.
     */
    where?: response_tree_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_histories to fetch.
     */
    orderBy?: response_tree_historyOrderByWithRelationInput | response_tree_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_tree_histories.
     */
    cursor?: response_tree_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_tree_histories.
     */
    distinct?: Response_tree_historyScalarFieldEnum | Response_tree_historyScalarFieldEnum[]
  }

  /**
   * response_tree_history findFirstOrThrow
   */
  export type response_tree_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_history to fetch.
     */
    where?: response_tree_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_histories to fetch.
     */
    orderBy?: response_tree_historyOrderByWithRelationInput | response_tree_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_tree_histories.
     */
    cursor?: response_tree_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_tree_histories.
     */
    distinct?: Response_tree_historyScalarFieldEnum | Response_tree_historyScalarFieldEnum[]
  }

  /**
   * response_tree_history findMany
   */
  export type response_tree_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_histories to fetch.
     */
    where?: response_tree_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_histories to fetch.
     */
    orderBy?: response_tree_historyOrderByWithRelationInput | response_tree_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing response_tree_histories.
     */
    cursor?: response_tree_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_histories.
     */
    skip?: number
    distinct?: Response_tree_historyScalarFieldEnum | Response_tree_historyScalarFieldEnum[]
  }

  /**
   * response_tree_history create
   */
  export type response_tree_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a response_tree_history.
     */
    data: XOR<response_tree_historyCreateInput, response_tree_historyUncheckedCreateInput>
  }

  /**
   * response_tree_history createMany
   */
  export type response_tree_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many response_tree_histories.
     */
    data: response_tree_historyCreateManyInput | response_tree_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * response_tree_history createManyAndReturn
   */
  export type response_tree_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many response_tree_histories.
     */
    data: response_tree_historyCreateManyInput | response_tree_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * response_tree_history update
   */
  export type response_tree_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a response_tree_history.
     */
    data: XOR<response_tree_historyUpdateInput, response_tree_historyUncheckedUpdateInput>
    /**
     * Choose, which response_tree_history to update.
     */
    where: response_tree_historyWhereUniqueInput
  }

  /**
   * response_tree_history updateMany
   */
  export type response_tree_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update response_tree_histories.
     */
    data: XOR<response_tree_historyUpdateManyMutationInput, response_tree_historyUncheckedUpdateManyInput>
    /**
     * Filter which response_tree_histories to update
     */
    where?: response_tree_historyWhereInput
  }

  /**
   * response_tree_history upsert
   */
  export type response_tree_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the response_tree_history to update in case it exists.
     */
    where: response_tree_historyWhereUniqueInput
    /**
     * In case the response_tree_history found by the `where` argument doesn't exist, create a new response_tree_history with this data.
     */
    create: XOR<response_tree_historyCreateInput, response_tree_historyUncheckedCreateInput>
    /**
     * In case the response_tree_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<response_tree_historyUpdateInput, response_tree_historyUncheckedUpdateInput>
  }

  /**
   * response_tree_history delete
   */
  export type response_tree_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    /**
     * Filter which response_tree_history to delete.
     */
    where: response_tree_historyWhereUniqueInput
  }

  /**
   * response_tree_history deleteMany
   */
  export type response_tree_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_tree_histories to delete
     */
    where?: response_tree_historyWhereInput
  }

  /**
   * response_tree_history without action
   */
  export type response_tree_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
  }


  /**
   * Model response_tree_mobile_links
   */

  export type AggregateResponse_tree_mobile_links = {
    _count: Response_tree_mobile_linksCountAggregateOutputType | null
    _avg: Response_tree_mobile_linksAvgAggregateOutputType | null
    _sum: Response_tree_mobile_linksSumAggregateOutputType | null
    _min: Response_tree_mobile_linksMinAggregateOutputType | null
    _max: Response_tree_mobile_linksMaxAggregateOutputType | null
  }

  export type Response_tree_mobile_linksAvgAggregateOutputType = {
    deviceId: number | null
  }

  export type Response_tree_mobile_linksSumAggregateOutputType = {
    deviceId: number | null
  }

  export type Response_tree_mobile_linksMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    code: string | null
    qrCodeData: string | null
    isActive: boolean | null
    connectionId: string | null
    createdAt: Date | null
    expiresAt: Date | null
    connectedAt: Date | null
    deviceId: number | null
  }

  export type Response_tree_mobile_linksMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    code: string | null
    qrCodeData: string | null
    isActive: boolean | null
    connectionId: string | null
    createdAt: Date | null
    expiresAt: Date | null
    connectedAt: Date | null
    deviceId: number | null
  }

  export type Response_tree_mobile_linksCountAggregateOutputType = {
    id: number
    sessionId: number
    code: number
    qrCodeData: number
    isActive: number
    connectionId: number
    createdAt: number
    expiresAt: number
    connectedAt: number
    deviceId: number
    _all: number
  }


  export type Response_tree_mobile_linksAvgAggregateInputType = {
    deviceId?: true
  }

  export type Response_tree_mobile_linksSumAggregateInputType = {
    deviceId?: true
  }

  export type Response_tree_mobile_linksMinAggregateInputType = {
    id?: true
    sessionId?: true
    code?: true
    qrCodeData?: true
    isActive?: true
    connectionId?: true
    createdAt?: true
    expiresAt?: true
    connectedAt?: true
    deviceId?: true
  }

  export type Response_tree_mobile_linksMaxAggregateInputType = {
    id?: true
    sessionId?: true
    code?: true
    qrCodeData?: true
    isActive?: true
    connectionId?: true
    createdAt?: true
    expiresAt?: true
    connectedAt?: true
    deviceId?: true
  }

  export type Response_tree_mobile_linksCountAggregateInputType = {
    id?: true
    sessionId?: true
    code?: true
    qrCodeData?: true
    isActive?: true
    connectionId?: true
    createdAt?: true
    expiresAt?: true
    connectedAt?: true
    deviceId?: true
    _all?: true
  }

  export type Response_tree_mobile_linksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_tree_mobile_links to aggregate.
     */
    where?: response_tree_mobile_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_mobile_links to fetch.
     */
    orderBy?: response_tree_mobile_linksOrderByWithRelationInput | response_tree_mobile_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: response_tree_mobile_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_mobile_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_mobile_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned response_tree_mobile_links
    **/
    _count?: true | Response_tree_mobile_linksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Response_tree_mobile_linksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Response_tree_mobile_linksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Response_tree_mobile_linksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Response_tree_mobile_linksMaxAggregateInputType
  }

  export type GetResponse_tree_mobile_linksAggregateType<T extends Response_tree_mobile_linksAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse_tree_mobile_links]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse_tree_mobile_links[P]>
      : GetScalarType<T[P], AggregateResponse_tree_mobile_links[P]>
  }




  export type response_tree_mobile_linksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_mobile_linksWhereInput
    orderBy?: response_tree_mobile_linksOrderByWithAggregationInput | response_tree_mobile_linksOrderByWithAggregationInput[]
    by: Response_tree_mobile_linksScalarFieldEnum[] | Response_tree_mobile_linksScalarFieldEnum
    having?: response_tree_mobile_linksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Response_tree_mobile_linksCountAggregateInputType | true
    _avg?: Response_tree_mobile_linksAvgAggregateInputType
    _sum?: Response_tree_mobile_linksSumAggregateInputType
    _min?: Response_tree_mobile_linksMinAggregateInputType
    _max?: Response_tree_mobile_linksMaxAggregateInputType
  }

  export type Response_tree_mobile_linksGroupByOutputType = {
    id: string
    sessionId: string
    code: string
    qrCodeData: string | null
    isActive: boolean
    connectionId: string | null
    createdAt: Date
    expiresAt: Date
    connectedAt: Date | null
    deviceId: number | null
    _count: Response_tree_mobile_linksCountAggregateOutputType | null
    _avg: Response_tree_mobile_linksAvgAggregateOutputType | null
    _sum: Response_tree_mobile_linksSumAggregateOutputType | null
    _min: Response_tree_mobile_linksMinAggregateOutputType | null
    _max: Response_tree_mobile_linksMaxAggregateOutputType | null
  }

  type GetResponse_tree_mobile_linksGroupByPayload<T extends response_tree_mobile_linksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Response_tree_mobile_linksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Response_tree_mobile_linksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Response_tree_mobile_linksGroupByOutputType[P]>
            : GetScalarType<T[P], Response_tree_mobile_linksGroupByOutputType[P]>
        }
      >
    >


  export type response_tree_mobile_linksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    code?: boolean
    qrCodeData?: boolean
    isActive?: boolean
    connectionId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    connectedAt?: boolean
    deviceId?: boolean
    response_tree_sessions?: boolean | response_tree_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_tree_mobile_links"]>

  export type response_tree_mobile_linksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    code?: boolean
    qrCodeData?: boolean
    isActive?: boolean
    connectionId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    connectedAt?: boolean
    deviceId?: boolean
    response_tree_sessions?: boolean | response_tree_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_tree_mobile_links"]>

  export type response_tree_mobile_linksSelectScalar = {
    id?: boolean
    sessionId?: boolean
    code?: boolean
    qrCodeData?: boolean
    isActive?: boolean
    connectionId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    connectedAt?: boolean
    deviceId?: boolean
  }

  export type response_tree_mobile_linksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_tree_sessions?: boolean | response_tree_sessionsDefaultArgs<ExtArgs>
  }
  export type response_tree_mobile_linksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_tree_sessions?: boolean | response_tree_sessionsDefaultArgs<ExtArgs>
  }

  export type $response_tree_mobile_linksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "response_tree_mobile_links"
    objects: {
      response_tree_sessions: Prisma.$response_tree_sessionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      code: string
      qrCodeData: string | null
      isActive: boolean
      connectionId: string | null
      createdAt: Date
      expiresAt: Date
      connectedAt: Date | null
      deviceId: number | null
    }, ExtArgs["result"]["response_tree_mobile_links"]>
    composites: {}
  }

  type response_tree_mobile_linksGetPayload<S extends boolean | null | undefined | response_tree_mobile_linksDefaultArgs> = $Result.GetResult<Prisma.$response_tree_mobile_linksPayload, S>

  type response_tree_mobile_linksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<response_tree_mobile_linksFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Response_tree_mobile_linksCountAggregateInputType | true
    }

  export interface response_tree_mobile_linksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['response_tree_mobile_links'], meta: { name: 'response_tree_mobile_links' } }
    /**
     * Find zero or one Response_tree_mobile_links that matches the filter.
     * @param {response_tree_mobile_linksFindUniqueArgs} args - Arguments to find a Response_tree_mobile_links
     * @example
     * // Get one Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends response_tree_mobile_linksFindUniqueArgs>(args: SelectSubset<T, response_tree_mobile_linksFindUniqueArgs<ExtArgs>>): Prisma__response_tree_mobile_linksClient<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Response_tree_mobile_links that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {response_tree_mobile_linksFindUniqueOrThrowArgs} args - Arguments to find a Response_tree_mobile_links
     * @example
     * // Get one Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends response_tree_mobile_linksFindUniqueOrThrowArgs>(args: SelectSubset<T, response_tree_mobile_linksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__response_tree_mobile_linksClient<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Response_tree_mobile_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_mobile_linksFindFirstArgs} args - Arguments to find a Response_tree_mobile_links
     * @example
     * // Get one Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends response_tree_mobile_linksFindFirstArgs>(args?: SelectSubset<T, response_tree_mobile_linksFindFirstArgs<ExtArgs>>): Prisma__response_tree_mobile_linksClient<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Response_tree_mobile_links that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_mobile_linksFindFirstOrThrowArgs} args - Arguments to find a Response_tree_mobile_links
     * @example
     * // Get one Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends response_tree_mobile_linksFindFirstOrThrowArgs>(args?: SelectSubset<T, response_tree_mobile_linksFindFirstOrThrowArgs<ExtArgs>>): Prisma__response_tree_mobile_linksClient<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Response_tree_mobile_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_mobile_linksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.findMany()
     * 
     * // Get first 10 Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const response_tree_mobile_linksWithIdOnly = await prisma.response_tree_mobile_links.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends response_tree_mobile_linksFindManyArgs>(args?: SelectSubset<T, response_tree_mobile_linksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Response_tree_mobile_links.
     * @param {response_tree_mobile_linksCreateArgs} args - Arguments to create a Response_tree_mobile_links.
     * @example
     * // Create one Response_tree_mobile_links
     * const Response_tree_mobile_links = await prisma.response_tree_mobile_links.create({
     *   data: {
     *     // ... data to create a Response_tree_mobile_links
     *   }
     * })
     * 
     */
    create<T extends response_tree_mobile_linksCreateArgs>(args: SelectSubset<T, response_tree_mobile_linksCreateArgs<ExtArgs>>): Prisma__response_tree_mobile_linksClient<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Response_tree_mobile_links.
     * @param {response_tree_mobile_linksCreateManyArgs} args - Arguments to create many Response_tree_mobile_links.
     * @example
     * // Create many Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends response_tree_mobile_linksCreateManyArgs>(args?: SelectSubset<T, response_tree_mobile_linksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Response_tree_mobile_links and returns the data saved in the database.
     * @param {response_tree_mobile_linksCreateManyAndReturnArgs} args - Arguments to create many Response_tree_mobile_links.
     * @example
     * // Create many Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Response_tree_mobile_links and only return the `id`
     * const response_tree_mobile_linksWithIdOnly = await prisma.response_tree_mobile_links.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends response_tree_mobile_linksCreateManyAndReturnArgs>(args?: SelectSubset<T, response_tree_mobile_linksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Response_tree_mobile_links.
     * @param {response_tree_mobile_linksDeleteArgs} args - Arguments to delete one Response_tree_mobile_links.
     * @example
     * // Delete one Response_tree_mobile_links
     * const Response_tree_mobile_links = await prisma.response_tree_mobile_links.delete({
     *   where: {
     *     // ... filter to delete one Response_tree_mobile_links
     *   }
     * })
     * 
     */
    delete<T extends response_tree_mobile_linksDeleteArgs>(args: SelectSubset<T, response_tree_mobile_linksDeleteArgs<ExtArgs>>): Prisma__response_tree_mobile_linksClient<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Response_tree_mobile_links.
     * @param {response_tree_mobile_linksUpdateArgs} args - Arguments to update one Response_tree_mobile_links.
     * @example
     * // Update one Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends response_tree_mobile_linksUpdateArgs>(args: SelectSubset<T, response_tree_mobile_linksUpdateArgs<ExtArgs>>): Prisma__response_tree_mobile_linksClient<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Response_tree_mobile_links.
     * @param {response_tree_mobile_linksDeleteManyArgs} args - Arguments to filter Response_tree_mobile_links to delete.
     * @example
     * // Delete a few Response_tree_mobile_links
     * const { count } = await prisma.response_tree_mobile_links.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends response_tree_mobile_linksDeleteManyArgs>(args?: SelectSubset<T, response_tree_mobile_linksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Response_tree_mobile_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_mobile_linksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends response_tree_mobile_linksUpdateManyArgs>(args: SelectSubset<T, response_tree_mobile_linksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Response_tree_mobile_links.
     * @param {response_tree_mobile_linksUpsertArgs} args - Arguments to update or create a Response_tree_mobile_links.
     * @example
     * // Update or create a Response_tree_mobile_links
     * const response_tree_mobile_links = await prisma.response_tree_mobile_links.upsert({
     *   create: {
     *     // ... data to create a Response_tree_mobile_links
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response_tree_mobile_links we want to update
     *   }
     * })
     */
    upsert<T extends response_tree_mobile_linksUpsertArgs>(args: SelectSubset<T, response_tree_mobile_linksUpsertArgs<ExtArgs>>): Prisma__response_tree_mobile_linksClient<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Response_tree_mobile_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_mobile_linksCountArgs} args - Arguments to filter Response_tree_mobile_links to count.
     * @example
     * // Count the number of Response_tree_mobile_links
     * const count = await prisma.response_tree_mobile_links.count({
     *   where: {
     *     // ... the filter for the Response_tree_mobile_links we want to count
     *   }
     * })
    **/
    count<T extends response_tree_mobile_linksCountArgs>(
      args?: Subset<T, response_tree_mobile_linksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Response_tree_mobile_linksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response_tree_mobile_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Response_tree_mobile_linksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Response_tree_mobile_linksAggregateArgs>(args: Subset<T, Response_tree_mobile_linksAggregateArgs>): Prisma.PrismaPromise<GetResponse_tree_mobile_linksAggregateType<T>>

    /**
     * Group by Response_tree_mobile_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_mobile_linksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends response_tree_mobile_linksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: response_tree_mobile_linksGroupByArgs['orderBy'] }
        : { orderBy?: response_tree_mobile_linksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, response_tree_mobile_linksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponse_tree_mobile_linksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the response_tree_mobile_links model
   */
  readonly fields: response_tree_mobile_linksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for response_tree_mobile_links.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__response_tree_mobile_linksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response_tree_sessions<T extends response_tree_sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, response_tree_sessionsDefaultArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the response_tree_mobile_links model
   */ 
  interface response_tree_mobile_linksFieldRefs {
    readonly id: FieldRef<"response_tree_mobile_links", 'String'>
    readonly sessionId: FieldRef<"response_tree_mobile_links", 'String'>
    readonly code: FieldRef<"response_tree_mobile_links", 'String'>
    readonly qrCodeData: FieldRef<"response_tree_mobile_links", 'String'>
    readonly isActive: FieldRef<"response_tree_mobile_links", 'Boolean'>
    readonly connectionId: FieldRef<"response_tree_mobile_links", 'String'>
    readonly createdAt: FieldRef<"response_tree_mobile_links", 'DateTime'>
    readonly expiresAt: FieldRef<"response_tree_mobile_links", 'DateTime'>
    readonly connectedAt: FieldRef<"response_tree_mobile_links", 'DateTime'>
    readonly deviceId: FieldRef<"response_tree_mobile_links", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * response_tree_mobile_links findUnique
   */
  export type response_tree_mobile_linksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_mobile_links to fetch.
     */
    where: response_tree_mobile_linksWhereUniqueInput
  }

  /**
   * response_tree_mobile_links findUniqueOrThrow
   */
  export type response_tree_mobile_linksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_mobile_links to fetch.
     */
    where: response_tree_mobile_linksWhereUniqueInput
  }

  /**
   * response_tree_mobile_links findFirst
   */
  export type response_tree_mobile_linksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_mobile_links to fetch.
     */
    where?: response_tree_mobile_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_mobile_links to fetch.
     */
    orderBy?: response_tree_mobile_linksOrderByWithRelationInput | response_tree_mobile_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_tree_mobile_links.
     */
    cursor?: response_tree_mobile_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_mobile_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_mobile_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_tree_mobile_links.
     */
    distinct?: Response_tree_mobile_linksScalarFieldEnum | Response_tree_mobile_linksScalarFieldEnum[]
  }

  /**
   * response_tree_mobile_links findFirstOrThrow
   */
  export type response_tree_mobile_linksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_mobile_links to fetch.
     */
    where?: response_tree_mobile_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_mobile_links to fetch.
     */
    orderBy?: response_tree_mobile_linksOrderByWithRelationInput | response_tree_mobile_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_tree_mobile_links.
     */
    cursor?: response_tree_mobile_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_mobile_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_mobile_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_tree_mobile_links.
     */
    distinct?: Response_tree_mobile_linksScalarFieldEnum | Response_tree_mobile_linksScalarFieldEnum[]
  }

  /**
   * response_tree_mobile_links findMany
   */
  export type response_tree_mobile_linksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_mobile_links to fetch.
     */
    where?: response_tree_mobile_linksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_mobile_links to fetch.
     */
    orderBy?: response_tree_mobile_linksOrderByWithRelationInput | response_tree_mobile_linksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing response_tree_mobile_links.
     */
    cursor?: response_tree_mobile_linksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_mobile_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_mobile_links.
     */
    skip?: number
    distinct?: Response_tree_mobile_linksScalarFieldEnum | Response_tree_mobile_linksScalarFieldEnum[]
  }

  /**
   * response_tree_mobile_links create
   */
  export type response_tree_mobile_linksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    /**
     * The data needed to create a response_tree_mobile_links.
     */
    data: XOR<response_tree_mobile_linksCreateInput, response_tree_mobile_linksUncheckedCreateInput>
  }

  /**
   * response_tree_mobile_links createMany
   */
  export type response_tree_mobile_linksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many response_tree_mobile_links.
     */
    data: response_tree_mobile_linksCreateManyInput | response_tree_mobile_linksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * response_tree_mobile_links createManyAndReturn
   */
  export type response_tree_mobile_linksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many response_tree_mobile_links.
     */
    data: response_tree_mobile_linksCreateManyInput | response_tree_mobile_linksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * response_tree_mobile_links update
   */
  export type response_tree_mobile_linksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    /**
     * The data needed to update a response_tree_mobile_links.
     */
    data: XOR<response_tree_mobile_linksUpdateInput, response_tree_mobile_linksUncheckedUpdateInput>
    /**
     * Choose, which response_tree_mobile_links to update.
     */
    where: response_tree_mobile_linksWhereUniqueInput
  }

  /**
   * response_tree_mobile_links updateMany
   */
  export type response_tree_mobile_linksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update response_tree_mobile_links.
     */
    data: XOR<response_tree_mobile_linksUpdateManyMutationInput, response_tree_mobile_linksUncheckedUpdateManyInput>
    /**
     * Filter which response_tree_mobile_links to update
     */
    where?: response_tree_mobile_linksWhereInput
  }

  /**
   * response_tree_mobile_links upsert
   */
  export type response_tree_mobile_linksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    /**
     * The filter to search for the response_tree_mobile_links to update in case it exists.
     */
    where: response_tree_mobile_linksWhereUniqueInput
    /**
     * In case the response_tree_mobile_links found by the `where` argument doesn't exist, create a new response_tree_mobile_links with this data.
     */
    create: XOR<response_tree_mobile_linksCreateInput, response_tree_mobile_linksUncheckedCreateInput>
    /**
     * In case the response_tree_mobile_links was found with the provided `where` argument, update it with this data.
     */
    update: XOR<response_tree_mobile_linksUpdateInput, response_tree_mobile_linksUncheckedUpdateInput>
  }

  /**
   * response_tree_mobile_links delete
   */
  export type response_tree_mobile_linksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    /**
     * Filter which response_tree_mobile_links to delete.
     */
    where: response_tree_mobile_linksWhereUniqueInput
  }

  /**
   * response_tree_mobile_links deleteMany
   */
  export type response_tree_mobile_linksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_tree_mobile_links to delete
     */
    where?: response_tree_mobile_linksWhereInput
  }

  /**
   * response_tree_mobile_links without action
   */
  export type response_tree_mobile_linksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
  }


  /**
   * Model response_tree_sessions
   */

  export type AggregateResponse_tree_sessions = {
    _count: Response_tree_sessionsCountAggregateOutputType | null
    _min: Response_tree_sessionsMinAggregateOutputType | null
    _max: Response_tree_sessionsMaxAggregateOutputType | null
  }

  export type Response_tree_sessionsMinAggregateOutputType = {
    id: string | null
    treeId: string | null
    userId: string | null
    deviceId: string | null
    currentNodeId: string | null
    isComplete: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    endedAt: Date | null
    interfaceType: string | null
    language: string | null
    lastActivityAt: Date | null
    roomId: string | null
    sessionId: string | null
  }

  export type Response_tree_sessionsMaxAggregateOutputType = {
    id: string | null
    treeId: string | null
    userId: string | null
    deviceId: string | null
    currentNodeId: string | null
    isComplete: boolean | null
    startedAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    endedAt: Date | null
    interfaceType: string | null
    language: string | null
    lastActivityAt: Date | null
    roomId: string | null
    sessionId: string | null
  }

  export type Response_tree_sessionsCountAggregateOutputType = {
    id: number
    treeId: number
    userId: number
    deviceId: number
    currentNodeId: number
    metadata: number
    isComplete: number
    startedAt: number
    updatedAt: number
    completedAt: number
    endedAt: number
    interfaceType: number
    language: number
    lastActivityAt: number
    roomId: number
    sessionId: number
    _all: number
  }


  export type Response_tree_sessionsMinAggregateInputType = {
    id?: true
    treeId?: true
    userId?: true
    deviceId?: true
    currentNodeId?: true
    isComplete?: true
    startedAt?: true
    updatedAt?: true
    completedAt?: true
    endedAt?: true
    interfaceType?: true
    language?: true
    lastActivityAt?: true
    roomId?: true
    sessionId?: true
  }

  export type Response_tree_sessionsMaxAggregateInputType = {
    id?: true
    treeId?: true
    userId?: true
    deviceId?: true
    currentNodeId?: true
    isComplete?: true
    startedAt?: true
    updatedAt?: true
    completedAt?: true
    endedAt?: true
    interfaceType?: true
    language?: true
    lastActivityAt?: true
    roomId?: true
    sessionId?: true
  }

  export type Response_tree_sessionsCountAggregateInputType = {
    id?: true
    treeId?: true
    userId?: true
    deviceId?: true
    currentNodeId?: true
    metadata?: true
    isComplete?: true
    startedAt?: true
    updatedAt?: true
    completedAt?: true
    endedAt?: true
    interfaceType?: true
    language?: true
    lastActivityAt?: true
    roomId?: true
    sessionId?: true
    _all?: true
  }

  export type Response_tree_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_tree_sessions to aggregate.
     */
    where?: response_tree_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_sessions to fetch.
     */
    orderBy?: response_tree_sessionsOrderByWithRelationInput | response_tree_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: response_tree_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned response_tree_sessions
    **/
    _count?: true | Response_tree_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Response_tree_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Response_tree_sessionsMaxAggregateInputType
  }

  export type GetResponse_tree_sessionsAggregateType<T extends Response_tree_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse_tree_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse_tree_sessions[P]>
      : GetScalarType<T[P], AggregateResponse_tree_sessions[P]>
  }




  export type response_tree_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_sessionsWhereInput
    orderBy?: response_tree_sessionsOrderByWithAggregationInput | response_tree_sessionsOrderByWithAggregationInput[]
    by: Response_tree_sessionsScalarFieldEnum[] | Response_tree_sessionsScalarFieldEnum
    having?: response_tree_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Response_tree_sessionsCountAggregateInputType | true
    _min?: Response_tree_sessionsMinAggregateInputType
    _max?: Response_tree_sessionsMaxAggregateInputType
  }

  export type Response_tree_sessionsGroupByOutputType = {
    id: string
    treeId: string
    userId: string | null
    deviceId: string | null
    currentNodeId: string | null
    metadata: JsonValue | null
    isComplete: boolean
    startedAt: Date
    updatedAt: Date
    completedAt: Date | null
    endedAt: Date | null
    interfaceType: string | null
    language: string | null
    lastActivityAt: Date | null
    roomId: string | null
    sessionId: string
    _count: Response_tree_sessionsCountAggregateOutputType | null
    _min: Response_tree_sessionsMinAggregateOutputType | null
    _max: Response_tree_sessionsMaxAggregateOutputType | null
  }

  type GetResponse_tree_sessionsGroupByPayload<T extends response_tree_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Response_tree_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Response_tree_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Response_tree_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Response_tree_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type response_tree_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    treeId?: boolean
    userId?: boolean
    deviceId?: boolean
    currentNodeId?: boolean
    metadata?: boolean
    isComplete?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    endedAt?: boolean
    interfaceType?: boolean
    language?: boolean
    lastActivityAt?: boolean
    roomId?: boolean
    sessionId?: boolean
    response_tree_history?: boolean | response_tree_sessions$response_tree_historyArgs<ExtArgs>
    response_tree_mobile_links?: boolean | response_tree_sessions$response_tree_mobile_linksArgs<ExtArgs>
    response_nodes?: boolean | response_tree_sessions$response_nodesArgs<ExtArgs>
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
    _count?: boolean | Response_tree_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_tree_sessions"]>

  export type response_tree_sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    treeId?: boolean
    userId?: boolean
    deviceId?: boolean
    currentNodeId?: boolean
    metadata?: boolean
    isComplete?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    endedAt?: boolean
    interfaceType?: boolean
    language?: boolean
    lastActivityAt?: boolean
    roomId?: boolean
    sessionId?: boolean
    response_nodes?: boolean | response_tree_sessions$response_nodesArgs<ExtArgs>
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_tree_sessions"]>

  export type response_tree_sessionsSelectScalar = {
    id?: boolean
    treeId?: boolean
    userId?: boolean
    deviceId?: boolean
    currentNodeId?: boolean
    metadata?: boolean
    isComplete?: boolean
    startedAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    endedAt?: boolean
    interfaceType?: boolean
    language?: boolean
    lastActivityAt?: boolean
    roomId?: boolean
    sessionId?: boolean
  }

  export type response_tree_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_tree_history?: boolean | response_tree_sessions$response_tree_historyArgs<ExtArgs>
    response_tree_mobile_links?: boolean | response_tree_sessions$response_tree_mobile_linksArgs<ExtArgs>
    response_nodes?: boolean | response_tree_sessions$response_nodesArgs<ExtArgs>
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
    _count?: boolean | Response_tree_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type response_tree_sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_nodes?: boolean | response_tree_sessions$response_nodesArgs<ExtArgs>
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
  }

  export type $response_tree_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "response_tree_sessions"
    objects: {
      response_tree_history: Prisma.$response_tree_historyPayload<ExtArgs>[]
      response_tree_mobile_links: Prisma.$response_tree_mobile_linksPayload<ExtArgs>[]
      response_nodes: Prisma.$response_nodesPayload<ExtArgs> | null
      response_trees: Prisma.$response_treesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      treeId: string
      userId: string | null
      deviceId: string | null
      currentNodeId: string | null
      metadata: Prisma.JsonValue | null
      isComplete: boolean
      startedAt: Date
      updatedAt: Date
      completedAt: Date | null
      endedAt: Date | null
      interfaceType: string | null
      language: string | null
      lastActivityAt: Date | null
      roomId: string | null
      sessionId: string
    }, ExtArgs["result"]["response_tree_sessions"]>
    composites: {}
  }

  type response_tree_sessionsGetPayload<S extends boolean | null | undefined | response_tree_sessionsDefaultArgs> = $Result.GetResult<Prisma.$response_tree_sessionsPayload, S>

  type response_tree_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<response_tree_sessionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Response_tree_sessionsCountAggregateInputType | true
    }

  export interface response_tree_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['response_tree_sessions'], meta: { name: 'response_tree_sessions' } }
    /**
     * Find zero or one Response_tree_sessions that matches the filter.
     * @param {response_tree_sessionsFindUniqueArgs} args - Arguments to find a Response_tree_sessions
     * @example
     * // Get one Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends response_tree_sessionsFindUniqueArgs>(args: SelectSubset<T, response_tree_sessionsFindUniqueArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Response_tree_sessions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {response_tree_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Response_tree_sessions
     * @example
     * // Get one Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends response_tree_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, response_tree_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Response_tree_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_sessionsFindFirstArgs} args - Arguments to find a Response_tree_sessions
     * @example
     * // Get one Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends response_tree_sessionsFindFirstArgs>(args?: SelectSubset<T, response_tree_sessionsFindFirstArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Response_tree_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_sessionsFindFirstOrThrowArgs} args - Arguments to find a Response_tree_sessions
     * @example
     * // Get one Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends response_tree_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, response_tree_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Response_tree_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.findMany()
     * 
     * // Get first 10 Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const response_tree_sessionsWithIdOnly = await prisma.response_tree_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends response_tree_sessionsFindManyArgs>(args?: SelectSubset<T, response_tree_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Response_tree_sessions.
     * @param {response_tree_sessionsCreateArgs} args - Arguments to create a Response_tree_sessions.
     * @example
     * // Create one Response_tree_sessions
     * const Response_tree_sessions = await prisma.response_tree_sessions.create({
     *   data: {
     *     // ... data to create a Response_tree_sessions
     *   }
     * })
     * 
     */
    create<T extends response_tree_sessionsCreateArgs>(args: SelectSubset<T, response_tree_sessionsCreateArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Response_tree_sessions.
     * @param {response_tree_sessionsCreateManyArgs} args - Arguments to create many Response_tree_sessions.
     * @example
     * // Create many Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends response_tree_sessionsCreateManyArgs>(args?: SelectSubset<T, response_tree_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Response_tree_sessions and returns the data saved in the database.
     * @param {response_tree_sessionsCreateManyAndReturnArgs} args - Arguments to create many Response_tree_sessions.
     * @example
     * // Create many Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Response_tree_sessions and only return the `id`
     * const response_tree_sessionsWithIdOnly = await prisma.response_tree_sessions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends response_tree_sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, response_tree_sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Response_tree_sessions.
     * @param {response_tree_sessionsDeleteArgs} args - Arguments to delete one Response_tree_sessions.
     * @example
     * // Delete one Response_tree_sessions
     * const Response_tree_sessions = await prisma.response_tree_sessions.delete({
     *   where: {
     *     // ... filter to delete one Response_tree_sessions
     *   }
     * })
     * 
     */
    delete<T extends response_tree_sessionsDeleteArgs>(args: SelectSubset<T, response_tree_sessionsDeleteArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Response_tree_sessions.
     * @param {response_tree_sessionsUpdateArgs} args - Arguments to update one Response_tree_sessions.
     * @example
     * // Update one Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends response_tree_sessionsUpdateArgs>(args: SelectSubset<T, response_tree_sessionsUpdateArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Response_tree_sessions.
     * @param {response_tree_sessionsDeleteManyArgs} args - Arguments to filter Response_tree_sessions to delete.
     * @example
     * // Delete a few Response_tree_sessions
     * const { count } = await prisma.response_tree_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends response_tree_sessionsDeleteManyArgs>(args?: SelectSubset<T, response_tree_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Response_tree_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends response_tree_sessionsUpdateManyArgs>(args: SelectSubset<T, response_tree_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Response_tree_sessions.
     * @param {response_tree_sessionsUpsertArgs} args - Arguments to update or create a Response_tree_sessions.
     * @example
     * // Update or create a Response_tree_sessions
     * const response_tree_sessions = await prisma.response_tree_sessions.upsert({
     *   create: {
     *     // ... data to create a Response_tree_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response_tree_sessions we want to update
     *   }
     * })
     */
    upsert<T extends response_tree_sessionsUpsertArgs>(args: SelectSubset<T, response_tree_sessionsUpsertArgs<ExtArgs>>): Prisma__response_tree_sessionsClient<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Response_tree_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_sessionsCountArgs} args - Arguments to filter Response_tree_sessions to count.
     * @example
     * // Count the number of Response_tree_sessions
     * const count = await prisma.response_tree_sessions.count({
     *   where: {
     *     // ... the filter for the Response_tree_sessions we want to count
     *   }
     * })
    **/
    count<T extends response_tree_sessionsCountArgs>(
      args?: Subset<T, response_tree_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Response_tree_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response_tree_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Response_tree_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Response_tree_sessionsAggregateArgs>(args: Subset<T, Response_tree_sessionsAggregateArgs>): Prisma.PrismaPromise<GetResponse_tree_sessionsAggregateType<T>>

    /**
     * Group by Response_tree_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends response_tree_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: response_tree_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: response_tree_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, response_tree_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponse_tree_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the response_tree_sessions model
   */
  readonly fields: response_tree_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for response_tree_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__response_tree_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response_tree_history<T extends response_tree_sessions$response_tree_historyArgs<ExtArgs> = {}>(args?: Subset<T, response_tree_sessions$response_tree_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_historyPayload<ExtArgs>, T, "findMany"> | Null>
    response_tree_mobile_links<T extends response_tree_sessions$response_tree_mobile_linksArgs<ExtArgs> = {}>(args?: Subset<T, response_tree_sessions$response_tree_mobile_linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_mobile_linksPayload<ExtArgs>, T, "findMany"> | Null>
    response_nodes<T extends response_tree_sessions$response_nodesArgs<ExtArgs> = {}>(args?: Subset<T, response_tree_sessions$response_nodesArgs<ExtArgs>>): Prisma__response_nodesClient<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    response_trees<T extends response_treesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, response_treesDefaultArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the response_tree_sessions model
   */ 
  interface response_tree_sessionsFieldRefs {
    readonly id: FieldRef<"response_tree_sessions", 'String'>
    readonly treeId: FieldRef<"response_tree_sessions", 'String'>
    readonly userId: FieldRef<"response_tree_sessions", 'String'>
    readonly deviceId: FieldRef<"response_tree_sessions", 'String'>
    readonly currentNodeId: FieldRef<"response_tree_sessions", 'String'>
    readonly metadata: FieldRef<"response_tree_sessions", 'Json'>
    readonly isComplete: FieldRef<"response_tree_sessions", 'Boolean'>
    readonly startedAt: FieldRef<"response_tree_sessions", 'DateTime'>
    readonly updatedAt: FieldRef<"response_tree_sessions", 'DateTime'>
    readonly completedAt: FieldRef<"response_tree_sessions", 'DateTime'>
    readonly endedAt: FieldRef<"response_tree_sessions", 'DateTime'>
    readonly interfaceType: FieldRef<"response_tree_sessions", 'String'>
    readonly language: FieldRef<"response_tree_sessions", 'String'>
    readonly lastActivityAt: FieldRef<"response_tree_sessions", 'DateTime'>
    readonly roomId: FieldRef<"response_tree_sessions", 'String'>
    readonly sessionId: FieldRef<"response_tree_sessions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * response_tree_sessions findUnique
   */
  export type response_tree_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_sessions to fetch.
     */
    where: response_tree_sessionsWhereUniqueInput
  }

  /**
   * response_tree_sessions findUniqueOrThrow
   */
  export type response_tree_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_sessions to fetch.
     */
    where: response_tree_sessionsWhereUniqueInput
  }

  /**
   * response_tree_sessions findFirst
   */
  export type response_tree_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_sessions to fetch.
     */
    where?: response_tree_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_sessions to fetch.
     */
    orderBy?: response_tree_sessionsOrderByWithRelationInput | response_tree_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_tree_sessions.
     */
    cursor?: response_tree_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_tree_sessions.
     */
    distinct?: Response_tree_sessionsScalarFieldEnum | Response_tree_sessionsScalarFieldEnum[]
  }

  /**
   * response_tree_sessions findFirstOrThrow
   */
  export type response_tree_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_sessions to fetch.
     */
    where?: response_tree_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_sessions to fetch.
     */
    orderBy?: response_tree_sessionsOrderByWithRelationInput | response_tree_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_tree_sessions.
     */
    cursor?: response_tree_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_tree_sessions.
     */
    distinct?: Response_tree_sessionsScalarFieldEnum | Response_tree_sessionsScalarFieldEnum[]
  }

  /**
   * response_tree_sessions findMany
   */
  export type response_tree_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_sessions to fetch.
     */
    where?: response_tree_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_sessions to fetch.
     */
    orderBy?: response_tree_sessionsOrderByWithRelationInput | response_tree_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing response_tree_sessions.
     */
    cursor?: response_tree_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_sessions.
     */
    skip?: number
    distinct?: Response_tree_sessionsScalarFieldEnum | Response_tree_sessionsScalarFieldEnum[]
  }

  /**
   * response_tree_sessions create
   */
  export type response_tree_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a response_tree_sessions.
     */
    data: XOR<response_tree_sessionsCreateInput, response_tree_sessionsUncheckedCreateInput>
  }

  /**
   * response_tree_sessions createMany
   */
  export type response_tree_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many response_tree_sessions.
     */
    data: response_tree_sessionsCreateManyInput | response_tree_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * response_tree_sessions createManyAndReturn
   */
  export type response_tree_sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many response_tree_sessions.
     */
    data: response_tree_sessionsCreateManyInput | response_tree_sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * response_tree_sessions update
   */
  export type response_tree_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a response_tree_sessions.
     */
    data: XOR<response_tree_sessionsUpdateInput, response_tree_sessionsUncheckedUpdateInput>
    /**
     * Choose, which response_tree_sessions to update.
     */
    where: response_tree_sessionsWhereUniqueInput
  }

  /**
   * response_tree_sessions updateMany
   */
  export type response_tree_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update response_tree_sessions.
     */
    data: XOR<response_tree_sessionsUpdateManyMutationInput, response_tree_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which response_tree_sessions to update
     */
    where?: response_tree_sessionsWhereInput
  }

  /**
   * response_tree_sessions upsert
   */
  export type response_tree_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the response_tree_sessions to update in case it exists.
     */
    where: response_tree_sessionsWhereUniqueInput
    /**
     * In case the response_tree_sessions found by the `where` argument doesn't exist, create a new response_tree_sessions with this data.
     */
    create: XOR<response_tree_sessionsCreateInput, response_tree_sessionsUncheckedCreateInput>
    /**
     * In case the response_tree_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<response_tree_sessionsUpdateInput, response_tree_sessionsUncheckedUpdateInput>
  }

  /**
   * response_tree_sessions delete
   */
  export type response_tree_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    /**
     * Filter which response_tree_sessions to delete.
     */
    where: response_tree_sessionsWhereUniqueInput
  }

  /**
   * response_tree_sessions deleteMany
   */
  export type response_tree_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_tree_sessions to delete
     */
    where?: response_tree_sessionsWhereInput
  }

  /**
   * response_tree_sessions.response_tree_history
   */
  export type response_tree_sessions$response_tree_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_history
     */
    select?: response_tree_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_historyInclude<ExtArgs> | null
    where?: response_tree_historyWhereInput
    orderBy?: response_tree_historyOrderByWithRelationInput | response_tree_historyOrderByWithRelationInput[]
    cursor?: response_tree_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Response_tree_historyScalarFieldEnum | Response_tree_historyScalarFieldEnum[]
  }

  /**
   * response_tree_sessions.response_tree_mobile_links
   */
  export type response_tree_sessions$response_tree_mobile_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_mobile_links
     */
    select?: response_tree_mobile_linksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_mobile_linksInclude<ExtArgs> | null
    where?: response_tree_mobile_linksWhereInput
    orderBy?: response_tree_mobile_linksOrderByWithRelationInput | response_tree_mobile_linksOrderByWithRelationInput[]
    cursor?: response_tree_mobile_linksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Response_tree_mobile_linksScalarFieldEnum | Response_tree_mobile_linksScalarFieldEnum[]
  }

  /**
   * response_tree_sessions.response_nodes
   */
  export type response_tree_sessions$response_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    where?: response_nodesWhereInput
  }

  /**
   * response_tree_sessions without action
   */
  export type response_tree_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model response_tree_versions
   */

  export type AggregateResponse_tree_versions = {
    _count: Response_tree_versionsCountAggregateOutputType | null
    _avg: Response_tree_versionsAvgAggregateOutputType | null
    _sum: Response_tree_versionsSumAggregateOutputType | null
    _min: Response_tree_versionsMinAggregateOutputType | null
    _max: Response_tree_versionsMaxAggregateOutputType | null
  }

  export type Response_tree_versionsAvgAggregateOutputType = {
    version: number | null
  }

  export type Response_tree_versionsSumAggregateOutputType = {
    version: number | null
  }

  export type Response_tree_versionsMinAggregateOutputType = {
    id: string | null
    treeId: string | null
    version: number | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type Response_tree_versionsMaxAggregateOutputType = {
    id: string | null
    treeId: string | null
    version: number | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type Response_tree_versionsCountAggregateOutputType = {
    id: number
    treeId: number
    version: number
    snapshot: number
    createdAt: number
    createdBy: number
    data: number
    _all: number
  }


  export type Response_tree_versionsAvgAggregateInputType = {
    version?: true
  }

  export type Response_tree_versionsSumAggregateInputType = {
    version?: true
  }

  export type Response_tree_versionsMinAggregateInputType = {
    id?: true
    treeId?: true
    version?: true
    createdAt?: true
    createdBy?: true
  }

  export type Response_tree_versionsMaxAggregateInputType = {
    id?: true
    treeId?: true
    version?: true
    createdAt?: true
    createdBy?: true
  }

  export type Response_tree_versionsCountAggregateInputType = {
    id?: true
    treeId?: true
    version?: true
    snapshot?: true
    createdAt?: true
    createdBy?: true
    data?: true
    _all?: true
  }

  export type Response_tree_versionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_tree_versions to aggregate.
     */
    where?: response_tree_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_versions to fetch.
     */
    orderBy?: response_tree_versionsOrderByWithRelationInput | response_tree_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: response_tree_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned response_tree_versions
    **/
    _count?: true | Response_tree_versionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Response_tree_versionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Response_tree_versionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Response_tree_versionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Response_tree_versionsMaxAggregateInputType
  }

  export type GetResponse_tree_versionsAggregateType<T extends Response_tree_versionsAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse_tree_versions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse_tree_versions[P]>
      : GetScalarType<T[P], AggregateResponse_tree_versions[P]>
  }




  export type response_tree_versionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_tree_versionsWhereInput
    orderBy?: response_tree_versionsOrderByWithAggregationInput | response_tree_versionsOrderByWithAggregationInput[]
    by: Response_tree_versionsScalarFieldEnum[] | Response_tree_versionsScalarFieldEnum
    having?: response_tree_versionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Response_tree_versionsCountAggregateInputType | true
    _avg?: Response_tree_versionsAvgAggregateInputType
    _sum?: Response_tree_versionsSumAggregateInputType
    _min?: Response_tree_versionsMinAggregateInputType
    _max?: Response_tree_versionsMaxAggregateInputType
  }

  export type Response_tree_versionsGroupByOutputType = {
    id: string
    treeId: string
    version: number
    snapshot: JsonValue
    createdAt: Date
    createdBy: string | null
    data: JsonValue | null
    _count: Response_tree_versionsCountAggregateOutputType | null
    _avg: Response_tree_versionsAvgAggregateOutputType | null
    _sum: Response_tree_versionsSumAggregateOutputType | null
    _min: Response_tree_versionsMinAggregateOutputType | null
    _max: Response_tree_versionsMaxAggregateOutputType | null
  }

  type GetResponse_tree_versionsGroupByPayload<T extends response_tree_versionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Response_tree_versionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Response_tree_versionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Response_tree_versionsGroupByOutputType[P]>
            : GetScalarType<T[P], Response_tree_versionsGroupByOutputType[P]>
        }
      >
    >


  export type response_tree_versionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    treeId?: boolean
    version?: boolean
    snapshot?: boolean
    createdAt?: boolean
    createdBy?: boolean
    data?: boolean
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_tree_versions"]>

  export type response_tree_versionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    treeId?: boolean
    version?: boolean
    snapshot?: boolean
    createdAt?: boolean
    createdBy?: boolean
    data?: boolean
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_tree_versions"]>

  export type response_tree_versionsSelectScalar = {
    id?: boolean
    treeId?: boolean
    version?: boolean
    snapshot?: boolean
    createdAt?: boolean
    createdBy?: boolean
    data?: boolean
  }

  export type response_tree_versionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
  }
  export type response_tree_versionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_trees?: boolean | response_treesDefaultArgs<ExtArgs>
  }

  export type $response_tree_versionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "response_tree_versions"
    objects: {
      response_trees: Prisma.$response_treesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      treeId: string
      version: number
      snapshot: Prisma.JsonValue
      createdAt: Date
      createdBy: string | null
      data: Prisma.JsonValue | null
    }, ExtArgs["result"]["response_tree_versions"]>
    composites: {}
  }

  type response_tree_versionsGetPayload<S extends boolean | null | undefined | response_tree_versionsDefaultArgs> = $Result.GetResult<Prisma.$response_tree_versionsPayload, S>

  type response_tree_versionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<response_tree_versionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Response_tree_versionsCountAggregateInputType | true
    }

  export interface response_tree_versionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['response_tree_versions'], meta: { name: 'response_tree_versions' } }
    /**
     * Find zero or one Response_tree_versions that matches the filter.
     * @param {response_tree_versionsFindUniqueArgs} args - Arguments to find a Response_tree_versions
     * @example
     * // Get one Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends response_tree_versionsFindUniqueArgs>(args: SelectSubset<T, response_tree_versionsFindUniqueArgs<ExtArgs>>): Prisma__response_tree_versionsClient<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Response_tree_versions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {response_tree_versionsFindUniqueOrThrowArgs} args - Arguments to find a Response_tree_versions
     * @example
     * // Get one Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends response_tree_versionsFindUniqueOrThrowArgs>(args: SelectSubset<T, response_tree_versionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__response_tree_versionsClient<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Response_tree_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_versionsFindFirstArgs} args - Arguments to find a Response_tree_versions
     * @example
     * // Get one Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends response_tree_versionsFindFirstArgs>(args?: SelectSubset<T, response_tree_versionsFindFirstArgs<ExtArgs>>): Prisma__response_tree_versionsClient<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Response_tree_versions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_versionsFindFirstOrThrowArgs} args - Arguments to find a Response_tree_versions
     * @example
     * // Get one Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends response_tree_versionsFindFirstOrThrowArgs>(args?: SelectSubset<T, response_tree_versionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__response_tree_versionsClient<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Response_tree_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_versionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.findMany()
     * 
     * // Get first 10 Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const response_tree_versionsWithIdOnly = await prisma.response_tree_versions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends response_tree_versionsFindManyArgs>(args?: SelectSubset<T, response_tree_versionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Response_tree_versions.
     * @param {response_tree_versionsCreateArgs} args - Arguments to create a Response_tree_versions.
     * @example
     * // Create one Response_tree_versions
     * const Response_tree_versions = await prisma.response_tree_versions.create({
     *   data: {
     *     // ... data to create a Response_tree_versions
     *   }
     * })
     * 
     */
    create<T extends response_tree_versionsCreateArgs>(args: SelectSubset<T, response_tree_versionsCreateArgs<ExtArgs>>): Prisma__response_tree_versionsClient<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Response_tree_versions.
     * @param {response_tree_versionsCreateManyArgs} args - Arguments to create many Response_tree_versions.
     * @example
     * // Create many Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends response_tree_versionsCreateManyArgs>(args?: SelectSubset<T, response_tree_versionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Response_tree_versions and returns the data saved in the database.
     * @param {response_tree_versionsCreateManyAndReturnArgs} args - Arguments to create many Response_tree_versions.
     * @example
     * // Create many Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Response_tree_versions and only return the `id`
     * const response_tree_versionsWithIdOnly = await prisma.response_tree_versions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends response_tree_versionsCreateManyAndReturnArgs>(args?: SelectSubset<T, response_tree_versionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Response_tree_versions.
     * @param {response_tree_versionsDeleteArgs} args - Arguments to delete one Response_tree_versions.
     * @example
     * // Delete one Response_tree_versions
     * const Response_tree_versions = await prisma.response_tree_versions.delete({
     *   where: {
     *     // ... filter to delete one Response_tree_versions
     *   }
     * })
     * 
     */
    delete<T extends response_tree_versionsDeleteArgs>(args: SelectSubset<T, response_tree_versionsDeleteArgs<ExtArgs>>): Prisma__response_tree_versionsClient<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Response_tree_versions.
     * @param {response_tree_versionsUpdateArgs} args - Arguments to update one Response_tree_versions.
     * @example
     * // Update one Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends response_tree_versionsUpdateArgs>(args: SelectSubset<T, response_tree_versionsUpdateArgs<ExtArgs>>): Prisma__response_tree_versionsClient<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Response_tree_versions.
     * @param {response_tree_versionsDeleteManyArgs} args - Arguments to filter Response_tree_versions to delete.
     * @example
     * // Delete a few Response_tree_versions
     * const { count } = await prisma.response_tree_versions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends response_tree_versionsDeleteManyArgs>(args?: SelectSubset<T, response_tree_versionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Response_tree_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_versionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends response_tree_versionsUpdateManyArgs>(args: SelectSubset<T, response_tree_versionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Response_tree_versions.
     * @param {response_tree_versionsUpsertArgs} args - Arguments to update or create a Response_tree_versions.
     * @example
     * // Update or create a Response_tree_versions
     * const response_tree_versions = await prisma.response_tree_versions.upsert({
     *   create: {
     *     // ... data to create a Response_tree_versions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response_tree_versions we want to update
     *   }
     * })
     */
    upsert<T extends response_tree_versionsUpsertArgs>(args: SelectSubset<T, response_tree_versionsUpsertArgs<ExtArgs>>): Prisma__response_tree_versionsClient<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Response_tree_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_versionsCountArgs} args - Arguments to filter Response_tree_versions to count.
     * @example
     * // Count the number of Response_tree_versions
     * const count = await prisma.response_tree_versions.count({
     *   where: {
     *     // ... the filter for the Response_tree_versions we want to count
     *   }
     * })
    **/
    count<T extends response_tree_versionsCountArgs>(
      args?: Subset<T, response_tree_versionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Response_tree_versionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response_tree_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Response_tree_versionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Response_tree_versionsAggregateArgs>(args: Subset<T, Response_tree_versionsAggregateArgs>): Prisma.PrismaPromise<GetResponse_tree_versionsAggregateType<T>>

    /**
     * Group by Response_tree_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_tree_versionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends response_tree_versionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: response_tree_versionsGroupByArgs['orderBy'] }
        : { orderBy?: response_tree_versionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, response_tree_versionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponse_tree_versionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the response_tree_versions model
   */
  readonly fields: response_tree_versionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for response_tree_versions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__response_tree_versionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response_trees<T extends response_treesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, response_treesDefaultArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the response_tree_versions model
   */ 
  interface response_tree_versionsFieldRefs {
    readonly id: FieldRef<"response_tree_versions", 'String'>
    readonly treeId: FieldRef<"response_tree_versions", 'String'>
    readonly version: FieldRef<"response_tree_versions", 'Int'>
    readonly snapshot: FieldRef<"response_tree_versions", 'Json'>
    readonly createdAt: FieldRef<"response_tree_versions", 'DateTime'>
    readonly createdBy: FieldRef<"response_tree_versions", 'String'>
    readonly data: FieldRef<"response_tree_versions", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * response_tree_versions findUnique
   */
  export type response_tree_versionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_versions to fetch.
     */
    where: response_tree_versionsWhereUniqueInput
  }

  /**
   * response_tree_versions findUniqueOrThrow
   */
  export type response_tree_versionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_versions to fetch.
     */
    where: response_tree_versionsWhereUniqueInput
  }

  /**
   * response_tree_versions findFirst
   */
  export type response_tree_versionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_versions to fetch.
     */
    where?: response_tree_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_versions to fetch.
     */
    orderBy?: response_tree_versionsOrderByWithRelationInput | response_tree_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_tree_versions.
     */
    cursor?: response_tree_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_tree_versions.
     */
    distinct?: Response_tree_versionsScalarFieldEnum | Response_tree_versionsScalarFieldEnum[]
  }

  /**
   * response_tree_versions findFirstOrThrow
   */
  export type response_tree_versionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_versions to fetch.
     */
    where?: response_tree_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_versions to fetch.
     */
    orderBy?: response_tree_versionsOrderByWithRelationInput | response_tree_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_tree_versions.
     */
    cursor?: response_tree_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_tree_versions.
     */
    distinct?: Response_tree_versionsScalarFieldEnum | Response_tree_versionsScalarFieldEnum[]
  }

  /**
   * response_tree_versions findMany
   */
  export type response_tree_versionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    /**
     * Filter, which response_tree_versions to fetch.
     */
    where?: response_tree_versionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_tree_versions to fetch.
     */
    orderBy?: response_tree_versionsOrderByWithRelationInput | response_tree_versionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing response_tree_versions.
     */
    cursor?: response_tree_versionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_tree_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_tree_versions.
     */
    skip?: number
    distinct?: Response_tree_versionsScalarFieldEnum | Response_tree_versionsScalarFieldEnum[]
  }

  /**
   * response_tree_versions create
   */
  export type response_tree_versionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    /**
     * The data needed to create a response_tree_versions.
     */
    data: XOR<response_tree_versionsCreateInput, response_tree_versionsUncheckedCreateInput>
  }

  /**
   * response_tree_versions createMany
   */
  export type response_tree_versionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many response_tree_versions.
     */
    data: response_tree_versionsCreateManyInput | response_tree_versionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * response_tree_versions createManyAndReturn
   */
  export type response_tree_versionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many response_tree_versions.
     */
    data: response_tree_versionsCreateManyInput | response_tree_versionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * response_tree_versions update
   */
  export type response_tree_versionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    /**
     * The data needed to update a response_tree_versions.
     */
    data: XOR<response_tree_versionsUpdateInput, response_tree_versionsUncheckedUpdateInput>
    /**
     * Choose, which response_tree_versions to update.
     */
    where: response_tree_versionsWhereUniqueInput
  }

  /**
   * response_tree_versions updateMany
   */
  export type response_tree_versionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update response_tree_versions.
     */
    data: XOR<response_tree_versionsUpdateManyMutationInput, response_tree_versionsUncheckedUpdateManyInput>
    /**
     * Filter which response_tree_versions to update
     */
    where?: response_tree_versionsWhereInput
  }

  /**
   * response_tree_versions upsert
   */
  export type response_tree_versionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    /**
     * The filter to search for the response_tree_versions to update in case it exists.
     */
    where: response_tree_versionsWhereUniqueInput
    /**
     * In case the response_tree_versions found by the `where` argument doesn't exist, create a new response_tree_versions with this data.
     */
    create: XOR<response_tree_versionsCreateInput, response_tree_versionsUncheckedCreateInput>
    /**
     * In case the response_tree_versions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<response_tree_versionsUpdateInput, response_tree_versionsUncheckedUpdateInput>
  }

  /**
   * response_tree_versions delete
   */
  export type response_tree_versionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    /**
     * Filter which response_tree_versions to delete.
     */
    where: response_tree_versionsWhereUniqueInput
  }

  /**
   * response_tree_versions deleteMany
   */
  export type response_tree_versionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_tree_versions to delete
     */
    where?: response_tree_versionsWhereInput
  }

  /**
   * response_tree_versions without action
   */
  export type response_tree_versionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
  }


  /**
   * Model response_trees
   */

  export type AggregateResponse_trees = {
    _count: Response_treesCountAggregateOutputType | null
    _avg: Response_treesAvgAggregateOutputType | null
    _sum: Response_treesSumAggregateOutputType | null
    _min: Response_treesMinAggregateOutputType | null
    _max: Response_treesMaxAggregateOutputType | null
  }

  export type Response_treesAvgAggregateOutputType = {
    version: number | null
  }

  export type Response_treesSumAggregateOutputType = {
    version: number | null
  }

  export type Response_treesMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Response_treesMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type Response_treesCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    isPublished: number
    publishedAt: number
    version: number
    createdAt: number
    updatedAt: number
    isActive: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type Response_treesAvgAggregateInputType = {
    version?: true
  }

  export type Response_treesSumAggregateInputType = {
    version?: true
  }

  export type Response_treesMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isPublished?: true
    publishedAt?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Response_treesMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isPublished?: true
    publishedAt?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type Response_treesCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isPublished?: true
    publishedAt?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type Response_treesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_trees to aggregate.
     */
    where?: response_treesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_trees to fetch.
     */
    orderBy?: response_treesOrderByWithRelationInput | response_treesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: response_treesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_trees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_trees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned response_trees
    **/
    _count?: true | Response_treesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Response_treesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Response_treesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Response_treesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Response_treesMaxAggregateInputType
  }

  export type GetResponse_treesAggregateType<T extends Response_treesAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse_trees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse_trees[P]>
      : GetScalarType<T[P], AggregateResponse_trees[P]>
  }




  export type response_treesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: response_treesWhereInput
    orderBy?: response_treesOrderByWithAggregationInput | response_treesOrderByWithAggregationInput[]
    by: Response_treesScalarFieldEnum[] | Response_treesScalarFieldEnum
    having?: response_treesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Response_treesCountAggregateInputType | true
    _avg?: Response_treesAvgAggregateInputType
    _sum?: Response_treesSumAggregateInputType
    _min?: Response_treesMinAggregateInputType
    _max?: Response_treesMaxAggregateInputType
  }

  export type Response_treesGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    isPublished: boolean
    publishedAt: Date | null
    version: number
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: Response_treesCountAggregateOutputType | null
    _avg: Response_treesAvgAggregateOutputType | null
    _sum: Response_treesSumAggregateOutputType | null
    _min: Response_treesMinAggregateOutputType | null
    _max: Response_treesMaxAggregateOutputType | null
  }

  type GetResponse_treesGroupByPayload<T extends response_treesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Response_treesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Response_treesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Response_treesGroupByOutputType[P]>
            : GetScalarType<T[P], Response_treesGroupByOutputType[P]>
        }
      >
    >


  export type response_treesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
    response_nodes?: boolean | response_trees$response_nodesArgs<ExtArgs>
    response_tree_sessions?: boolean | response_trees$response_tree_sessionsArgs<ExtArgs>
    response_tree_versions?: boolean | response_trees$response_tree_versionsArgs<ExtArgs>
    _count?: boolean | Response_treesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response_trees"]>

  export type response_treesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["response_trees"]>

  export type response_treesSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }

  export type response_treesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response_nodes?: boolean | response_trees$response_nodesArgs<ExtArgs>
    response_tree_sessions?: boolean | response_trees$response_tree_sessionsArgs<ExtArgs>
    response_tree_versions?: boolean | response_trees$response_tree_versionsArgs<ExtArgs>
    _count?: boolean | Response_treesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type response_treesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $response_treesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "response_trees"
    objects: {
      response_nodes: Prisma.$response_nodesPayload<ExtArgs>[]
      response_tree_sessions: Prisma.$response_tree_sessionsPayload<ExtArgs>[]
      response_tree_versions: Prisma.$response_tree_versionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      isPublished: boolean
      publishedAt: Date | null
      version: number
      createdAt: Date
      updatedAt: Date
      isActive: boolean
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["response_trees"]>
    composites: {}
  }

  type response_treesGetPayload<S extends boolean | null | undefined | response_treesDefaultArgs> = $Result.GetResult<Prisma.$response_treesPayload, S>

  type response_treesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<response_treesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Response_treesCountAggregateInputType | true
    }

  export interface response_treesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['response_trees'], meta: { name: 'response_trees' } }
    /**
     * Find zero or one Response_trees that matches the filter.
     * @param {response_treesFindUniqueArgs} args - Arguments to find a Response_trees
     * @example
     * // Get one Response_trees
     * const response_trees = await prisma.response_trees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends response_treesFindUniqueArgs>(args: SelectSubset<T, response_treesFindUniqueArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Response_trees that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {response_treesFindUniqueOrThrowArgs} args - Arguments to find a Response_trees
     * @example
     * // Get one Response_trees
     * const response_trees = await prisma.response_trees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends response_treesFindUniqueOrThrowArgs>(args: SelectSubset<T, response_treesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Response_trees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_treesFindFirstArgs} args - Arguments to find a Response_trees
     * @example
     * // Get one Response_trees
     * const response_trees = await prisma.response_trees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends response_treesFindFirstArgs>(args?: SelectSubset<T, response_treesFindFirstArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Response_trees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_treesFindFirstOrThrowArgs} args - Arguments to find a Response_trees
     * @example
     * // Get one Response_trees
     * const response_trees = await prisma.response_trees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends response_treesFindFirstOrThrowArgs>(args?: SelectSubset<T, response_treesFindFirstOrThrowArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Response_trees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_treesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Response_trees
     * const response_trees = await prisma.response_trees.findMany()
     * 
     * // Get first 10 Response_trees
     * const response_trees = await prisma.response_trees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const response_treesWithIdOnly = await prisma.response_trees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends response_treesFindManyArgs>(args?: SelectSubset<T, response_treesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Response_trees.
     * @param {response_treesCreateArgs} args - Arguments to create a Response_trees.
     * @example
     * // Create one Response_trees
     * const Response_trees = await prisma.response_trees.create({
     *   data: {
     *     // ... data to create a Response_trees
     *   }
     * })
     * 
     */
    create<T extends response_treesCreateArgs>(args: SelectSubset<T, response_treesCreateArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Response_trees.
     * @param {response_treesCreateManyArgs} args - Arguments to create many Response_trees.
     * @example
     * // Create many Response_trees
     * const response_trees = await prisma.response_trees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends response_treesCreateManyArgs>(args?: SelectSubset<T, response_treesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Response_trees and returns the data saved in the database.
     * @param {response_treesCreateManyAndReturnArgs} args - Arguments to create many Response_trees.
     * @example
     * // Create many Response_trees
     * const response_trees = await prisma.response_trees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Response_trees and only return the `id`
     * const response_treesWithIdOnly = await prisma.response_trees.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends response_treesCreateManyAndReturnArgs>(args?: SelectSubset<T, response_treesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Response_trees.
     * @param {response_treesDeleteArgs} args - Arguments to delete one Response_trees.
     * @example
     * // Delete one Response_trees
     * const Response_trees = await prisma.response_trees.delete({
     *   where: {
     *     // ... filter to delete one Response_trees
     *   }
     * })
     * 
     */
    delete<T extends response_treesDeleteArgs>(args: SelectSubset<T, response_treesDeleteArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Response_trees.
     * @param {response_treesUpdateArgs} args - Arguments to update one Response_trees.
     * @example
     * // Update one Response_trees
     * const response_trees = await prisma.response_trees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends response_treesUpdateArgs>(args: SelectSubset<T, response_treesUpdateArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Response_trees.
     * @param {response_treesDeleteManyArgs} args - Arguments to filter Response_trees to delete.
     * @example
     * // Delete a few Response_trees
     * const { count } = await prisma.response_trees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends response_treesDeleteManyArgs>(args?: SelectSubset<T, response_treesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Response_trees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_treesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Response_trees
     * const response_trees = await prisma.response_trees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends response_treesUpdateManyArgs>(args: SelectSubset<T, response_treesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Response_trees.
     * @param {response_treesUpsertArgs} args - Arguments to update or create a Response_trees.
     * @example
     * // Update or create a Response_trees
     * const response_trees = await prisma.response_trees.upsert({
     *   create: {
     *     // ... data to create a Response_trees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response_trees we want to update
     *   }
     * })
     */
    upsert<T extends response_treesUpsertArgs>(args: SelectSubset<T, response_treesUpsertArgs<ExtArgs>>): Prisma__response_treesClient<$Result.GetResult<Prisma.$response_treesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Response_trees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_treesCountArgs} args - Arguments to filter Response_trees to count.
     * @example
     * // Count the number of Response_trees
     * const count = await prisma.response_trees.count({
     *   where: {
     *     // ... the filter for the Response_trees we want to count
     *   }
     * })
    **/
    count<T extends response_treesCountArgs>(
      args?: Subset<T, response_treesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Response_treesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response_trees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Response_treesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Response_treesAggregateArgs>(args: Subset<T, Response_treesAggregateArgs>): Prisma.PrismaPromise<GetResponse_treesAggregateType<T>>

    /**
     * Group by Response_trees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {response_treesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends response_treesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: response_treesGroupByArgs['orderBy'] }
        : { orderBy?: response_treesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, response_treesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponse_treesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the response_trees model
   */
  readonly fields: response_treesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for response_trees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__response_treesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response_nodes<T extends response_trees$response_nodesArgs<ExtArgs> = {}>(args?: Subset<T, response_trees$response_nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_nodesPayload<ExtArgs>, T, "findMany"> | Null>
    response_tree_sessions<T extends response_trees$response_tree_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, response_trees$response_tree_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_sessionsPayload<ExtArgs>, T, "findMany"> | Null>
    response_tree_versions<T extends response_trees$response_tree_versionsArgs<ExtArgs> = {}>(args?: Subset<T, response_trees$response_tree_versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$response_tree_versionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the response_trees model
   */ 
  interface response_treesFieldRefs {
    readonly id: FieldRef<"response_trees", 'String'>
    readonly tenantId: FieldRef<"response_trees", 'String'>
    readonly name: FieldRef<"response_trees", 'String'>
    readonly description: FieldRef<"response_trees", 'String'>
    readonly isPublished: FieldRef<"response_trees", 'Boolean'>
    readonly publishedAt: FieldRef<"response_trees", 'DateTime'>
    readonly version: FieldRef<"response_trees", 'Int'>
    readonly createdAt: FieldRef<"response_trees", 'DateTime'>
    readonly updatedAt: FieldRef<"response_trees", 'DateTime'>
    readonly isActive: FieldRef<"response_trees", 'Boolean'>
    readonly deleted_at: FieldRef<"response_trees", 'DateTime'>
    readonly deleted_by: FieldRef<"response_trees", 'String'>
    readonly is_deleted: FieldRef<"response_trees", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * response_trees findUnique
   */
  export type response_treesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
    /**
     * Filter, which response_trees to fetch.
     */
    where: response_treesWhereUniqueInput
  }

  /**
   * response_trees findUniqueOrThrow
   */
  export type response_treesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
    /**
     * Filter, which response_trees to fetch.
     */
    where: response_treesWhereUniqueInput
  }

  /**
   * response_trees findFirst
   */
  export type response_treesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
    /**
     * Filter, which response_trees to fetch.
     */
    where?: response_treesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_trees to fetch.
     */
    orderBy?: response_treesOrderByWithRelationInput | response_treesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_trees.
     */
    cursor?: response_treesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_trees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_trees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_trees.
     */
    distinct?: Response_treesScalarFieldEnum | Response_treesScalarFieldEnum[]
  }

  /**
   * response_trees findFirstOrThrow
   */
  export type response_treesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
    /**
     * Filter, which response_trees to fetch.
     */
    where?: response_treesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_trees to fetch.
     */
    orderBy?: response_treesOrderByWithRelationInput | response_treesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for response_trees.
     */
    cursor?: response_treesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_trees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_trees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of response_trees.
     */
    distinct?: Response_treesScalarFieldEnum | Response_treesScalarFieldEnum[]
  }

  /**
   * response_trees findMany
   */
  export type response_treesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
    /**
     * Filter, which response_trees to fetch.
     */
    where?: response_treesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of response_trees to fetch.
     */
    orderBy?: response_treesOrderByWithRelationInput | response_treesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing response_trees.
     */
    cursor?: response_treesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` response_trees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` response_trees.
     */
    skip?: number
    distinct?: Response_treesScalarFieldEnum | Response_treesScalarFieldEnum[]
  }

  /**
   * response_trees create
   */
  export type response_treesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
    /**
     * The data needed to create a response_trees.
     */
    data: XOR<response_treesCreateInput, response_treesUncheckedCreateInput>
  }

  /**
   * response_trees createMany
   */
  export type response_treesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many response_trees.
     */
    data: response_treesCreateManyInput | response_treesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * response_trees createManyAndReturn
   */
  export type response_treesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many response_trees.
     */
    data: response_treesCreateManyInput | response_treesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * response_trees update
   */
  export type response_treesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
    /**
     * The data needed to update a response_trees.
     */
    data: XOR<response_treesUpdateInput, response_treesUncheckedUpdateInput>
    /**
     * Choose, which response_trees to update.
     */
    where: response_treesWhereUniqueInput
  }

  /**
   * response_trees updateMany
   */
  export type response_treesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update response_trees.
     */
    data: XOR<response_treesUpdateManyMutationInput, response_treesUncheckedUpdateManyInput>
    /**
     * Filter which response_trees to update
     */
    where?: response_treesWhereInput
  }

  /**
   * response_trees upsert
   */
  export type response_treesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
    /**
     * The filter to search for the response_trees to update in case it exists.
     */
    where: response_treesWhereUniqueInput
    /**
     * In case the response_trees found by the `where` argument doesn't exist, create a new response_trees with this data.
     */
    create: XOR<response_treesCreateInput, response_treesUncheckedCreateInput>
    /**
     * In case the response_trees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<response_treesUpdateInput, response_treesUncheckedUpdateInput>
  }

  /**
   * response_trees delete
   */
  export type response_treesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
    /**
     * Filter which response_trees to delete.
     */
    where: response_treesWhereUniqueInput
  }

  /**
   * response_trees deleteMany
   */
  export type response_treesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which response_trees to delete
     */
    where?: response_treesWhereInput
  }

  /**
   * response_trees.response_nodes
   */
  export type response_trees$response_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_nodes
     */
    select?: response_nodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_nodesInclude<ExtArgs> | null
    where?: response_nodesWhereInput
    orderBy?: response_nodesOrderByWithRelationInput | response_nodesOrderByWithRelationInput[]
    cursor?: response_nodesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Response_nodesScalarFieldEnum | Response_nodesScalarFieldEnum[]
  }

  /**
   * response_trees.response_tree_sessions
   */
  export type response_trees$response_tree_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_sessions
     */
    select?: response_tree_sessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_sessionsInclude<ExtArgs> | null
    where?: response_tree_sessionsWhereInput
    orderBy?: response_tree_sessionsOrderByWithRelationInput | response_tree_sessionsOrderByWithRelationInput[]
    cursor?: response_tree_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Response_tree_sessionsScalarFieldEnum | Response_tree_sessionsScalarFieldEnum[]
  }

  /**
   * response_trees.response_tree_versions
   */
  export type response_trees$response_tree_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_tree_versions
     */
    select?: response_tree_versionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_tree_versionsInclude<ExtArgs> | null
    where?: response_tree_versionsWhereInput
    orderBy?: response_tree_versionsOrderByWithRelationInput | response_tree_versionsOrderByWithRelationInput[]
    cursor?: response_tree_versionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Response_tree_versionsScalarFieldEnum | Response_tree_versionsScalarFieldEnum[]
  }

  /**
   * response_trees without action
   */
  export type response_treesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the response_trees
     */
    select?: response_treesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: response_treesInclude<ExtArgs> | null
  }


  /**
   * Model room_grades
   */

  export type AggregateRoom_grades = {
    _count: Room_gradesCountAggregateOutputType | null
    _min: Room_gradesMinAggregateOutputType | null
    _max: Room_gradesMaxAggregateOutputType | null
  }

  export type Room_gradesMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    code: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Room_gradesMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    code: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Room_gradesCountAggregateOutputType = {
    id: number
    tenant_id: number
    code: number
    name: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Room_gradesMinAggregateInputType = {
    id?: true
    tenant_id?: true
    code?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Room_gradesMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    code?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Room_gradesCountAggregateInputType = {
    id?: true
    tenant_id?: true
    code?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Room_gradesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which room_grades to aggregate.
     */
    where?: room_gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_grades to fetch.
     */
    orderBy?: room_gradesOrderByWithRelationInput | room_gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: room_gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned room_grades
    **/
    _count?: true | Room_gradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Room_gradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Room_gradesMaxAggregateInputType
  }

  export type GetRoom_gradesAggregateType<T extends Room_gradesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom_grades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom_grades[P]>
      : GetScalarType<T[P], AggregateRoom_grades[P]>
  }




  export type room_gradesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: room_gradesWhereInput
    orderBy?: room_gradesOrderByWithAggregationInput | room_gradesOrderByWithAggregationInput[]
    by: Room_gradesScalarFieldEnum[] | Room_gradesScalarFieldEnum
    having?: room_gradesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Room_gradesCountAggregateInputType | true
    _min?: Room_gradesMinAggregateInputType
    _max?: Room_gradesMaxAggregateInputType
  }

  export type Room_gradesGroupByOutputType = {
    id: string
    tenant_id: string
    code: string
    name: string
    description: string | null
    created_at: Date
    updated_at: Date
    _count: Room_gradesCountAggregateOutputType | null
    _min: Room_gradesMinAggregateOutputType | null
    _max: Room_gradesMaxAggregateOutputType | null
  }

  type GetRoom_gradesGroupByPayload<T extends room_gradesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Room_gradesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Room_gradesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Room_gradesGroupByOutputType[P]>
            : GetScalarType<T[P], Room_gradesGroupByOutputType[P]>
        }
      >
    >


  export type room_gradesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["room_grades"]>

  export type room_gradesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["room_grades"]>

  export type room_gradesSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $room_gradesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "room_grades"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      code: string
      name: string
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["room_grades"]>
    composites: {}
  }

  type room_gradesGetPayload<S extends boolean | null | undefined | room_gradesDefaultArgs> = $Result.GetResult<Prisma.$room_gradesPayload, S>

  type room_gradesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<room_gradesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Room_gradesCountAggregateInputType | true
    }

  export interface room_gradesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['room_grades'], meta: { name: 'room_grades' } }
    /**
     * Find zero or one Room_grades that matches the filter.
     * @param {room_gradesFindUniqueArgs} args - Arguments to find a Room_grades
     * @example
     * // Get one Room_grades
     * const room_grades = await prisma.room_grades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends room_gradesFindUniqueArgs>(args: SelectSubset<T, room_gradesFindUniqueArgs<ExtArgs>>): Prisma__room_gradesClient<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Room_grades that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {room_gradesFindUniqueOrThrowArgs} args - Arguments to find a Room_grades
     * @example
     * // Get one Room_grades
     * const room_grades = await prisma.room_grades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends room_gradesFindUniqueOrThrowArgs>(args: SelectSubset<T, room_gradesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__room_gradesClient<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Room_grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_gradesFindFirstArgs} args - Arguments to find a Room_grades
     * @example
     * // Get one Room_grades
     * const room_grades = await prisma.room_grades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends room_gradesFindFirstArgs>(args?: SelectSubset<T, room_gradesFindFirstArgs<ExtArgs>>): Prisma__room_gradesClient<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Room_grades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_gradesFindFirstOrThrowArgs} args - Arguments to find a Room_grades
     * @example
     * // Get one Room_grades
     * const room_grades = await prisma.room_grades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends room_gradesFindFirstOrThrowArgs>(args?: SelectSubset<T, room_gradesFindFirstOrThrowArgs<ExtArgs>>): Prisma__room_gradesClient<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Room_grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_gradesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Room_grades
     * const room_grades = await prisma.room_grades.findMany()
     * 
     * // Get first 10 Room_grades
     * const room_grades = await prisma.room_grades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const room_gradesWithIdOnly = await prisma.room_grades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends room_gradesFindManyArgs>(args?: SelectSubset<T, room_gradesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Room_grades.
     * @param {room_gradesCreateArgs} args - Arguments to create a Room_grades.
     * @example
     * // Create one Room_grades
     * const Room_grades = await prisma.room_grades.create({
     *   data: {
     *     // ... data to create a Room_grades
     *   }
     * })
     * 
     */
    create<T extends room_gradesCreateArgs>(args: SelectSubset<T, room_gradesCreateArgs<ExtArgs>>): Prisma__room_gradesClient<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Room_grades.
     * @param {room_gradesCreateManyArgs} args - Arguments to create many Room_grades.
     * @example
     * // Create many Room_grades
     * const room_grades = await prisma.room_grades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends room_gradesCreateManyArgs>(args?: SelectSubset<T, room_gradesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Room_grades and returns the data saved in the database.
     * @param {room_gradesCreateManyAndReturnArgs} args - Arguments to create many Room_grades.
     * @example
     * // Create many Room_grades
     * const room_grades = await prisma.room_grades.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Room_grades and only return the `id`
     * const room_gradesWithIdOnly = await prisma.room_grades.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends room_gradesCreateManyAndReturnArgs>(args?: SelectSubset<T, room_gradesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Room_grades.
     * @param {room_gradesDeleteArgs} args - Arguments to delete one Room_grades.
     * @example
     * // Delete one Room_grades
     * const Room_grades = await prisma.room_grades.delete({
     *   where: {
     *     // ... filter to delete one Room_grades
     *   }
     * })
     * 
     */
    delete<T extends room_gradesDeleteArgs>(args: SelectSubset<T, room_gradesDeleteArgs<ExtArgs>>): Prisma__room_gradesClient<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Room_grades.
     * @param {room_gradesUpdateArgs} args - Arguments to update one Room_grades.
     * @example
     * // Update one Room_grades
     * const room_grades = await prisma.room_grades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends room_gradesUpdateArgs>(args: SelectSubset<T, room_gradesUpdateArgs<ExtArgs>>): Prisma__room_gradesClient<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Room_grades.
     * @param {room_gradesDeleteManyArgs} args - Arguments to filter Room_grades to delete.
     * @example
     * // Delete a few Room_grades
     * const { count } = await prisma.room_grades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends room_gradesDeleteManyArgs>(args?: SelectSubset<T, room_gradesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Room_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_gradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Room_grades
     * const room_grades = await prisma.room_grades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends room_gradesUpdateManyArgs>(args: SelectSubset<T, room_gradesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room_grades.
     * @param {room_gradesUpsertArgs} args - Arguments to update or create a Room_grades.
     * @example
     * // Update or create a Room_grades
     * const room_grades = await prisma.room_grades.upsert({
     *   create: {
     *     // ... data to create a Room_grades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room_grades we want to update
     *   }
     * })
     */
    upsert<T extends room_gradesUpsertArgs>(args: SelectSubset<T, room_gradesUpsertArgs<ExtArgs>>): Prisma__room_gradesClient<$Result.GetResult<Prisma.$room_gradesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Room_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_gradesCountArgs} args - Arguments to filter Room_grades to count.
     * @example
     * // Count the number of Room_grades
     * const count = await prisma.room_grades.count({
     *   where: {
     *     // ... the filter for the Room_grades we want to count
     *   }
     * })
    **/
    count<T extends room_gradesCountArgs>(
      args?: Subset<T, room_gradesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Room_gradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Room_gradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Room_gradesAggregateArgs>(args: Subset<T, Room_gradesAggregateArgs>): Prisma.PrismaPromise<GetRoom_gradesAggregateType<T>>

    /**
     * Group by Room_grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {room_gradesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends room_gradesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: room_gradesGroupByArgs['orderBy'] }
        : { orderBy?: room_gradesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, room_gradesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoom_gradesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the room_grades model
   */
  readonly fields: room_gradesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for room_grades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__room_gradesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the room_grades model
   */ 
  interface room_gradesFieldRefs {
    readonly id: FieldRef<"room_grades", 'String'>
    readonly tenant_id: FieldRef<"room_grades", 'String'>
    readonly code: FieldRef<"room_grades", 'String'>
    readonly name: FieldRef<"room_grades", 'String'>
    readonly description: FieldRef<"room_grades", 'String'>
    readonly created_at: FieldRef<"room_grades", 'DateTime'>
    readonly updated_at: FieldRef<"room_grades", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * room_grades findUnique
   */
  export type room_gradesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
    /**
     * Filter, which room_grades to fetch.
     */
    where: room_gradesWhereUniqueInput
  }

  /**
   * room_grades findUniqueOrThrow
   */
  export type room_gradesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
    /**
     * Filter, which room_grades to fetch.
     */
    where: room_gradesWhereUniqueInput
  }

  /**
   * room_grades findFirst
   */
  export type room_gradesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
    /**
     * Filter, which room_grades to fetch.
     */
    where?: room_gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_grades to fetch.
     */
    orderBy?: room_gradesOrderByWithRelationInput | room_gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for room_grades.
     */
    cursor?: room_gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of room_grades.
     */
    distinct?: Room_gradesScalarFieldEnum | Room_gradesScalarFieldEnum[]
  }

  /**
   * room_grades findFirstOrThrow
   */
  export type room_gradesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
    /**
     * Filter, which room_grades to fetch.
     */
    where?: room_gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_grades to fetch.
     */
    orderBy?: room_gradesOrderByWithRelationInput | room_gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for room_grades.
     */
    cursor?: room_gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of room_grades.
     */
    distinct?: Room_gradesScalarFieldEnum | Room_gradesScalarFieldEnum[]
  }

  /**
   * room_grades findMany
   */
  export type room_gradesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
    /**
     * Filter, which room_grades to fetch.
     */
    where?: room_gradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of room_grades to fetch.
     */
    orderBy?: room_gradesOrderByWithRelationInput | room_gradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing room_grades.
     */
    cursor?: room_gradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` room_grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` room_grades.
     */
    skip?: number
    distinct?: Room_gradesScalarFieldEnum | Room_gradesScalarFieldEnum[]
  }

  /**
   * room_grades create
   */
  export type room_gradesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
    /**
     * The data needed to create a room_grades.
     */
    data: XOR<room_gradesCreateInput, room_gradesUncheckedCreateInput>
  }

  /**
   * room_grades createMany
   */
  export type room_gradesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many room_grades.
     */
    data: room_gradesCreateManyInput | room_gradesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * room_grades createManyAndReturn
   */
  export type room_gradesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many room_grades.
     */
    data: room_gradesCreateManyInput | room_gradesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * room_grades update
   */
  export type room_gradesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
    /**
     * The data needed to update a room_grades.
     */
    data: XOR<room_gradesUpdateInput, room_gradesUncheckedUpdateInput>
    /**
     * Choose, which room_grades to update.
     */
    where: room_gradesWhereUniqueInput
  }

  /**
   * room_grades updateMany
   */
  export type room_gradesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update room_grades.
     */
    data: XOR<room_gradesUpdateManyMutationInput, room_gradesUncheckedUpdateManyInput>
    /**
     * Filter which room_grades to update
     */
    where?: room_gradesWhereInput
  }

  /**
   * room_grades upsert
   */
  export type room_gradesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
    /**
     * The filter to search for the room_grades to update in case it exists.
     */
    where: room_gradesWhereUniqueInput
    /**
     * In case the room_grades found by the `where` argument doesn't exist, create a new room_grades with this data.
     */
    create: XOR<room_gradesCreateInput, room_gradesUncheckedCreateInput>
    /**
     * In case the room_grades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<room_gradesUpdateInput, room_gradesUncheckedUpdateInput>
  }

  /**
   * room_grades delete
   */
  export type room_gradesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
    /**
     * Filter which room_grades to delete.
     */
    where: room_gradesWhereUniqueInput
  }

  /**
   * room_grades deleteMany
   */
  export type room_gradesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which room_grades to delete
     */
    where?: room_gradesWhereInput
  }

  /**
   * room_grades without action
   */
  export type room_gradesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the room_grades
     */
    select?: room_gradesSelect<ExtArgs> | null
  }


  /**
   * Model schema_version
   */

  export type AggregateSchema_version = {
    _count: Schema_versionCountAggregateOutputType | null
    _min: Schema_versionMinAggregateOutputType | null
    _max: Schema_versionMaxAggregateOutputType | null
  }

  export type Schema_versionMinAggregateOutputType = {
    version: string | null
    description: string | null
    rollback_sql: string | null
    applied_at: Date | null
    applied_by: string | null
  }

  export type Schema_versionMaxAggregateOutputType = {
    version: string | null
    description: string | null
    rollback_sql: string | null
    applied_at: Date | null
    applied_by: string | null
  }

  export type Schema_versionCountAggregateOutputType = {
    version: number
    description: number
    rollback_sql: number
    applied_at: number
    applied_by: number
    _all: number
  }


  export type Schema_versionMinAggregateInputType = {
    version?: true
    description?: true
    rollback_sql?: true
    applied_at?: true
    applied_by?: true
  }

  export type Schema_versionMaxAggregateInputType = {
    version?: true
    description?: true
    rollback_sql?: true
    applied_at?: true
    applied_by?: true
  }

  export type Schema_versionCountAggregateInputType = {
    version?: true
    description?: true
    rollback_sql?: true
    applied_at?: true
    applied_by?: true
    _all?: true
  }

  export type Schema_versionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_version to aggregate.
     */
    where?: schema_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_versions to fetch.
     */
    orderBy?: schema_versionOrderByWithRelationInput | schema_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: schema_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schema_versions
    **/
    _count?: true | Schema_versionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Schema_versionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Schema_versionMaxAggregateInputType
  }

  export type GetSchema_versionAggregateType<T extends Schema_versionAggregateArgs> = {
        [P in keyof T & keyof AggregateSchema_version]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchema_version[P]>
      : GetScalarType<T[P], AggregateSchema_version[P]>
  }




  export type schema_versionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: schema_versionWhereInput
    orderBy?: schema_versionOrderByWithAggregationInput | schema_versionOrderByWithAggregationInput[]
    by: Schema_versionScalarFieldEnum[] | Schema_versionScalarFieldEnum
    having?: schema_versionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Schema_versionCountAggregateInputType | true
    _min?: Schema_versionMinAggregateInputType
    _max?: Schema_versionMaxAggregateInputType
  }

  export type Schema_versionGroupByOutputType = {
    version: string
    description: string
    rollback_sql: string | null
    applied_at: Date
    applied_by: string | null
    _count: Schema_versionCountAggregateOutputType | null
    _min: Schema_versionMinAggregateOutputType | null
    _max: Schema_versionMaxAggregateOutputType | null
  }

  type GetSchema_versionGroupByPayload<T extends schema_versionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Schema_versionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Schema_versionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Schema_versionGroupByOutputType[P]>
            : GetScalarType<T[P], Schema_versionGroupByOutputType[P]>
        }
      >
    >


  export type schema_versionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
    description?: boolean
    rollback_sql?: boolean
    applied_at?: boolean
    applied_by?: boolean
  }, ExtArgs["result"]["schema_version"]>

  export type schema_versionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
    description?: boolean
    rollback_sql?: boolean
    applied_at?: boolean
    applied_by?: boolean
  }, ExtArgs["result"]["schema_version"]>

  export type schema_versionSelectScalar = {
    version?: boolean
    description?: boolean
    rollback_sql?: boolean
    applied_at?: boolean
    applied_by?: boolean
  }


  export type $schema_versionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "schema_version"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      version: string
      description: string
      rollback_sql: string | null
      applied_at: Date
      applied_by: string | null
    }, ExtArgs["result"]["schema_version"]>
    composites: {}
  }

  type schema_versionGetPayload<S extends boolean | null | undefined | schema_versionDefaultArgs> = $Result.GetResult<Prisma.$schema_versionPayload, S>

  type schema_versionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<schema_versionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Schema_versionCountAggregateInputType | true
    }

  export interface schema_versionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['schema_version'], meta: { name: 'schema_version' } }
    /**
     * Find zero or one Schema_version that matches the filter.
     * @param {schema_versionFindUniqueArgs} args - Arguments to find a Schema_version
     * @example
     * // Get one Schema_version
     * const schema_version = await prisma.schema_version.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends schema_versionFindUniqueArgs>(args: SelectSubset<T, schema_versionFindUniqueArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Schema_version that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {schema_versionFindUniqueOrThrowArgs} args - Arguments to find a Schema_version
     * @example
     * // Get one Schema_version
     * const schema_version = await prisma.schema_version.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends schema_versionFindUniqueOrThrowArgs>(args: SelectSubset<T, schema_versionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Schema_version that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionFindFirstArgs} args - Arguments to find a Schema_version
     * @example
     * // Get one Schema_version
     * const schema_version = await prisma.schema_version.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends schema_versionFindFirstArgs>(args?: SelectSubset<T, schema_versionFindFirstArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Schema_version that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionFindFirstOrThrowArgs} args - Arguments to find a Schema_version
     * @example
     * // Get one Schema_version
     * const schema_version = await prisma.schema_version.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends schema_versionFindFirstOrThrowArgs>(args?: SelectSubset<T, schema_versionFindFirstOrThrowArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schema_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schema_versions
     * const schema_versions = await prisma.schema_version.findMany()
     * 
     * // Get first 10 Schema_versions
     * const schema_versions = await prisma.schema_version.findMany({ take: 10 })
     * 
     * // Only select the `version`
     * const schema_versionWithVersionOnly = await prisma.schema_version.findMany({ select: { version: true } })
     * 
     */
    findMany<T extends schema_versionFindManyArgs>(args?: SelectSubset<T, schema_versionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Schema_version.
     * @param {schema_versionCreateArgs} args - Arguments to create a Schema_version.
     * @example
     * // Create one Schema_version
     * const Schema_version = await prisma.schema_version.create({
     *   data: {
     *     // ... data to create a Schema_version
     *   }
     * })
     * 
     */
    create<T extends schema_versionCreateArgs>(args: SelectSubset<T, schema_versionCreateArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schema_versions.
     * @param {schema_versionCreateManyArgs} args - Arguments to create many Schema_versions.
     * @example
     * // Create many Schema_versions
     * const schema_version = await prisma.schema_version.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends schema_versionCreateManyArgs>(args?: SelectSubset<T, schema_versionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schema_versions and returns the data saved in the database.
     * @param {schema_versionCreateManyAndReturnArgs} args - Arguments to create many Schema_versions.
     * @example
     * // Create many Schema_versions
     * const schema_version = await prisma.schema_version.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schema_versions and only return the `version`
     * const schema_versionWithVersionOnly = await prisma.schema_version.createManyAndReturn({ 
     *   select: { version: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends schema_versionCreateManyAndReturnArgs>(args?: SelectSubset<T, schema_versionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Schema_version.
     * @param {schema_versionDeleteArgs} args - Arguments to delete one Schema_version.
     * @example
     * // Delete one Schema_version
     * const Schema_version = await prisma.schema_version.delete({
     *   where: {
     *     // ... filter to delete one Schema_version
     *   }
     * })
     * 
     */
    delete<T extends schema_versionDeleteArgs>(args: SelectSubset<T, schema_versionDeleteArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Schema_version.
     * @param {schema_versionUpdateArgs} args - Arguments to update one Schema_version.
     * @example
     * // Update one Schema_version
     * const schema_version = await prisma.schema_version.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends schema_versionUpdateArgs>(args: SelectSubset<T, schema_versionUpdateArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schema_versions.
     * @param {schema_versionDeleteManyArgs} args - Arguments to filter Schema_versions to delete.
     * @example
     * // Delete a few Schema_versions
     * const { count } = await prisma.schema_version.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends schema_versionDeleteManyArgs>(args?: SelectSubset<T, schema_versionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schema_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schema_versions
     * const schema_version = await prisma.schema_version.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends schema_versionUpdateManyArgs>(args: SelectSubset<T, schema_versionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schema_version.
     * @param {schema_versionUpsertArgs} args - Arguments to update or create a Schema_version.
     * @example
     * // Update or create a Schema_version
     * const schema_version = await prisma.schema_version.upsert({
     *   create: {
     *     // ... data to create a Schema_version
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schema_version we want to update
     *   }
     * })
     */
    upsert<T extends schema_versionUpsertArgs>(args: SelectSubset<T, schema_versionUpsertArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schema_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionCountArgs} args - Arguments to filter Schema_versions to count.
     * @example
     * // Count the number of Schema_versions
     * const count = await prisma.schema_version.count({
     *   where: {
     *     // ... the filter for the Schema_versions we want to count
     *   }
     * })
    **/
    count<T extends schema_versionCountArgs>(
      args?: Subset<T, schema_versionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Schema_versionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schema_version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Schema_versionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Schema_versionAggregateArgs>(args: Subset<T, Schema_versionAggregateArgs>): Prisma.PrismaPromise<GetSchema_versionAggregateType<T>>

    /**
     * Group by Schema_version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends schema_versionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: schema_versionGroupByArgs['orderBy'] }
        : { orderBy?: schema_versionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, schema_versionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchema_versionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the schema_version model
   */
  readonly fields: schema_versionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for schema_version.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__schema_versionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the schema_version model
   */ 
  interface schema_versionFieldRefs {
    readonly version: FieldRef<"schema_version", 'String'>
    readonly description: FieldRef<"schema_version", 'String'>
    readonly rollback_sql: FieldRef<"schema_version", 'String'>
    readonly applied_at: FieldRef<"schema_version", 'DateTime'>
    readonly applied_by: FieldRef<"schema_version", 'String'>
  }
    

  // Custom InputTypes
  /**
   * schema_version findUnique
   */
  export type schema_versionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Filter, which schema_version to fetch.
     */
    where: schema_versionWhereUniqueInput
  }

  /**
   * schema_version findUniqueOrThrow
   */
  export type schema_versionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Filter, which schema_version to fetch.
     */
    where: schema_versionWhereUniqueInput
  }

  /**
   * schema_version findFirst
   */
  export type schema_versionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Filter, which schema_version to fetch.
     */
    where?: schema_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_versions to fetch.
     */
    orderBy?: schema_versionOrderByWithRelationInput | schema_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_versions.
     */
    cursor?: schema_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_versions.
     */
    distinct?: Schema_versionScalarFieldEnum | Schema_versionScalarFieldEnum[]
  }

  /**
   * schema_version findFirstOrThrow
   */
  export type schema_versionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Filter, which schema_version to fetch.
     */
    where?: schema_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_versions to fetch.
     */
    orderBy?: schema_versionOrderByWithRelationInput | schema_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_versions.
     */
    cursor?: schema_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_versions.
     */
    distinct?: Schema_versionScalarFieldEnum | Schema_versionScalarFieldEnum[]
  }

  /**
   * schema_version findMany
   */
  export type schema_versionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Filter, which schema_versions to fetch.
     */
    where?: schema_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_versions to fetch.
     */
    orderBy?: schema_versionOrderByWithRelationInput | schema_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schema_versions.
     */
    cursor?: schema_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_versions.
     */
    skip?: number
    distinct?: Schema_versionScalarFieldEnum | Schema_versionScalarFieldEnum[]
  }

  /**
   * schema_version create
   */
  export type schema_versionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * The data needed to create a schema_version.
     */
    data: XOR<schema_versionCreateInput, schema_versionUncheckedCreateInput>
  }

  /**
   * schema_version createMany
   */
  export type schema_versionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many schema_versions.
     */
    data: schema_versionCreateManyInput | schema_versionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_version createManyAndReturn
   */
  export type schema_versionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many schema_versions.
     */
    data: schema_versionCreateManyInput | schema_versionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_version update
   */
  export type schema_versionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * The data needed to update a schema_version.
     */
    data: XOR<schema_versionUpdateInput, schema_versionUncheckedUpdateInput>
    /**
     * Choose, which schema_version to update.
     */
    where: schema_versionWhereUniqueInput
  }

  /**
   * schema_version updateMany
   */
  export type schema_versionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update schema_versions.
     */
    data: XOR<schema_versionUpdateManyMutationInput, schema_versionUncheckedUpdateManyInput>
    /**
     * Filter which schema_versions to update
     */
    where?: schema_versionWhereInput
  }

  /**
   * schema_version upsert
   */
  export type schema_versionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * The filter to search for the schema_version to update in case it exists.
     */
    where: schema_versionWhereUniqueInput
    /**
     * In case the schema_version found by the `where` argument doesn't exist, create a new schema_version with this data.
     */
    create: XOR<schema_versionCreateInput, schema_versionUncheckedCreateInput>
    /**
     * In case the schema_version was found with the provided `where` argument, update it with this data.
     */
    update: XOR<schema_versionUpdateInput, schema_versionUncheckedUpdateInput>
  }

  /**
   * schema_version delete
   */
  export type schema_versionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Filter which schema_version to delete.
     */
    where: schema_versionWhereUniqueInput
  }

  /**
   * schema_version deleteMany
   */
  export type schema_versionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_versions to delete
     */
    where?: schema_versionWhereInput
  }

  /**
   * schema_version without action
   */
  export type schema_versionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
  }


  /**
   * Model service_plan_restrictions
   */

  export type AggregateService_plan_restrictions = {
    _count: Service_plan_restrictionsCountAggregateOutputType | null
    _avg: Service_plan_restrictionsAvgAggregateOutputType | null
    _sum: Service_plan_restrictionsSumAggregateOutputType | null
    _min: Service_plan_restrictionsMinAggregateOutputType | null
    _max: Service_plan_restrictionsMaxAggregateOutputType | null
  }

  export type Service_plan_restrictionsAvgAggregateOutputType = {
    max_users: number | null
    max_devices: number | null
    max_monthly_orders: number | null
    max_rooms: number | null
    max_monthly_ai_requests: number | null
    monthly_price: number | null
  }

  export type Service_plan_restrictionsSumAggregateOutputType = {
    max_users: number | null
    max_devices: number | null
    max_monthly_orders: number | null
    max_rooms: number | null
    max_monthly_ai_requests: number | null
    monthly_price: number | null
  }

  export type Service_plan_restrictionsMinAggregateOutputType = {
    id: string | null
    service_type: string | null
    plan_type: string | null
    plan_category: string | null
    max_users: number | null
    max_devices: number | null
    max_monthly_orders: number | null
    enable_ai_concierge: boolean | null
    enable_multilingual: boolean | null
    max_rooms: number | null
    enable_revenue_management: boolean | null
    max_monthly_ai_requests: number | null
    enable_ai_crm: boolean | null
    monthly_price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Service_plan_restrictionsMaxAggregateOutputType = {
    id: string | null
    service_type: string | null
    plan_type: string | null
    plan_category: string | null
    max_users: number | null
    max_devices: number | null
    max_monthly_orders: number | null
    enable_ai_concierge: boolean | null
    enable_multilingual: boolean | null
    max_rooms: number | null
    enable_revenue_management: boolean | null
    max_monthly_ai_requests: number | null
    enable_ai_crm: boolean | null
    monthly_price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Service_plan_restrictionsCountAggregateOutputType = {
    id: number
    service_type: number
    plan_type: number
    plan_category: number
    max_users: number
    max_devices: number
    max_monthly_orders: number
    enable_ai_concierge: number
    enable_multilingual: number
    max_rooms: number
    enable_revenue_management: number
    max_monthly_ai_requests: number
    enable_ai_crm: number
    monthly_price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Service_plan_restrictionsAvgAggregateInputType = {
    max_users?: true
    max_devices?: true
    max_monthly_orders?: true
    max_rooms?: true
    max_monthly_ai_requests?: true
    monthly_price?: true
  }

  export type Service_plan_restrictionsSumAggregateInputType = {
    max_users?: true
    max_devices?: true
    max_monthly_orders?: true
    max_rooms?: true
    max_monthly_ai_requests?: true
    monthly_price?: true
  }

  export type Service_plan_restrictionsMinAggregateInputType = {
    id?: true
    service_type?: true
    plan_type?: true
    plan_category?: true
    max_users?: true
    max_devices?: true
    max_monthly_orders?: true
    enable_ai_concierge?: true
    enable_multilingual?: true
    max_rooms?: true
    enable_revenue_management?: true
    max_monthly_ai_requests?: true
    enable_ai_crm?: true
    monthly_price?: true
    created_at?: true
    updated_at?: true
  }

  export type Service_plan_restrictionsMaxAggregateInputType = {
    id?: true
    service_type?: true
    plan_type?: true
    plan_category?: true
    max_users?: true
    max_devices?: true
    max_monthly_orders?: true
    enable_ai_concierge?: true
    enable_multilingual?: true
    max_rooms?: true
    enable_revenue_management?: true
    max_monthly_ai_requests?: true
    enable_ai_crm?: true
    monthly_price?: true
    created_at?: true
    updated_at?: true
  }

  export type Service_plan_restrictionsCountAggregateInputType = {
    id?: true
    service_type?: true
    plan_type?: true
    plan_category?: true
    max_users?: true
    max_devices?: true
    max_monthly_orders?: true
    enable_ai_concierge?: true
    enable_multilingual?: true
    max_rooms?: true
    enable_revenue_management?: true
    max_monthly_ai_requests?: true
    enable_ai_crm?: true
    monthly_price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Service_plan_restrictionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_plan_restrictions to aggregate.
     */
    where?: service_plan_restrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_plan_restrictions to fetch.
     */
    orderBy?: service_plan_restrictionsOrderByWithRelationInput | service_plan_restrictionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: service_plan_restrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_plan_restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_plan_restrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_plan_restrictions
    **/
    _count?: true | Service_plan_restrictionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Service_plan_restrictionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Service_plan_restrictionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Service_plan_restrictionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Service_plan_restrictionsMaxAggregateInputType
  }

  export type GetService_plan_restrictionsAggregateType<T extends Service_plan_restrictionsAggregateArgs> = {
        [P in keyof T & keyof AggregateService_plan_restrictions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_plan_restrictions[P]>
      : GetScalarType<T[P], AggregateService_plan_restrictions[P]>
  }




  export type service_plan_restrictionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_plan_restrictionsWhereInput
    orderBy?: service_plan_restrictionsOrderByWithAggregationInput | service_plan_restrictionsOrderByWithAggregationInput[]
    by: Service_plan_restrictionsScalarFieldEnum[] | Service_plan_restrictionsScalarFieldEnum
    having?: service_plan_restrictionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Service_plan_restrictionsCountAggregateInputType | true
    _avg?: Service_plan_restrictionsAvgAggregateInputType
    _sum?: Service_plan_restrictionsSumAggregateInputType
    _min?: Service_plan_restrictionsMinAggregateInputType
    _max?: Service_plan_restrictionsMaxAggregateInputType
  }

  export type Service_plan_restrictionsGroupByOutputType = {
    id: string
    service_type: string
    plan_type: string
    plan_category: string
    max_users: number
    max_devices: number
    max_monthly_orders: number | null
    enable_ai_concierge: boolean | null
    enable_multilingual: boolean | null
    max_rooms: number | null
    enable_revenue_management: boolean | null
    max_monthly_ai_requests: number | null
    enable_ai_crm: boolean | null
    monthly_price: number
    created_at: Date
    updated_at: Date
    _count: Service_plan_restrictionsCountAggregateOutputType | null
    _avg: Service_plan_restrictionsAvgAggregateOutputType | null
    _sum: Service_plan_restrictionsSumAggregateOutputType | null
    _min: Service_plan_restrictionsMinAggregateOutputType | null
    _max: Service_plan_restrictionsMaxAggregateOutputType | null
  }

  type GetService_plan_restrictionsGroupByPayload<T extends service_plan_restrictionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Service_plan_restrictionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Service_plan_restrictionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Service_plan_restrictionsGroupByOutputType[P]>
            : GetScalarType<T[P], Service_plan_restrictionsGroupByOutputType[P]>
        }
      >
    >


  export type service_plan_restrictionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_type?: boolean
    plan_type?: boolean
    plan_category?: boolean
    max_users?: boolean
    max_devices?: boolean
    max_monthly_orders?: boolean
    enable_ai_concierge?: boolean
    enable_multilingual?: boolean
    max_rooms?: boolean
    enable_revenue_management?: boolean
    max_monthly_ai_requests?: boolean
    enable_ai_crm?: boolean
    monthly_price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["service_plan_restrictions"]>

  export type service_plan_restrictionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service_type?: boolean
    plan_type?: boolean
    plan_category?: boolean
    max_users?: boolean
    max_devices?: boolean
    max_monthly_orders?: boolean
    enable_ai_concierge?: boolean
    enable_multilingual?: boolean
    max_rooms?: boolean
    enable_revenue_management?: boolean
    max_monthly_ai_requests?: boolean
    enable_ai_crm?: boolean
    monthly_price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["service_plan_restrictions"]>

  export type service_plan_restrictionsSelectScalar = {
    id?: boolean
    service_type?: boolean
    plan_type?: boolean
    plan_category?: boolean
    max_users?: boolean
    max_devices?: boolean
    max_monthly_orders?: boolean
    enable_ai_concierge?: boolean
    enable_multilingual?: boolean
    max_rooms?: boolean
    enable_revenue_management?: boolean
    max_monthly_ai_requests?: boolean
    enable_ai_crm?: boolean
    monthly_price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $service_plan_restrictionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service_plan_restrictions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      service_type: string
      plan_type: string
      plan_category: string
      max_users: number
      max_devices: number
      max_monthly_orders: number | null
      enable_ai_concierge: boolean | null
      enable_multilingual: boolean | null
      max_rooms: number | null
      enable_revenue_management: boolean | null
      max_monthly_ai_requests: number | null
      enable_ai_crm: boolean | null
      monthly_price: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["service_plan_restrictions"]>
    composites: {}
  }

  type service_plan_restrictionsGetPayload<S extends boolean | null | undefined | service_plan_restrictionsDefaultArgs> = $Result.GetResult<Prisma.$service_plan_restrictionsPayload, S>

  type service_plan_restrictionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<service_plan_restrictionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Service_plan_restrictionsCountAggregateInputType | true
    }

  export interface service_plan_restrictionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service_plan_restrictions'], meta: { name: 'service_plan_restrictions' } }
    /**
     * Find zero or one Service_plan_restrictions that matches the filter.
     * @param {service_plan_restrictionsFindUniqueArgs} args - Arguments to find a Service_plan_restrictions
     * @example
     * // Get one Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends service_plan_restrictionsFindUniqueArgs>(args: SelectSubset<T, service_plan_restrictionsFindUniqueArgs<ExtArgs>>): Prisma__service_plan_restrictionsClient<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service_plan_restrictions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {service_plan_restrictionsFindUniqueOrThrowArgs} args - Arguments to find a Service_plan_restrictions
     * @example
     * // Get one Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends service_plan_restrictionsFindUniqueOrThrowArgs>(args: SelectSubset<T, service_plan_restrictionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__service_plan_restrictionsClient<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service_plan_restrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_plan_restrictionsFindFirstArgs} args - Arguments to find a Service_plan_restrictions
     * @example
     * // Get one Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends service_plan_restrictionsFindFirstArgs>(args?: SelectSubset<T, service_plan_restrictionsFindFirstArgs<ExtArgs>>): Prisma__service_plan_restrictionsClient<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service_plan_restrictions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_plan_restrictionsFindFirstOrThrowArgs} args - Arguments to find a Service_plan_restrictions
     * @example
     * // Get one Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends service_plan_restrictionsFindFirstOrThrowArgs>(args?: SelectSubset<T, service_plan_restrictionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__service_plan_restrictionsClient<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Service_plan_restrictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_plan_restrictionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.findMany()
     * 
     * // Get first 10 Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_plan_restrictionsWithIdOnly = await prisma.service_plan_restrictions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends service_plan_restrictionsFindManyArgs>(args?: SelectSubset<T, service_plan_restrictionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service_plan_restrictions.
     * @param {service_plan_restrictionsCreateArgs} args - Arguments to create a Service_plan_restrictions.
     * @example
     * // Create one Service_plan_restrictions
     * const Service_plan_restrictions = await prisma.service_plan_restrictions.create({
     *   data: {
     *     // ... data to create a Service_plan_restrictions
     *   }
     * })
     * 
     */
    create<T extends service_plan_restrictionsCreateArgs>(args: SelectSubset<T, service_plan_restrictionsCreateArgs<ExtArgs>>): Prisma__service_plan_restrictionsClient<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Service_plan_restrictions.
     * @param {service_plan_restrictionsCreateManyArgs} args - Arguments to create many Service_plan_restrictions.
     * @example
     * // Create many Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends service_plan_restrictionsCreateManyArgs>(args?: SelectSubset<T, service_plan_restrictionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Service_plan_restrictions and returns the data saved in the database.
     * @param {service_plan_restrictionsCreateManyAndReturnArgs} args - Arguments to create many Service_plan_restrictions.
     * @example
     * // Create many Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Service_plan_restrictions and only return the `id`
     * const service_plan_restrictionsWithIdOnly = await prisma.service_plan_restrictions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends service_plan_restrictionsCreateManyAndReturnArgs>(args?: SelectSubset<T, service_plan_restrictionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service_plan_restrictions.
     * @param {service_plan_restrictionsDeleteArgs} args - Arguments to delete one Service_plan_restrictions.
     * @example
     * // Delete one Service_plan_restrictions
     * const Service_plan_restrictions = await prisma.service_plan_restrictions.delete({
     *   where: {
     *     // ... filter to delete one Service_plan_restrictions
     *   }
     * })
     * 
     */
    delete<T extends service_plan_restrictionsDeleteArgs>(args: SelectSubset<T, service_plan_restrictionsDeleteArgs<ExtArgs>>): Prisma__service_plan_restrictionsClient<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service_plan_restrictions.
     * @param {service_plan_restrictionsUpdateArgs} args - Arguments to update one Service_plan_restrictions.
     * @example
     * // Update one Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends service_plan_restrictionsUpdateArgs>(args: SelectSubset<T, service_plan_restrictionsUpdateArgs<ExtArgs>>): Prisma__service_plan_restrictionsClient<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Service_plan_restrictions.
     * @param {service_plan_restrictionsDeleteManyArgs} args - Arguments to filter Service_plan_restrictions to delete.
     * @example
     * // Delete a few Service_plan_restrictions
     * const { count } = await prisma.service_plan_restrictions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends service_plan_restrictionsDeleteManyArgs>(args?: SelectSubset<T, service_plan_restrictionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_plan_restrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_plan_restrictionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends service_plan_restrictionsUpdateManyArgs>(args: SelectSubset<T, service_plan_restrictionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service_plan_restrictions.
     * @param {service_plan_restrictionsUpsertArgs} args - Arguments to update or create a Service_plan_restrictions.
     * @example
     * // Update or create a Service_plan_restrictions
     * const service_plan_restrictions = await prisma.service_plan_restrictions.upsert({
     *   create: {
     *     // ... data to create a Service_plan_restrictions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_plan_restrictions we want to update
     *   }
     * })
     */
    upsert<T extends service_plan_restrictionsUpsertArgs>(args: SelectSubset<T, service_plan_restrictionsUpsertArgs<ExtArgs>>): Prisma__service_plan_restrictionsClient<$Result.GetResult<Prisma.$service_plan_restrictionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Service_plan_restrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_plan_restrictionsCountArgs} args - Arguments to filter Service_plan_restrictions to count.
     * @example
     * // Count the number of Service_plan_restrictions
     * const count = await prisma.service_plan_restrictions.count({
     *   where: {
     *     // ... the filter for the Service_plan_restrictions we want to count
     *   }
     * })
    **/
    count<T extends service_plan_restrictionsCountArgs>(
      args?: Subset<T, service_plan_restrictionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_plan_restrictionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_plan_restrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_plan_restrictionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_plan_restrictionsAggregateArgs>(args: Subset<T, Service_plan_restrictionsAggregateArgs>): Prisma.PrismaPromise<GetService_plan_restrictionsAggregateType<T>>

    /**
     * Group by Service_plan_restrictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_plan_restrictionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends service_plan_restrictionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: service_plan_restrictionsGroupByArgs['orderBy'] }
        : { orderBy?: service_plan_restrictionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, service_plan_restrictionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetService_plan_restrictionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service_plan_restrictions model
   */
  readonly fields: service_plan_restrictionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service_plan_restrictions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__service_plan_restrictionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service_plan_restrictions model
   */ 
  interface service_plan_restrictionsFieldRefs {
    readonly id: FieldRef<"service_plan_restrictions", 'String'>
    readonly service_type: FieldRef<"service_plan_restrictions", 'String'>
    readonly plan_type: FieldRef<"service_plan_restrictions", 'String'>
    readonly plan_category: FieldRef<"service_plan_restrictions", 'String'>
    readonly max_users: FieldRef<"service_plan_restrictions", 'Int'>
    readonly max_devices: FieldRef<"service_plan_restrictions", 'Int'>
    readonly max_monthly_orders: FieldRef<"service_plan_restrictions", 'Int'>
    readonly enable_ai_concierge: FieldRef<"service_plan_restrictions", 'Boolean'>
    readonly enable_multilingual: FieldRef<"service_plan_restrictions", 'Boolean'>
    readonly max_rooms: FieldRef<"service_plan_restrictions", 'Int'>
    readonly enable_revenue_management: FieldRef<"service_plan_restrictions", 'Boolean'>
    readonly max_monthly_ai_requests: FieldRef<"service_plan_restrictions", 'Int'>
    readonly enable_ai_crm: FieldRef<"service_plan_restrictions", 'Boolean'>
    readonly monthly_price: FieldRef<"service_plan_restrictions", 'Int'>
    readonly created_at: FieldRef<"service_plan_restrictions", 'DateTime'>
    readonly updated_at: FieldRef<"service_plan_restrictions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * service_plan_restrictions findUnique
   */
  export type service_plan_restrictionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
    /**
     * Filter, which service_plan_restrictions to fetch.
     */
    where: service_plan_restrictionsWhereUniqueInput
  }

  /**
   * service_plan_restrictions findUniqueOrThrow
   */
  export type service_plan_restrictionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
    /**
     * Filter, which service_plan_restrictions to fetch.
     */
    where: service_plan_restrictionsWhereUniqueInput
  }

  /**
   * service_plan_restrictions findFirst
   */
  export type service_plan_restrictionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
    /**
     * Filter, which service_plan_restrictions to fetch.
     */
    where?: service_plan_restrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_plan_restrictions to fetch.
     */
    orderBy?: service_plan_restrictionsOrderByWithRelationInput | service_plan_restrictionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_plan_restrictions.
     */
    cursor?: service_plan_restrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_plan_restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_plan_restrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_plan_restrictions.
     */
    distinct?: Service_plan_restrictionsScalarFieldEnum | Service_plan_restrictionsScalarFieldEnum[]
  }

  /**
   * service_plan_restrictions findFirstOrThrow
   */
  export type service_plan_restrictionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
    /**
     * Filter, which service_plan_restrictions to fetch.
     */
    where?: service_plan_restrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_plan_restrictions to fetch.
     */
    orderBy?: service_plan_restrictionsOrderByWithRelationInput | service_plan_restrictionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_plan_restrictions.
     */
    cursor?: service_plan_restrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_plan_restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_plan_restrictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_plan_restrictions.
     */
    distinct?: Service_plan_restrictionsScalarFieldEnum | Service_plan_restrictionsScalarFieldEnum[]
  }

  /**
   * service_plan_restrictions findMany
   */
  export type service_plan_restrictionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
    /**
     * Filter, which service_plan_restrictions to fetch.
     */
    where?: service_plan_restrictionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_plan_restrictions to fetch.
     */
    orderBy?: service_plan_restrictionsOrderByWithRelationInput | service_plan_restrictionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_plan_restrictions.
     */
    cursor?: service_plan_restrictionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_plan_restrictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_plan_restrictions.
     */
    skip?: number
    distinct?: Service_plan_restrictionsScalarFieldEnum | Service_plan_restrictionsScalarFieldEnum[]
  }

  /**
   * service_plan_restrictions create
   */
  export type service_plan_restrictionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
    /**
     * The data needed to create a service_plan_restrictions.
     */
    data: XOR<service_plan_restrictionsCreateInput, service_plan_restrictionsUncheckedCreateInput>
  }

  /**
   * service_plan_restrictions createMany
   */
  export type service_plan_restrictionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many service_plan_restrictions.
     */
    data: service_plan_restrictionsCreateManyInput | service_plan_restrictionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_plan_restrictions createManyAndReturn
   */
  export type service_plan_restrictionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many service_plan_restrictions.
     */
    data: service_plan_restrictionsCreateManyInput | service_plan_restrictionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_plan_restrictions update
   */
  export type service_plan_restrictionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
    /**
     * The data needed to update a service_plan_restrictions.
     */
    data: XOR<service_plan_restrictionsUpdateInput, service_plan_restrictionsUncheckedUpdateInput>
    /**
     * Choose, which service_plan_restrictions to update.
     */
    where: service_plan_restrictionsWhereUniqueInput
  }

  /**
   * service_plan_restrictions updateMany
   */
  export type service_plan_restrictionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update service_plan_restrictions.
     */
    data: XOR<service_plan_restrictionsUpdateManyMutationInput, service_plan_restrictionsUncheckedUpdateManyInput>
    /**
     * Filter which service_plan_restrictions to update
     */
    where?: service_plan_restrictionsWhereInput
  }

  /**
   * service_plan_restrictions upsert
   */
  export type service_plan_restrictionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
    /**
     * The filter to search for the service_plan_restrictions to update in case it exists.
     */
    where: service_plan_restrictionsWhereUniqueInput
    /**
     * In case the service_plan_restrictions found by the `where` argument doesn't exist, create a new service_plan_restrictions with this data.
     */
    create: XOR<service_plan_restrictionsCreateInput, service_plan_restrictionsUncheckedCreateInput>
    /**
     * In case the service_plan_restrictions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<service_plan_restrictionsUpdateInput, service_plan_restrictionsUncheckedUpdateInput>
  }

  /**
   * service_plan_restrictions delete
   */
  export type service_plan_restrictionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
    /**
     * Filter which service_plan_restrictions to delete.
     */
    where: service_plan_restrictionsWhereUniqueInput
  }

  /**
   * service_plan_restrictions deleteMany
   */
  export type service_plan_restrictionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_plan_restrictions to delete
     */
    where?: service_plan_restrictionsWhereInput
  }

  /**
   * service_plan_restrictions without action
   */
  export type service_plan_restrictionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_plan_restrictions
     */
    select?: service_plan_restrictionsSelect<ExtArgs> | null
  }


  /**
   * Model service_usage_statistics
   */

  export type AggregateService_usage_statistics = {
    _count: Service_usage_statisticsCountAggregateOutputType | null
    _avg: Service_usage_statisticsAvgAggregateOutputType | null
    _sum: Service_usage_statisticsSumAggregateOutputType | null
    _min: Service_usage_statisticsMinAggregateOutputType | null
    _max: Service_usage_statisticsMaxAggregateOutputType | null
  }

  export type Service_usage_statisticsAvgAggregateOutputType = {
    active_users_count: number | null
    active_devices_count: number | null
  }

  export type Service_usage_statisticsSumAggregateOutputType = {
    active_users_count: number | null
    active_devices_count: number | null
  }

  export type Service_usage_statisticsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    service_type: string | null
    month: string | null
    active_users_count: number | null
    active_devices_count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Service_usage_statisticsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    service_type: string | null
    month: string | null
    active_users_count: number | null
    active_devices_count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Service_usage_statisticsCountAggregateOutputType = {
    id: number
    tenant_id: number
    service_type: number
    month: number
    active_users_count: number
    active_devices_count: number
    usage_data: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Service_usage_statisticsAvgAggregateInputType = {
    active_users_count?: true
    active_devices_count?: true
  }

  export type Service_usage_statisticsSumAggregateInputType = {
    active_users_count?: true
    active_devices_count?: true
  }

  export type Service_usage_statisticsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    service_type?: true
    month?: true
    active_users_count?: true
    active_devices_count?: true
    created_at?: true
    updated_at?: true
  }

  export type Service_usage_statisticsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    service_type?: true
    month?: true
    active_users_count?: true
    active_devices_count?: true
    created_at?: true
    updated_at?: true
  }

  export type Service_usage_statisticsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    service_type?: true
    month?: true
    active_users_count?: true
    active_devices_count?: true
    usage_data?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Service_usage_statisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_usage_statistics to aggregate.
     */
    where?: service_usage_statisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_usage_statistics to fetch.
     */
    orderBy?: service_usage_statisticsOrderByWithRelationInput | service_usage_statisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: service_usage_statisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_usage_statistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_usage_statistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_usage_statistics
    **/
    _count?: true | Service_usage_statisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Service_usage_statisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Service_usage_statisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Service_usage_statisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Service_usage_statisticsMaxAggregateInputType
  }

  export type GetService_usage_statisticsAggregateType<T extends Service_usage_statisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateService_usage_statistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_usage_statistics[P]>
      : GetScalarType<T[P], AggregateService_usage_statistics[P]>
  }




  export type service_usage_statisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_usage_statisticsWhereInput
    orderBy?: service_usage_statisticsOrderByWithAggregationInput | service_usage_statisticsOrderByWithAggregationInput[]
    by: Service_usage_statisticsScalarFieldEnum[] | Service_usage_statisticsScalarFieldEnum
    having?: service_usage_statisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Service_usage_statisticsCountAggregateInputType | true
    _avg?: Service_usage_statisticsAvgAggregateInputType
    _sum?: Service_usage_statisticsSumAggregateInputType
    _min?: Service_usage_statisticsMinAggregateInputType
    _max?: Service_usage_statisticsMaxAggregateInputType
  }

  export type Service_usage_statisticsGroupByOutputType = {
    id: string
    tenant_id: string
    service_type: string
    month: string
    active_users_count: number
    active_devices_count: number
    usage_data: JsonValue
    created_at: Date
    updated_at: Date
    _count: Service_usage_statisticsCountAggregateOutputType | null
    _avg: Service_usage_statisticsAvgAggregateOutputType | null
    _sum: Service_usage_statisticsSumAggregateOutputType | null
    _min: Service_usage_statisticsMinAggregateOutputType | null
    _max: Service_usage_statisticsMaxAggregateOutputType | null
  }

  type GetService_usage_statisticsGroupByPayload<T extends service_usage_statisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Service_usage_statisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Service_usage_statisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Service_usage_statisticsGroupByOutputType[P]>
            : GetScalarType<T[P], Service_usage_statisticsGroupByOutputType[P]>
        }
      >
    >


  export type service_usage_statisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    service_type?: boolean
    month?: boolean
    active_users_count?: boolean
    active_devices_count?: boolean
    usage_data?: boolean
    created_at?: boolean
    updated_at?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service_usage_statistics"]>

  export type service_usage_statisticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    service_type?: boolean
    month?: boolean
    active_users_count?: boolean
    active_devices_count?: boolean
    usage_data?: boolean
    created_at?: boolean
    updated_at?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service_usage_statistics"]>

  export type service_usage_statisticsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    service_type?: boolean
    month?: boolean
    active_users_count?: boolean
    active_devices_count?: boolean
    usage_data?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type service_usage_statisticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type service_usage_statisticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $service_usage_statisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service_usage_statistics"
    objects: {
      Tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      service_type: string
      month: string
      active_users_count: number
      active_devices_count: number
      usage_data: Prisma.JsonValue
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["service_usage_statistics"]>
    composites: {}
  }

  type service_usage_statisticsGetPayload<S extends boolean | null | undefined | service_usage_statisticsDefaultArgs> = $Result.GetResult<Prisma.$service_usage_statisticsPayload, S>

  type service_usage_statisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<service_usage_statisticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Service_usage_statisticsCountAggregateInputType | true
    }

  export interface service_usage_statisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service_usage_statistics'], meta: { name: 'service_usage_statistics' } }
    /**
     * Find zero or one Service_usage_statistics that matches the filter.
     * @param {service_usage_statisticsFindUniqueArgs} args - Arguments to find a Service_usage_statistics
     * @example
     * // Get one Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends service_usage_statisticsFindUniqueArgs>(args: SelectSubset<T, service_usage_statisticsFindUniqueArgs<ExtArgs>>): Prisma__service_usage_statisticsClient<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service_usage_statistics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {service_usage_statisticsFindUniqueOrThrowArgs} args - Arguments to find a Service_usage_statistics
     * @example
     * // Get one Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends service_usage_statisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, service_usage_statisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__service_usage_statisticsClient<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service_usage_statistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usage_statisticsFindFirstArgs} args - Arguments to find a Service_usage_statistics
     * @example
     * // Get one Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends service_usage_statisticsFindFirstArgs>(args?: SelectSubset<T, service_usage_statisticsFindFirstArgs<ExtArgs>>): Prisma__service_usage_statisticsClient<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service_usage_statistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usage_statisticsFindFirstOrThrowArgs} args - Arguments to find a Service_usage_statistics
     * @example
     * // Get one Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends service_usage_statisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, service_usage_statisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__service_usage_statisticsClient<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Service_usage_statistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usage_statisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.findMany()
     * 
     * // Get first 10 Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_usage_statisticsWithIdOnly = await prisma.service_usage_statistics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends service_usage_statisticsFindManyArgs>(args?: SelectSubset<T, service_usage_statisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service_usage_statistics.
     * @param {service_usage_statisticsCreateArgs} args - Arguments to create a Service_usage_statistics.
     * @example
     * // Create one Service_usage_statistics
     * const Service_usage_statistics = await prisma.service_usage_statistics.create({
     *   data: {
     *     // ... data to create a Service_usage_statistics
     *   }
     * })
     * 
     */
    create<T extends service_usage_statisticsCreateArgs>(args: SelectSubset<T, service_usage_statisticsCreateArgs<ExtArgs>>): Prisma__service_usage_statisticsClient<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Service_usage_statistics.
     * @param {service_usage_statisticsCreateManyArgs} args - Arguments to create many Service_usage_statistics.
     * @example
     * // Create many Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends service_usage_statisticsCreateManyArgs>(args?: SelectSubset<T, service_usage_statisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Service_usage_statistics and returns the data saved in the database.
     * @param {service_usage_statisticsCreateManyAndReturnArgs} args - Arguments to create many Service_usage_statistics.
     * @example
     * // Create many Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Service_usage_statistics and only return the `id`
     * const service_usage_statisticsWithIdOnly = await prisma.service_usage_statistics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends service_usage_statisticsCreateManyAndReturnArgs>(args?: SelectSubset<T, service_usage_statisticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service_usage_statistics.
     * @param {service_usage_statisticsDeleteArgs} args - Arguments to delete one Service_usage_statistics.
     * @example
     * // Delete one Service_usage_statistics
     * const Service_usage_statistics = await prisma.service_usage_statistics.delete({
     *   where: {
     *     // ... filter to delete one Service_usage_statistics
     *   }
     * })
     * 
     */
    delete<T extends service_usage_statisticsDeleteArgs>(args: SelectSubset<T, service_usage_statisticsDeleteArgs<ExtArgs>>): Prisma__service_usage_statisticsClient<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service_usage_statistics.
     * @param {service_usage_statisticsUpdateArgs} args - Arguments to update one Service_usage_statistics.
     * @example
     * // Update one Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends service_usage_statisticsUpdateArgs>(args: SelectSubset<T, service_usage_statisticsUpdateArgs<ExtArgs>>): Prisma__service_usage_statisticsClient<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Service_usage_statistics.
     * @param {service_usage_statisticsDeleteManyArgs} args - Arguments to filter Service_usage_statistics to delete.
     * @example
     * // Delete a few Service_usage_statistics
     * const { count } = await prisma.service_usage_statistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends service_usage_statisticsDeleteManyArgs>(args?: SelectSubset<T, service_usage_statisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_usage_statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usage_statisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends service_usage_statisticsUpdateManyArgs>(args: SelectSubset<T, service_usage_statisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service_usage_statistics.
     * @param {service_usage_statisticsUpsertArgs} args - Arguments to update or create a Service_usage_statistics.
     * @example
     * // Update or create a Service_usage_statistics
     * const service_usage_statistics = await prisma.service_usage_statistics.upsert({
     *   create: {
     *     // ... data to create a Service_usage_statistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_usage_statistics we want to update
     *   }
     * })
     */
    upsert<T extends service_usage_statisticsUpsertArgs>(args: SelectSubset<T, service_usage_statisticsUpsertArgs<ExtArgs>>): Prisma__service_usage_statisticsClient<$Result.GetResult<Prisma.$service_usage_statisticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Service_usage_statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usage_statisticsCountArgs} args - Arguments to filter Service_usage_statistics to count.
     * @example
     * // Count the number of Service_usage_statistics
     * const count = await prisma.service_usage_statistics.count({
     *   where: {
     *     // ... the filter for the Service_usage_statistics we want to count
     *   }
     * })
    **/
    count<T extends service_usage_statisticsCountArgs>(
      args?: Subset<T, service_usage_statisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_usage_statisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_usage_statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_usage_statisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_usage_statisticsAggregateArgs>(args: Subset<T, Service_usage_statisticsAggregateArgs>): Prisma.PrismaPromise<GetService_usage_statisticsAggregateType<T>>

    /**
     * Group by Service_usage_statistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_usage_statisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends service_usage_statisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: service_usage_statisticsGroupByArgs['orderBy'] }
        : { orderBy?: service_usage_statisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, service_usage_statisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetService_usage_statisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service_usage_statistics model
   */
  readonly fields: service_usage_statisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service_usage_statistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__service_usage_statisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service_usage_statistics model
   */ 
  interface service_usage_statisticsFieldRefs {
    readonly id: FieldRef<"service_usage_statistics", 'String'>
    readonly tenant_id: FieldRef<"service_usage_statistics", 'String'>
    readonly service_type: FieldRef<"service_usage_statistics", 'String'>
    readonly month: FieldRef<"service_usage_statistics", 'String'>
    readonly active_users_count: FieldRef<"service_usage_statistics", 'Int'>
    readonly active_devices_count: FieldRef<"service_usage_statistics", 'Int'>
    readonly usage_data: FieldRef<"service_usage_statistics", 'Json'>
    readonly created_at: FieldRef<"service_usage_statistics", 'DateTime'>
    readonly updated_at: FieldRef<"service_usage_statistics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * service_usage_statistics findUnique
   */
  export type service_usage_statisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    /**
     * Filter, which service_usage_statistics to fetch.
     */
    where: service_usage_statisticsWhereUniqueInput
  }

  /**
   * service_usage_statistics findUniqueOrThrow
   */
  export type service_usage_statisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    /**
     * Filter, which service_usage_statistics to fetch.
     */
    where: service_usage_statisticsWhereUniqueInput
  }

  /**
   * service_usage_statistics findFirst
   */
  export type service_usage_statisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    /**
     * Filter, which service_usage_statistics to fetch.
     */
    where?: service_usage_statisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_usage_statistics to fetch.
     */
    orderBy?: service_usage_statisticsOrderByWithRelationInput | service_usage_statisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_usage_statistics.
     */
    cursor?: service_usage_statisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_usage_statistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_usage_statistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_usage_statistics.
     */
    distinct?: Service_usage_statisticsScalarFieldEnum | Service_usage_statisticsScalarFieldEnum[]
  }

  /**
   * service_usage_statistics findFirstOrThrow
   */
  export type service_usage_statisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    /**
     * Filter, which service_usage_statistics to fetch.
     */
    where?: service_usage_statisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_usage_statistics to fetch.
     */
    orderBy?: service_usage_statisticsOrderByWithRelationInput | service_usage_statisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_usage_statistics.
     */
    cursor?: service_usage_statisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_usage_statistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_usage_statistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_usage_statistics.
     */
    distinct?: Service_usage_statisticsScalarFieldEnum | Service_usage_statisticsScalarFieldEnum[]
  }

  /**
   * service_usage_statistics findMany
   */
  export type service_usage_statisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    /**
     * Filter, which service_usage_statistics to fetch.
     */
    where?: service_usage_statisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_usage_statistics to fetch.
     */
    orderBy?: service_usage_statisticsOrderByWithRelationInput | service_usage_statisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_usage_statistics.
     */
    cursor?: service_usage_statisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_usage_statistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_usage_statistics.
     */
    skip?: number
    distinct?: Service_usage_statisticsScalarFieldEnum | Service_usage_statisticsScalarFieldEnum[]
  }

  /**
   * service_usage_statistics create
   */
  export type service_usage_statisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    /**
     * The data needed to create a service_usage_statistics.
     */
    data: XOR<service_usage_statisticsCreateInput, service_usage_statisticsUncheckedCreateInput>
  }

  /**
   * service_usage_statistics createMany
   */
  export type service_usage_statisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many service_usage_statistics.
     */
    data: service_usage_statisticsCreateManyInput | service_usage_statisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_usage_statistics createManyAndReturn
   */
  export type service_usage_statisticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many service_usage_statistics.
     */
    data: service_usage_statisticsCreateManyInput | service_usage_statisticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * service_usage_statistics update
   */
  export type service_usage_statisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    /**
     * The data needed to update a service_usage_statistics.
     */
    data: XOR<service_usage_statisticsUpdateInput, service_usage_statisticsUncheckedUpdateInput>
    /**
     * Choose, which service_usage_statistics to update.
     */
    where: service_usage_statisticsWhereUniqueInput
  }

  /**
   * service_usage_statistics updateMany
   */
  export type service_usage_statisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update service_usage_statistics.
     */
    data: XOR<service_usage_statisticsUpdateManyMutationInput, service_usage_statisticsUncheckedUpdateManyInput>
    /**
     * Filter which service_usage_statistics to update
     */
    where?: service_usage_statisticsWhereInput
  }

  /**
   * service_usage_statistics upsert
   */
  export type service_usage_statisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    /**
     * The filter to search for the service_usage_statistics to update in case it exists.
     */
    where: service_usage_statisticsWhereUniqueInput
    /**
     * In case the service_usage_statistics found by the `where` argument doesn't exist, create a new service_usage_statistics with this data.
     */
    create: XOR<service_usage_statisticsCreateInput, service_usage_statisticsUncheckedCreateInput>
    /**
     * In case the service_usage_statistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<service_usage_statisticsUpdateInput, service_usage_statisticsUncheckedUpdateInput>
  }

  /**
   * service_usage_statistics delete
   */
  export type service_usage_statisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
    /**
     * Filter which service_usage_statistics to delete.
     */
    where: service_usage_statisticsWhereUniqueInput
  }

  /**
   * service_usage_statistics deleteMany
   */
  export type service_usage_statisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_usage_statistics to delete
     */
    where?: service_usage_statisticsWhereInput
  }

  /**
   * service_usage_statistics without action
   */
  export type service_usage_statisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_usage_statistics
     */
    select?: service_usage_statisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_usage_statisticsInclude<ExtArgs> | null
  }


  /**
   * Model staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffAvgAggregateOutputType = {
    failed_login_count: number | null
  }

  export type StaffSumAggregateOutputType = {
    failed_login_count: number | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    email: string | null
    name: string | null
    role: string | null
    department: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    failed_login_count: number | null
    last_login_at: Date | null
    locked_until: Date | null
    password_hash: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    email: string | null
    name: string | null
    role: string | null
    department: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    failed_login_count: number | null
    last_login_at: Date | null
    locked_until: Date | null
    password_hash: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    tenant_id: number
    email: number
    name: number
    role: number
    department: number
    is_active: number
    created_at: number
    updated_at: number
    failed_login_count: number
    last_login_at: number
    locked_until: number
    password_hash: number
    deleted_at: number
    deleted_by: number
    is_deleted: number
    _all: number
  }


  export type StaffAvgAggregateInputType = {
    failed_login_count?: true
  }

  export type StaffSumAggregateInputType = {
    failed_login_count?: true
  }

  export type StaffMinAggregateInputType = {
    id?: true
    tenant_id?: true
    email?: true
    name?: true
    role?: true
    department?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    failed_login_count?: true
    last_login_at?: true
    locked_until?: true
    password_hash?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    email?: true
    name?: true
    role?: true
    department?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    failed_login_count?: true
    last_login_at?: true
    locked_until?: true
    password_hash?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    tenant_id?: true
    email?: true
    name?: true
    role?: true
    department?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    failed_login_count?: true
    last_login_at?: true
    locked_until?: true
    password_hash?: true
    deleted_at?: true
    deleted_by?: true
    is_deleted?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which staff to aggregate.
     */
    where?: staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff to fetch.
     */
    orderBy?: staffOrderByWithRelationInput | staffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type staffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: staffWhereInput
    orderBy?: staffOrderByWithAggregationInput | staffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: staffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _avg?: StaffAvgAggregateInputType
    _sum?: StaffSumAggregateInputType
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: string
    tenant_id: string
    email: string
    name: string
    role: string
    department: string | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    failed_login_count: number
    last_login_at: Date | null
    locked_until: Date | null
    password_hash: string | null
    deleted_at: Date | null
    deleted_by: string | null
    is_deleted: boolean
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends staffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type staffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    failed_login_count?: boolean
    last_login_at?: boolean
    locked_until?: boolean
    password_hash?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["staff"]>

  export type staffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    failed_login_count?: boolean
    last_login_at?: boolean
    locked_until?: boolean
    password_hash?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }, ExtArgs["result"]["staff"]>

  export type staffSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    department?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    failed_login_count?: boolean
    last_login_at?: boolean
    locked_until?: boolean
    password_hash?: boolean
    deleted_at?: boolean
    deleted_by?: boolean
    is_deleted?: boolean
  }


  export type $staffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "staff"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      email: string
      name: string
      role: string
      department: string | null
      is_active: boolean
      created_at: Date
      updated_at: Date
      failed_login_count: number
      last_login_at: Date | null
      locked_until: Date | null
      password_hash: string | null
      deleted_at: Date | null
      deleted_by: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type staffGetPayload<S extends boolean | null | undefined | staffDefaultArgs> = $Result.GetResult<Prisma.$staffPayload, S>

  type staffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<staffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface staffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['staff'], meta: { name: 'staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {staffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends staffFindUniqueArgs>(args: SelectSubset<T, staffFindUniqueArgs<ExtArgs>>): Prisma__staffClient<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {staffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends staffFindUniqueOrThrowArgs>(args: SelectSubset<T, staffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__staffClient<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends staffFindFirstArgs>(args?: SelectSubset<T, staffFindFirstArgs<ExtArgs>>): Prisma__staffClient<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends staffFindFirstOrThrowArgs>(args?: SelectSubset<T, staffFindFirstOrThrowArgs<ExtArgs>>): Prisma__staffClient<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends staffFindManyArgs>(args?: SelectSubset<T, staffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Staff.
     * @param {staffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends staffCreateArgs>(args: SelectSubset<T, staffCreateArgs<ExtArgs>>): Prisma__staffClient<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Staff.
     * @param {staffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends staffCreateManyArgs>(args?: SelectSubset<T, staffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {staffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends staffCreateManyAndReturnArgs>(args?: SelectSubset<T, staffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Staff.
     * @param {staffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends staffDeleteArgs>(args: SelectSubset<T, staffDeleteArgs<ExtArgs>>): Prisma__staffClient<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Staff.
     * @param {staffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends staffUpdateArgs>(args: SelectSubset<T, staffUpdateArgs<ExtArgs>>): Prisma__staffClient<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Staff.
     * @param {staffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends staffDeleteManyArgs>(args?: SelectSubset<T, staffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends staffUpdateManyArgs>(args: SelectSubset<T, staffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff.
     * @param {staffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends staffUpsertArgs>(args: SelectSubset<T, staffUpsertArgs<ExtArgs>>): Prisma__staffClient<$Result.GetResult<Prisma.$staffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends staffCountArgs>(
      args?: Subset<T, staffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends staffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: staffGroupByArgs['orderBy'] }
        : { orderBy?: staffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, staffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the staff model
   */
  readonly fields: staffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__staffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the staff model
   */ 
  interface staffFieldRefs {
    readonly id: FieldRef<"staff", 'String'>
    readonly tenant_id: FieldRef<"staff", 'String'>
    readonly email: FieldRef<"staff", 'String'>
    readonly name: FieldRef<"staff", 'String'>
    readonly role: FieldRef<"staff", 'String'>
    readonly department: FieldRef<"staff", 'String'>
    readonly is_active: FieldRef<"staff", 'Boolean'>
    readonly created_at: FieldRef<"staff", 'DateTime'>
    readonly updated_at: FieldRef<"staff", 'DateTime'>
    readonly failed_login_count: FieldRef<"staff", 'Int'>
    readonly last_login_at: FieldRef<"staff", 'DateTime'>
    readonly locked_until: FieldRef<"staff", 'DateTime'>
    readonly password_hash: FieldRef<"staff", 'String'>
    readonly deleted_at: FieldRef<"staff", 'DateTime'>
    readonly deleted_by: FieldRef<"staff", 'String'>
    readonly is_deleted: FieldRef<"staff", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * staff findUnique
   */
  export type staffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
    /**
     * Filter, which staff to fetch.
     */
    where: staffWhereUniqueInput
  }

  /**
   * staff findUniqueOrThrow
   */
  export type staffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
    /**
     * Filter, which staff to fetch.
     */
    where: staffWhereUniqueInput
  }

  /**
   * staff findFirst
   */
  export type staffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
    /**
     * Filter, which staff to fetch.
     */
    where?: staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff to fetch.
     */
    orderBy?: staffOrderByWithRelationInput | staffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staff.
     */
    cursor?: staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * staff findFirstOrThrow
   */
  export type staffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
    /**
     * Filter, which staff to fetch.
     */
    where?: staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff to fetch.
     */
    orderBy?: staffOrderByWithRelationInput | staffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staff.
     */
    cursor?: staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * staff findMany
   */
  export type staffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
    /**
     * Filter, which staff to fetch.
     */
    where?: staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff to fetch.
     */
    orderBy?: staffOrderByWithRelationInput | staffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staff.
     */
    cursor?: staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * staff create
   */
  export type staffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
    /**
     * The data needed to create a staff.
     */
    data: XOR<staffCreateInput, staffUncheckedCreateInput>
  }

  /**
   * staff createMany
   */
  export type staffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many staff.
     */
    data: staffCreateManyInput | staffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * staff createManyAndReturn
   */
  export type staffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many staff.
     */
    data: staffCreateManyInput | staffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * staff update
   */
  export type staffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
    /**
     * The data needed to update a staff.
     */
    data: XOR<staffUpdateInput, staffUncheckedUpdateInput>
    /**
     * Choose, which staff to update.
     */
    where: staffWhereUniqueInput
  }

  /**
   * staff updateMany
   */
  export type staffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update staff.
     */
    data: XOR<staffUpdateManyMutationInput, staffUncheckedUpdateManyInput>
    /**
     * Filter which staff to update
     */
    where?: staffWhereInput
  }

  /**
   * staff upsert
   */
  export type staffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
    /**
     * The filter to search for the staff to update in case it exists.
     */
    where: staffWhereUniqueInput
    /**
     * In case the staff found by the `where` argument doesn't exist, create a new staff with this data.
     */
    create: XOR<staffCreateInput, staffUncheckedCreateInput>
    /**
     * In case the staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<staffUpdateInput, staffUncheckedUpdateInput>
  }

  /**
   * staff delete
   */
  export type staffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
    /**
     * Filter which staff to delete.
     */
    where: staffWhereUniqueInput
  }

  /**
   * staff deleteMany
   */
  export type staffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which staff to delete
     */
    where?: staffWhereInput
  }

  /**
   * staff without action
   */
  export type staffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff
     */
    select?: staffSelect<ExtArgs> | null
  }


  /**
   * Model system_event
   */

  export type AggregateSystem_event = {
    _count: System_eventCountAggregateOutputType | null
    _min: System_eventMinAggregateOutputType | null
    _max: System_eventMaxAggregateOutputType | null
  }

  export type System_eventMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    event_type: string | null
    source_system: string | null
    target_system: string | null
    entity_type: string | null
    entity_id: string | null
    action: string | null
    created_at: Date | null
    processed_at: Date | null
    status: string | null
  }

  export type System_eventMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    event_type: string | null
    source_system: string | null
    target_system: string | null
    entity_type: string | null
    entity_id: string | null
    action: string | null
    created_at: Date | null
    processed_at: Date | null
    status: string | null
  }

  export type System_eventCountAggregateOutputType = {
    id: number
    tenant_id: number
    user_id: number
    event_type: number
    source_system: number
    target_system: number
    entity_type: number
    entity_id: number
    action: number
    event_data: number
    created_at: number
    processed_at: number
    status: number
    _all: number
  }


  export type System_eventMinAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    event_type?: true
    source_system?: true
    target_system?: true
    entity_type?: true
    entity_id?: true
    action?: true
    created_at?: true
    processed_at?: true
    status?: true
  }

  export type System_eventMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    event_type?: true
    source_system?: true
    target_system?: true
    entity_type?: true
    entity_id?: true
    action?: true
    created_at?: true
    processed_at?: true
    status?: true
  }

  export type System_eventCountAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    event_type?: true
    source_system?: true
    target_system?: true
    entity_type?: true
    entity_id?: true
    action?: true
    event_data?: true
    created_at?: true
    processed_at?: true
    status?: true
    _all?: true
  }

  export type System_eventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which system_event to aggregate.
     */
    where?: system_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_events to fetch.
     */
    orderBy?: system_eventOrderByWithRelationInput | system_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: system_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned system_events
    **/
    _count?: true | System_eventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: System_eventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: System_eventMaxAggregateInputType
  }

  export type GetSystem_eventAggregateType<T extends System_eventAggregateArgs> = {
        [P in keyof T & keyof AggregateSystem_event]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystem_event[P]>
      : GetScalarType<T[P], AggregateSystem_event[P]>
  }




  export type system_eventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: system_eventWhereInput
    orderBy?: system_eventOrderByWithAggregationInput | system_eventOrderByWithAggregationInput[]
    by: System_eventScalarFieldEnum[] | System_eventScalarFieldEnum
    having?: system_eventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: System_eventCountAggregateInputType | true
    _min?: System_eventMinAggregateInputType
    _max?: System_eventMaxAggregateInputType
  }

  export type System_eventGroupByOutputType = {
    id: string
    tenant_id: string
    user_id: string | null
    event_type: string
    source_system: string
    target_system: string
    entity_type: string
    entity_id: string
    action: string
    event_data: JsonValue | null
    created_at: Date
    processed_at: Date | null
    status: string
    _count: System_eventCountAggregateOutputType | null
    _min: System_eventMinAggregateOutputType | null
    _max: System_eventMaxAggregateOutputType | null
  }

  type GetSystem_eventGroupByPayload<T extends system_eventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<System_eventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof System_eventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], System_eventGroupByOutputType[P]>
            : GetScalarType<T[P], System_eventGroupByOutputType[P]>
        }
      >
    >


  export type system_eventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    event_type?: boolean
    source_system?: boolean
    target_system?: boolean
    entity_type?: boolean
    entity_id?: boolean
    action?: boolean
    event_data?: boolean
    created_at?: boolean
    processed_at?: boolean
    status?: boolean
  }, ExtArgs["result"]["system_event"]>

  export type system_eventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    event_type?: boolean
    source_system?: boolean
    target_system?: boolean
    entity_type?: boolean
    entity_id?: boolean
    action?: boolean
    event_data?: boolean
    created_at?: boolean
    processed_at?: boolean
    status?: boolean
  }, ExtArgs["result"]["system_event"]>

  export type system_eventSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    event_type?: boolean
    source_system?: boolean
    target_system?: boolean
    entity_type?: boolean
    entity_id?: boolean
    action?: boolean
    event_data?: boolean
    created_at?: boolean
    processed_at?: boolean
    status?: boolean
  }


  export type $system_eventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "system_event"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      user_id: string | null
      event_type: string
      source_system: string
      target_system: string
      entity_type: string
      entity_id: string
      action: string
      event_data: Prisma.JsonValue | null
      created_at: Date
      processed_at: Date | null
      status: string
    }, ExtArgs["result"]["system_event"]>
    composites: {}
  }

  type system_eventGetPayload<S extends boolean | null | undefined | system_eventDefaultArgs> = $Result.GetResult<Prisma.$system_eventPayload, S>

  type system_eventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<system_eventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: System_eventCountAggregateInputType | true
    }

  export interface system_eventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['system_event'], meta: { name: 'system_event' } }
    /**
     * Find zero or one System_event that matches the filter.
     * @param {system_eventFindUniqueArgs} args - Arguments to find a System_event
     * @example
     * // Get one System_event
     * const system_event = await prisma.system_event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends system_eventFindUniqueArgs>(args: SelectSubset<T, system_eventFindUniqueArgs<ExtArgs>>): Prisma__system_eventClient<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one System_event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {system_eventFindUniqueOrThrowArgs} args - Arguments to find a System_event
     * @example
     * // Get one System_event
     * const system_event = await prisma.system_event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends system_eventFindUniqueOrThrowArgs>(args: SelectSubset<T, system_eventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__system_eventClient<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first System_event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_eventFindFirstArgs} args - Arguments to find a System_event
     * @example
     * // Get one System_event
     * const system_event = await prisma.system_event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends system_eventFindFirstArgs>(args?: SelectSubset<T, system_eventFindFirstArgs<ExtArgs>>): Prisma__system_eventClient<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first System_event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_eventFindFirstOrThrowArgs} args - Arguments to find a System_event
     * @example
     * // Get one System_event
     * const system_event = await prisma.system_event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends system_eventFindFirstOrThrowArgs>(args?: SelectSubset<T, system_eventFindFirstOrThrowArgs<ExtArgs>>): Prisma__system_eventClient<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more System_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_eventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all System_events
     * const system_events = await prisma.system_event.findMany()
     * 
     * // Get first 10 System_events
     * const system_events = await prisma.system_event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const system_eventWithIdOnly = await prisma.system_event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends system_eventFindManyArgs>(args?: SelectSubset<T, system_eventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a System_event.
     * @param {system_eventCreateArgs} args - Arguments to create a System_event.
     * @example
     * // Create one System_event
     * const System_event = await prisma.system_event.create({
     *   data: {
     *     // ... data to create a System_event
     *   }
     * })
     * 
     */
    create<T extends system_eventCreateArgs>(args: SelectSubset<T, system_eventCreateArgs<ExtArgs>>): Prisma__system_eventClient<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many System_events.
     * @param {system_eventCreateManyArgs} args - Arguments to create many System_events.
     * @example
     * // Create many System_events
     * const system_event = await prisma.system_event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends system_eventCreateManyArgs>(args?: SelectSubset<T, system_eventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many System_events and returns the data saved in the database.
     * @param {system_eventCreateManyAndReturnArgs} args - Arguments to create many System_events.
     * @example
     * // Create many System_events
     * const system_event = await prisma.system_event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many System_events and only return the `id`
     * const system_eventWithIdOnly = await prisma.system_event.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends system_eventCreateManyAndReturnArgs>(args?: SelectSubset<T, system_eventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a System_event.
     * @param {system_eventDeleteArgs} args - Arguments to delete one System_event.
     * @example
     * // Delete one System_event
     * const System_event = await prisma.system_event.delete({
     *   where: {
     *     // ... filter to delete one System_event
     *   }
     * })
     * 
     */
    delete<T extends system_eventDeleteArgs>(args: SelectSubset<T, system_eventDeleteArgs<ExtArgs>>): Prisma__system_eventClient<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one System_event.
     * @param {system_eventUpdateArgs} args - Arguments to update one System_event.
     * @example
     * // Update one System_event
     * const system_event = await prisma.system_event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends system_eventUpdateArgs>(args: SelectSubset<T, system_eventUpdateArgs<ExtArgs>>): Prisma__system_eventClient<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more System_events.
     * @param {system_eventDeleteManyArgs} args - Arguments to filter System_events to delete.
     * @example
     * // Delete a few System_events
     * const { count } = await prisma.system_event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends system_eventDeleteManyArgs>(args?: SelectSubset<T, system_eventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more System_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many System_events
     * const system_event = await prisma.system_event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends system_eventUpdateManyArgs>(args: SelectSubset<T, system_eventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one System_event.
     * @param {system_eventUpsertArgs} args - Arguments to update or create a System_event.
     * @example
     * // Update or create a System_event
     * const system_event = await prisma.system_event.upsert({
     *   create: {
     *     // ... data to create a System_event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the System_event we want to update
     *   }
     * })
     */
    upsert<T extends system_eventUpsertArgs>(args: SelectSubset<T, system_eventUpsertArgs<ExtArgs>>): Prisma__system_eventClient<$Result.GetResult<Prisma.$system_eventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of System_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_eventCountArgs} args - Arguments to filter System_events to count.
     * @example
     * // Count the number of System_events
     * const count = await prisma.system_event.count({
     *   where: {
     *     // ... the filter for the System_events we want to count
     *   }
     * })
    **/
    count<T extends system_eventCountArgs>(
      args?: Subset<T, system_eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], System_eventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a System_event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {System_eventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends System_eventAggregateArgs>(args: Subset<T, System_eventAggregateArgs>): Prisma.PrismaPromise<GetSystem_eventAggregateType<T>>

    /**
     * Group by System_event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {system_eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends system_eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: system_eventGroupByArgs['orderBy'] }
        : { orderBy?: system_eventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, system_eventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystem_eventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the system_event model
   */
  readonly fields: system_eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for system_event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__system_eventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the system_event model
   */ 
  interface system_eventFieldRefs {
    readonly id: FieldRef<"system_event", 'String'>
    readonly tenant_id: FieldRef<"system_event", 'String'>
    readonly user_id: FieldRef<"system_event", 'String'>
    readonly event_type: FieldRef<"system_event", 'String'>
    readonly source_system: FieldRef<"system_event", 'String'>
    readonly target_system: FieldRef<"system_event", 'String'>
    readonly entity_type: FieldRef<"system_event", 'String'>
    readonly entity_id: FieldRef<"system_event", 'String'>
    readonly action: FieldRef<"system_event", 'String'>
    readonly event_data: FieldRef<"system_event", 'Json'>
    readonly created_at: FieldRef<"system_event", 'DateTime'>
    readonly processed_at: FieldRef<"system_event", 'DateTime'>
    readonly status: FieldRef<"system_event", 'String'>
  }
    

  // Custom InputTypes
  /**
   * system_event findUnique
   */
  export type system_eventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
    /**
     * Filter, which system_event to fetch.
     */
    where: system_eventWhereUniqueInput
  }

  /**
   * system_event findUniqueOrThrow
   */
  export type system_eventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
    /**
     * Filter, which system_event to fetch.
     */
    where: system_eventWhereUniqueInput
  }

  /**
   * system_event findFirst
   */
  export type system_eventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
    /**
     * Filter, which system_event to fetch.
     */
    where?: system_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_events to fetch.
     */
    orderBy?: system_eventOrderByWithRelationInput | system_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for system_events.
     */
    cursor?: system_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of system_events.
     */
    distinct?: System_eventScalarFieldEnum | System_eventScalarFieldEnum[]
  }

  /**
   * system_event findFirstOrThrow
   */
  export type system_eventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
    /**
     * Filter, which system_event to fetch.
     */
    where?: system_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_events to fetch.
     */
    orderBy?: system_eventOrderByWithRelationInput | system_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for system_events.
     */
    cursor?: system_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of system_events.
     */
    distinct?: System_eventScalarFieldEnum | System_eventScalarFieldEnum[]
  }

  /**
   * system_event findMany
   */
  export type system_eventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
    /**
     * Filter, which system_events to fetch.
     */
    where?: system_eventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of system_events to fetch.
     */
    orderBy?: system_eventOrderByWithRelationInput | system_eventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing system_events.
     */
    cursor?: system_eventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` system_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` system_events.
     */
    skip?: number
    distinct?: System_eventScalarFieldEnum | System_eventScalarFieldEnum[]
  }

  /**
   * system_event create
   */
  export type system_eventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
    /**
     * The data needed to create a system_event.
     */
    data: XOR<system_eventCreateInput, system_eventUncheckedCreateInput>
  }

  /**
   * system_event createMany
   */
  export type system_eventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many system_events.
     */
    data: system_eventCreateManyInput | system_eventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * system_event createManyAndReturn
   */
  export type system_eventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many system_events.
     */
    data: system_eventCreateManyInput | system_eventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * system_event update
   */
  export type system_eventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
    /**
     * The data needed to update a system_event.
     */
    data: XOR<system_eventUpdateInput, system_eventUncheckedUpdateInput>
    /**
     * Choose, which system_event to update.
     */
    where: system_eventWhereUniqueInput
  }

  /**
   * system_event updateMany
   */
  export type system_eventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update system_events.
     */
    data: XOR<system_eventUpdateManyMutationInput, system_eventUncheckedUpdateManyInput>
    /**
     * Filter which system_events to update
     */
    where?: system_eventWhereInput
  }

  /**
   * system_event upsert
   */
  export type system_eventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
    /**
     * The filter to search for the system_event to update in case it exists.
     */
    where: system_eventWhereUniqueInput
    /**
     * In case the system_event found by the `where` argument doesn't exist, create a new system_event with this data.
     */
    create: XOR<system_eventCreateInput, system_eventUncheckedCreateInput>
    /**
     * In case the system_event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<system_eventUpdateInput, system_eventUncheckedUpdateInput>
  }

  /**
   * system_event delete
   */
  export type system_eventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
    /**
     * Filter which system_event to delete.
     */
    where: system_eventWhereUniqueInput
  }

  /**
   * system_event deleteMany
   */
  export type system_eventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which system_events to delete
     */
    where?: system_eventWhereInput
  }

  /**
   * system_event without action
   */
  export type system_eventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the system_event
     */
    select?: system_eventSelect<ExtArgs> | null
  }


  /**
   * Model tenant_access_logs
   */

  export type AggregateTenant_access_logs = {
    _count: Tenant_access_logsCountAggregateOutputType | null
    _min: Tenant_access_logsMinAggregateOutputType | null
    _max: Tenant_access_logsMaxAggregateOutputType | null
  }

  export type Tenant_access_logsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    action: string | null
    resource: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
    source_system: string | null
  }

  export type Tenant_access_logsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    action: string | null
    resource: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
    source_system: string | null
  }

  export type Tenant_access_logsCountAggregateOutputType = {
    id: number
    tenant_id: number
    user_id: number
    action: number
    resource: number
    ip_address: number
    user_agent: number
    created_at: number
    source_system: number
    _all: number
  }


  export type Tenant_access_logsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    action?: true
    resource?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    source_system?: true
  }

  export type Tenant_access_logsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    action?: true
    resource?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    source_system?: true
  }

  export type Tenant_access_logsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    action?: true
    resource?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    source_system?: true
    _all?: true
  }

  export type Tenant_access_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenant_access_logs to aggregate.
     */
    where?: tenant_access_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenant_access_logs to fetch.
     */
    orderBy?: tenant_access_logsOrderByWithRelationInput | tenant_access_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tenant_access_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenant_access_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenant_access_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tenant_access_logs
    **/
    _count?: true | Tenant_access_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tenant_access_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tenant_access_logsMaxAggregateInputType
  }

  export type GetTenant_access_logsAggregateType<T extends Tenant_access_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant_access_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant_access_logs[P]>
      : GetScalarType<T[P], AggregateTenant_access_logs[P]>
  }




  export type tenant_access_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenant_access_logsWhereInput
    orderBy?: tenant_access_logsOrderByWithAggregationInput | tenant_access_logsOrderByWithAggregationInput[]
    by: Tenant_access_logsScalarFieldEnum[] | Tenant_access_logsScalarFieldEnum
    having?: tenant_access_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tenant_access_logsCountAggregateInputType | true
    _min?: Tenant_access_logsMinAggregateInputType
    _max?: Tenant_access_logsMaxAggregateInputType
  }

  export type Tenant_access_logsGroupByOutputType = {
    id: string
    tenant_id: string
    user_id: string | null
    action: string
    resource: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date
    source_system: string | null
    _count: Tenant_access_logsCountAggregateOutputType | null
    _min: Tenant_access_logsMinAggregateOutputType | null
    _max: Tenant_access_logsMaxAggregateOutputType | null
  }

  type GetTenant_access_logsGroupByPayload<T extends tenant_access_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tenant_access_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tenant_access_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tenant_access_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Tenant_access_logsGroupByOutputType[P]>
        }
      >
    >


  export type tenant_access_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    action?: boolean
    resource?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    source_system?: boolean
  }, ExtArgs["result"]["tenant_access_logs"]>

  export type tenant_access_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    action?: boolean
    resource?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    source_system?: boolean
  }, ExtArgs["result"]["tenant_access_logs"]>

  export type tenant_access_logsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    action?: boolean
    resource?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    source_system?: boolean
  }


  export type $tenant_access_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tenant_access_logs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      user_id: string | null
      action: string
      resource: string | null
      ip_address: string | null
      user_agent: string | null
      created_at: Date
      source_system: string | null
    }, ExtArgs["result"]["tenant_access_logs"]>
    composites: {}
  }

  type tenant_access_logsGetPayload<S extends boolean | null | undefined | tenant_access_logsDefaultArgs> = $Result.GetResult<Prisma.$tenant_access_logsPayload, S>

  type tenant_access_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tenant_access_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tenant_access_logsCountAggregateInputType | true
    }

  export interface tenant_access_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tenant_access_logs'], meta: { name: 'tenant_access_logs' } }
    /**
     * Find zero or one Tenant_access_logs that matches the filter.
     * @param {tenant_access_logsFindUniqueArgs} args - Arguments to find a Tenant_access_logs
     * @example
     * // Get one Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tenant_access_logsFindUniqueArgs>(args: SelectSubset<T, tenant_access_logsFindUniqueArgs<ExtArgs>>): Prisma__tenant_access_logsClient<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant_access_logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tenant_access_logsFindUniqueOrThrowArgs} args - Arguments to find a Tenant_access_logs
     * @example
     * // Get one Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tenant_access_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, tenant_access_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tenant_access_logsClient<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant_access_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_access_logsFindFirstArgs} args - Arguments to find a Tenant_access_logs
     * @example
     * // Get one Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tenant_access_logsFindFirstArgs>(args?: SelectSubset<T, tenant_access_logsFindFirstArgs<ExtArgs>>): Prisma__tenant_access_logsClient<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant_access_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_access_logsFindFirstOrThrowArgs} args - Arguments to find a Tenant_access_logs
     * @example
     * // Get one Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tenant_access_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, tenant_access_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tenant_access_logsClient<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenant_access_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_access_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.findMany()
     * 
     * // Get first 10 Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenant_access_logsWithIdOnly = await prisma.tenant_access_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tenant_access_logsFindManyArgs>(args?: SelectSubset<T, tenant_access_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant_access_logs.
     * @param {tenant_access_logsCreateArgs} args - Arguments to create a Tenant_access_logs.
     * @example
     * // Create one Tenant_access_logs
     * const Tenant_access_logs = await prisma.tenant_access_logs.create({
     *   data: {
     *     // ... data to create a Tenant_access_logs
     *   }
     * })
     * 
     */
    create<T extends tenant_access_logsCreateArgs>(args: SelectSubset<T, tenant_access_logsCreateArgs<ExtArgs>>): Prisma__tenant_access_logsClient<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenant_access_logs.
     * @param {tenant_access_logsCreateManyArgs} args - Arguments to create many Tenant_access_logs.
     * @example
     * // Create many Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tenant_access_logsCreateManyArgs>(args?: SelectSubset<T, tenant_access_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenant_access_logs and returns the data saved in the database.
     * @param {tenant_access_logsCreateManyAndReturnArgs} args - Arguments to create many Tenant_access_logs.
     * @example
     * // Create many Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenant_access_logs and only return the `id`
     * const tenant_access_logsWithIdOnly = await prisma.tenant_access_logs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tenant_access_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, tenant_access_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant_access_logs.
     * @param {tenant_access_logsDeleteArgs} args - Arguments to delete one Tenant_access_logs.
     * @example
     * // Delete one Tenant_access_logs
     * const Tenant_access_logs = await prisma.tenant_access_logs.delete({
     *   where: {
     *     // ... filter to delete one Tenant_access_logs
     *   }
     * })
     * 
     */
    delete<T extends tenant_access_logsDeleteArgs>(args: SelectSubset<T, tenant_access_logsDeleteArgs<ExtArgs>>): Prisma__tenant_access_logsClient<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant_access_logs.
     * @param {tenant_access_logsUpdateArgs} args - Arguments to update one Tenant_access_logs.
     * @example
     * // Update one Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tenant_access_logsUpdateArgs>(args: SelectSubset<T, tenant_access_logsUpdateArgs<ExtArgs>>): Prisma__tenant_access_logsClient<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenant_access_logs.
     * @param {tenant_access_logsDeleteManyArgs} args - Arguments to filter Tenant_access_logs to delete.
     * @example
     * // Delete a few Tenant_access_logs
     * const { count } = await prisma.tenant_access_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tenant_access_logsDeleteManyArgs>(args?: SelectSubset<T, tenant_access_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenant_access_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_access_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tenant_access_logsUpdateManyArgs>(args: SelectSubset<T, tenant_access_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant_access_logs.
     * @param {tenant_access_logsUpsertArgs} args - Arguments to update or create a Tenant_access_logs.
     * @example
     * // Update or create a Tenant_access_logs
     * const tenant_access_logs = await prisma.tenant_access_logs.upsert({
     *   create: {
     *     // ... data to create a Tenant_access_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant_access_logs we want to update
     *   }
     * })
     */
    upsert<T extends tenant_access_logsUpsertArgs>(args: SelectSubset<T, tenant_access_logsUpsertArgs<ExtArgs>>): Prisma__tenant_access_logsClient<$Result.GetResult<Prisma.$tenant_access_logsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenant_access_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_access_logsCountArgs} args - Arguments to filter Tenant_access_logs to count.
     * @example
     * // Count the number of Tenant_access_logs
     * const count = await prisma.tenant_access_logs.count({
     *   where: {
     *     // ... the filter for the Tenant_access_logs we want to count
     *   }
     * })
    **/
    count<T extends tenant_access_logsCountArgs>(
      args?: Subset<T, tenant_access_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tenant_access_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant_access_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tenant_access_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tenant_access_logsAggregateArgs>(args: Subset<T, Tenant_access_logsAggregateArgs>): Prisma.PrismaPromise<GetTenant_access_logsAggregateType<T>>

    /**
     * Group by Tenant_access_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_access_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tenant_access_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tenant_access_logsGroupByArgs['orderBy'] }
        : { orderBy?: tenant_access_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tenant_access_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenant_access_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tenant_access_logs model
   */
  readonly fields: tenant_access_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tenant_access_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tenant_access_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tenant_access_logs model
   */ 
  interface tenant_access_logsFieldRefs {
    readonly id: FieldRef<"tenant_access_logs", 'String'>
    readonly tenant_id: FieldRef<"tenant_access_logs", 'String'>
    readonly user_id: FieldRef<"tenant_access_logs", 'String'>
    readonly action: FieldRef<"tenant_access_logs", 'String'>
    readonly resource: FieldRef<"tenant_access_logs", 'String'>
    readonly ip_address: FieldRef<"tenant_access_logs", 'String'>
    readonly user_agent: FieldRef<"tenant_access_logs", 'String'>
    readonly created_at: FieldRef<"tenant_access_logs", 'DateTime'>
    readonly source_system: FieldRef<"tenant_access_logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tenant_access_logs findUnique
   */
  export type tenant_access_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
    /**
     * Filter, which tenant_access_logs to fetch.
     */
    where: tenant_access_logsWhereUniqueInput
  }

  /**
   * tenant_access_logs findUniqueOrThrow
   */
  export type tenant_access_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
    /**
     * Filter, which tenant_access_logs to fetch.
     */
    where: tenant_access_logsWhereUniqueInput
  }

  /**
   * tenant_access_logs findFirst
   */
  export type tenant_access_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
    /**
     * Filter, which tenant_access_logs to fetch.
     */
    where?: tenant_access_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenant_access_logs to fetch.
     */
    orderBy?: tenant_access_logsOrderByWithRelationInput | tenant_access_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenant_access_logs.
     */
    cursor?: tenant_access_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenant_access_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenant_access_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenant_access_logs.
     */
    distinct?: Tenant_access_logsScalarFieldEnum | Tenant_access_logsScalarFieldEnum[]
  }

  /**
   * tenant_access_logs findFirstOrThrow
   */
  export type tenant_access_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
    /**
     * Filter, which tenant_access_logs to fetch.
     */
    where?: tenant_access_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenant_access_logs to fetch.
     */
    orderBy?: tenant_access_logsOrderByWithRelationInput | tenant_access_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenant_access_logs.
     */
    cursor?: tenant_access_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenant_access_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenant_access_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenant_access_logs.
     */
    distinct?: Tenant_access_logsScalarFieldEnum | Tenant_access_logsScalarFieldEnum[]
  }

  /**
   * tenant_access_logs findMany
   */
  export type tenant_access_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
    /**
     * Filter, which tenant_access_logs to fetch.
     */
    where?: tenant_access_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenant_access_logs to fetch.
     */
    orderBy?: tenant_access_logsOrderByWithRelationInput | tenant_access_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tenant_access_logs.
     */
    cursor?: tenant_access_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenant_access_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenant_access_logs.
     */
    skip?: number
    distinct?: Tenant_access_logsScalarFieldEnum | Tenant_access_logsScalarFieldEnum[]
  }

  /**
   * tenant_access_logs create
   */
  export type tenant_access_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
    /**
     * The data needed to create a tenant_access_logs.
     */
    data: XOR<tenant_access_logsCreateInput, tenant_access_logsUncheckedCreateInput>
  }

  /**
   * tenant_access_logs createMany
   */
  export type tenant_access_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tenant_access_logs.
     */
    data: tenant_access_logsCreateManyInput | tenant_access_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenant_access_logs createManyAndReturn
   */
  export type tenant_access_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tenant_access_logs.
     */
    data: tenant_access_logsCreateManyInput | tenant_access_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenant_access_logs update
   */
  export type tenant_access_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
    /**
     * The data needed to update a tenant_access_logs.
     */
    data: XOR<tenant_access_logsUpdateInput, tenant_access_logsUncheckedUpdateInput>
    /**
     * Choose, which tenant_access_logs to update.
     */
    where: tenant_access_logsWhereUniqueInput
  }

  /**
   * tenant_access_logs updateMany
   */
  export type tenant_access_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tenant_access_logs.
     */
    data: XOR<tenant_access_logsUpdateManyMutationInput, tenant_access_logsUncheckedUpdateManyInput>
    /**
     * Filter which tenant_access_logs to update
     */
    where?: tenant_access_logsWhereInput
  }

  /**
   * tenant_access_logs upsert
   */
  export type tenant_access_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
    /**
     * The filter to search for the tenant_access_logs to update in case it exists.
     */
    where: tenant_access_logsWhereUniqueInput
    /**
     * In case the tenant_access_logs found by the `where` argument doesn't exist, create a new tenant_access_logs with this data.
     */
    create: XOR<tenant_access_logsCreateInput, tenant_access_logsUncheckedCreateInput>
    /**
     * In case the tenant_access_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tenant_access_logsUpdateInput, tenant_access_logsUncheckedUpdateInput>
  }

  /**
   * tenant_access_logs delete
   */
  export type tenant_access_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
    /**
     * Filter which tenant_access_logs to delete.
     */
    where: tenant_access_logsWhereUniqueInput
  }

  /**
   * tenant_access_logs deleteMany
   */
  export type tenant_access_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenant_access_logs to delete
     */
    where?: tenant_access_logsWhereInput
  }

  /**
   * tenant_access_logs without action
   */
  export type tenant_access_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_access_logs
     */
    select?: tenant_access_logsSelect<ExtArgs> | null
  }


  /**
   * Model tenant_services
   */

  export type AggregateTenant_services = {
    _count: Tenant_servicesCountAggregateOutputType | null
    _min: Tenant_servicesMinAggregateOutputType | null
    _max: Tenant_servicesMaxAggregateOutputType | null
  }

  export type Tenant_servicesMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    service_type: string | null
    plan_type: string | null
    is_active: boolean | null
    activated_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Tenant_servicesMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    service_type: string | null
    plan_type: string | null
    is_active: boolean | null
    activated_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Tenant_servicesCountAggregateOutputType = {
    id: number
    tenant_id: number
    service_type: number
    plan_type: number
    is_active: number
    activated_at: number
    expires_at: number
    service_config: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Tenant_servicesMinAggregateInputType = {
    id?: true
    tenant_id?: true
    service_type?: true
    plan_type?: true
    is_active?: true
    activated_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Tenant_servicesMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    service_type?: true
    plan_type?: true
    is_active?: true
    activated_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Tenant_servicesCountAggregateInputType = {
    id?: true
    tenant_id?: true
    service_type?: true
    plan_type?: true
    is_active?: true
    activated_at?: true
    expires_at?: true
    service_config?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Tenant_servicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenant_services to aggregate.
     */
    where?: tenant_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenant_services to fetch.
     */
    orderBy?: tenant_servicesOrderByWithRelationInput | tenant_servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tenant_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenant_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenant_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tenant_services
    **/
    _count?: true | Tenant_servicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tenant_servicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tenant_servicesMaxAggregateInputType
  }

  export type GetTenant_servicesAggregateType<T extends Tenant_servicesAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant_services]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant_services[P]>
      : GetScalarType<T[P], AggregateTenant_services[P]>
  }




  export type tenant_servicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tenant_servicesWhereInput
    orderBy?: tenant_servicesOrderByWithAggregationInput | tenant_servicesOrderByWithAggregationInput[]
    by: Tenant_servicesScalarFieldEnum[] | Tenant_servicesScalarFieldEnum
    having?: tenant_servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tenant_servicesCountAggregateInputType | true
    _min?: Tenant_servicesMinAggregateInputType
    _max?: Tenant_servicesMaxAggregateInputType
  }

  export type Tenant_servicesGroupByOutputType = {
    id: string
    tenant_id: string
    service_type: string
    plan_type: string
    is_active: boolean
    activated_at: Date
    expires_at: Date | null
    service_config: JsonValue
    created_at: Date
    updated_at: Date
    _count: Tenant_servicesCountAggregateOutputType | null
    _min: Tenant_servicesMinAggregateOutputType | null
    _max: Tenant_servicesMaxAggregateOutputType | null
  }

  type GetTenant_servicesGroupByPayload<T extends tenant_servicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tenant_servicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tenant_servicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tenant_servicesGroupByOutputType[P]>
            : GetScalarType<T[P], Tenant_servicesGroupByOutputType[P]>
        }
      >
    >


  export type tenant_servicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    service_type?: boolean
    plan_type?: boolean
    is_active?: boolean
    activated_at?: boolean
    expires_at?: boolean
    service_config?: boolean
    created_at?: boolean
    updated_at?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant_services"]>

  export type tenant_servicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    service_type?: boolean
    plan_type?: boolean
    is_active?: boolean
    activated_at?: boolean
    expires_at?: boolean
    service_config?: boolean
    created_at?: boolean
    updated_at?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant_services"]>

  export type tenant_servicesSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    service_type?: boolean
    plan_type?: boolean
    is_active?: boolean
    activated_at?: boolean
    expires_at?: boolean
    service_config?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tenant_servicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type tenant_servicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $tenant_servicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tenant_services"
    objects: {
      Tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      service_type: string
      plan_type: string
      is_active: boolean
      activated_at: Date
      expires_at: Date | null
      service_config: Prisma.JsonValue
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenant_services"]>
    composites: {}
  }

  type tenant_servicesGetPayload<S extends boolean | null | undefined | tenant_servicesDefaultArgs> = $Result.GetResult<Prisma.$tenant_servicesPayload, S>

  type tenant_servicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tenant_servicesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tenant_servicesCountAggregateInputType | true
    }

  export interface tenant_servicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tenant_services'], meta: { name: 'tenant_services' } }
    /**
     * Find zero or one Tenant_services that matches the filter.
     * @param {tenant_servicesFindUniqueArgs} args - Arguments to find a Tenant_services
     * @example
     * // Get one Tenant_services
     * const tenant_services = await prisma.tenant_services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tenant_servicesFindUniqueArgs>(args: SelectSubset<T, tenant_servicesFindUniqueArgs<ExtArgs>>): Prisma__tenant_servicesClient<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant_services that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tenant_servicesFindUniqueOrThrowArgs} args - Arguments to find a Tenant_services
     * @example
     * // Get one Tenant_services
     * const tenant_services = await prisma.tenant_services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tenant_servicesFindUniqueOrThrowArgs>(args: SelectSubset<T, tenant_servicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tenant_servicesClient<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_servicesFindFirstArgs} args - Arguments to find a Tenant_services
     * @example
     * // Get one Tenant_services
     * const tenant_services = await prisma.tenant_services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tenant_servicesFindFirstArgs>(args?: SelectSubset<T, tenant_servicesFindFirstArgs<ExtArgs>>): Prisma__tenant_servicesClient<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant_services that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_servicesFindFirstOrThrowArgs} args - Arguments to find a Tenant_services
     * @example
     * // Get one Tenant_services
     * const tenant_services = await prisma.tenant_services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tenant_servicesFindFirstOrThrowArgs>(args?: SelectSubset<T, tenant_servicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tenant_servicesClient<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenant_services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_servicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenant_services
     * const tenant_services = await prisma.tenant_services.findMany()
     * 
     * // Get first 10 Tenant_services
     * const tenant_services = await prisma.tenant_services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenant_servicesWithIdOnly = await prisma.tenant_services.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tenant_servicesFindManyArgs>(args?: SelectSubset<T, tenant_servicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant_services.
     * @param {tenant_servicesCreateArgs} args - Arguments to create a Tenant_services.
     * @example
     * // Create one Tenant_services
     * const Tenant_services = await prisma.tenant_services.create({
     *   data: {
     *     // ... data to create a Tenant_services
     *   }
     * })
     * 
     */
    create<T extends tenant_servicesCreateArgs>(args: SelectSubset<T, tenant_servicesCreateArgs<ExtArgs>>): Prisma__tenant_servicesClient<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenant_services.
     * @param {tenant_servicesCreateManyArgs} args - Arguments to create many Tenant_services.
     * @example
     * // Create many Tenant_services
     * const tenant_services = await prisma.tenant_services.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tenant_servicesCreateManyArgs>(args?: SelectSubset<T, tenant_servicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenant_services and returns the data saved in the database.
     * @param {tenant_servicesCreateManyAndReturnArgs} args - Arguments to create many Tenant_services.
     * @example
     * // Create many Tenant_services
     * const tenant_services = await prisma.tenant_services.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenant_services and only return the `id`
     * const tenant_servicesWithIdOnly = await prisma.tenant_services.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tenant_servicesCreateManyAndReturnArgs>(args?: SelectSubset<T, tenant_servicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant_services.
     * @param {tenant_servicesDeleteArgs} args - Arguments to delete one Tenant_services.
     * @example
     * // Delete one Tenant_services
     * const Tenant_services = await prisma.tenant_services.delete({
     *   where: {
     *     // ... filter to delete one Tenant_services
     *   }
     * })
     * 
     */
    delete<T extends tenant_servicesDeleteArgs>(args: SelectSubset<T, tenant_servicesDeleteArgs<ExtArgs>>): Prisma__tenant_servicesClient<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant_services.
     * @param {tenant_servicesUpdateArgs} args - Arguments to update one Tenant_services.
     * @example
     * // Update one Tenant_services
     * const tenant_services = await prisma.tenant_services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tenant_servicesUpdateArgs>(args: SelectSubset<T, tenant_servicesUpdateArgs<ExtArgs>>): Prisma__tenant_servicesClient<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenant_services.
     * @param {tenant_servicesDeleteManyArgs} args - Arguments to filter Tenant_services to delete.
     * @example
     * // Delete a few Tenant_services
     * const { count } = await prisma.tenant_services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tenant_servicesDeleteManyArgs>(args?: SelectSubset<T, tenant_servicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenant_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenant_services
     * const tenant_services = await prisma.tenant_services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tenant_servicesUpdateManyArgs>(args: SelectSubset<T, tenant_servicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant_services.
     * @param {tenant_servicesUpsertArgs} args - Arguments to update or create a Tenant_services.
     * @example
     * // Update or create a Tenant_services
     * const tenant_services = await prisma.tenant_services.upsert({
     *   create: {
     *     // ... data to create a Tenant_services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant_services we want to update
     *   }
     * })
     */
    upsert<T extends tenant_servicesUpsertArgs>(args: SelectSubset<T, tenant_servicesUpsertArgs<ExtArgs>>): Prisma__tenant_servicesClient<$Result.GetResult<Prisma.$tenant_servicesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenant_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_servicesCountArgs} args - Arguments to filter Tenant_services to count.
     * @example
     * // Count the number of Tenant_services
     * const count = await prisma.tenant_services.count({
     *   where: {
     *     // ... the filter for the Tenant_services we want to count
     *   }
     * })
    **/
    count<T extends tenant_servicesCountArgs>(
      args?: Subset<T, tenant_servicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tenant_servicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tenant_servicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tenant_servicesAggregateArgs>(args: Subset<T, Tenant_servicesAggregateArgs>): Prisma.PrismaPromise<GetTenant_servicesAggregateType<T>>

    /**
     * Group by Tenant_services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tenant_servicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tenant_servicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tenant_servicesGroupByArgs['orderBy'] }
        : { orderBy?: tenant_servicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tenant_servicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenant_servicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tenant_services model
   */
  readonly fields: tenant_servicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tenant_services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tenant_servicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tenant_services model
   */ 
  interface tenant_servicesFieldRefs {
    readonly id: FieldRef<"tenant_services", 'String'>
    readonly tenant_id: FieldRef<"tenant_services", 'String'>
    readonly service_type: FieldRef<"tenant_services", 'String'>
    readonly plan_type: FieldRef<"tenant_services", 'String'>
    readonly is_active: FieldRef<"tenant_services", 'Boolean'>
    readonly activated_at: FieldRef<"tenant_services", 'DateTime'>
    readonly expires_at: FieldRef<"tenant_services", 'DateTime'>
    readonly service_config: FieldRef<"tenant_services", 'Json'>
    readonly created_at: FieldRef<"tenant_services", 'DateTime'>
    readonly updated_at: FieldRef<"tenant_services", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tenant_services findUnique
   */
  export type tenant_servicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    /**
     * Filter, which tenant_services to fetch.
     */
    where: tenant_servicesWhereUniqueInput
  }

  /**
   * tenant_services findUniqueOrThrow
   */
  export type tenant_servicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    /**
     * Filter, which tenant_services to fetch.
     */
    where: tenant_servicesWhereUniqueInput
  }

  /**
   * tenant_services findFirst
   */
  export type tenant_servicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    /**
     * Filter, which tenant_services to fetch.
     */
    where?: tenant_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenant_services to fetch.
     */
    orderBy?: tenant_servicesOrderByWithRelationInput | tenant_servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenant_services.
     */
    cursor?: tenant_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenant_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenant_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenant_services.
     */
    distinct?: Tenant_servicesScalarFieldEnum | Tenant_servicesScalarFieldEnum[]
  }

  /**
   * tenant_services findFirstOrThrow
   */
  export type tenant_servicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    /**
     * Filter, which tenant_services to fetch.
     */
    where?: tenant_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenant_services to fetch.
     */
    orderBy?: tenant_servicesOrderByWithRelationInput | tenant_servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tenant_services.
     */
    cursor?: tenant_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenant_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenant_services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tenant_services.
     */
    distinct?: Tenant_servicesScalarFieldEnum | Tenant_servicesScalarFieldEnum[]
  }

  /**
   * tenant_services findMany
   */
  export type tenant_servicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    /**
     * Filter, which tenant_services to fetch.
     */
    where?: tenant_servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tenant_services to fetch.
     */
    orderBy?: tenant_servicesOrderByWithRelationInput | tenant_servicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tenant_services.
     */
    cursor?: tenant_servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tenant_services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tenant_services.
     */
    skip?: number
    distinct?: Tenant_servicesScalarFieldEnum | Tenant_servicesScalarFieldEnum[]
  }

  /**
   * tenant_services create
   */
  export type tenant_servicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    /**
     * The data needed to create a tenant_services.
     */
    data: XOR<tenant_servicesCreateInput, tenant_servicesUncheckedCreateInput>
  }

  /**
   * tenant_services createMany
   */
  export type tenant_servicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tenant_services.
     */
    data: tenant_servicesCreateManyInput | tenant_servicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tenant_services createManyAndReturn
   */
  export type tenant_servicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tenant_services.
     */
    data: tenant_servicesCreateManyInput | tenant_servicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tenant_services update
   */
  export type tenant_servicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    /**
     * The data needed to update a tenant_services.
     */
    data: XOR<tenant_servicesUpdateInput, tenant_servicesUncheckedUpdateInput>
    /**
     * Choose, which tenant_services to update.
     */
    where: tenant_servicesWhereUniqueInput
  }

  /**
   * tenant_services updateMany
   */
  export type tenant_servicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tenant_services.
     */
    data: XOR<tenant_servicesUpdateManyMutationInput, tenant_servicesUncheckedUpdateManyInput>
    /**
     * Filter which tenant_services to update
     */
    where?: tenant_servicesWhereInput
  }

  /**
   * tenant_services upsert
   */
  export type tenant_servicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    /**
     * The filter to search for the tenant_services to update in case it exists.
     */
    where: tenant_servicesWhereUniqueInput
    /**
     * In case the tenant_services found by the `where` argument doesn't exist, create a new tenant_services with this data.
     */
    create: XOR<tenant_servicesCreateInput, tenant_servicesUncheckedCreateInput>
    /**
     * In case the tenant_services was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tenant_servicesUpdateInput, tenant_servicesUncheckedUpdateInput>
  }

  /**
   * tenant_services delete
   */
  export type tenant_servicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
    /**
     * Filter which tenant_services to delete.
     */
    where: tenant_servicesWhereUniqueInput
  }

  /**
   * tenant_services deleteMany
   */
  export type tenant_servicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tenant_services to delete
     */
    where?: tenant_servicesWhereInput
  }

  /**
   * tenant_services without action
   */
  export type tenant_servicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tenant_services
     */
    select?: tenant_servicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tenant_servicesInclude<ExtArgs> | null
  }


  /**
   * Model checkin_sessions
   */

  export type AggregateCheckin_sessions = {
    _count: Checkin_sessionsCountAggregateOutputType | null
    _avg: Checkin_sessionsAvgAggregateOutputType | null
    _sum: Checkin_sessionsSumAggregateOutputType | null
    _min: Checkin_sessionsMinAggregateOutputType | null
    _max: Checkin_sessionsMaxAggregateOutputType | null
  }

  export type Checkin_sessionsAvgAggregateOutputType = {
    adults: number | null
    children: number | null
  }

  export type Checkin_sessionsSumAggregateOutputType = {
    adults: number | null
    children: number | null
  }

  export type Checkin_sessionsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    session_number: string | null
    reservation_id: string | null
    room_id: string | null
    adults: number | null
    children: number | null
    check_in_at: Date | null
    check_out_at: Date | null
    planned_check_out: Date | null
    status: string | null
    special_requests: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Checkin_sessionsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    session_number: string | null
    reservation_id: string | null
    room_id: string | null
    adults: number | null
    children: number | null
    check_in_at: Date | null
    check_out_at: Date | null
    planned_check_out: Date | null
    status: string | null
    special_requests: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Checkin_sessionsCountAggregateOutputType = {
    id: number
    tenant_id: number
    session_number: number
    reservation_id: number
    room_id: number
    guest_info: number
    adults: number
    children: number
    check_in_at: number
    check_out_at: number
    planned_check_out: number
    status: number
    special_requests: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Checkin_sessionsAvgAggregateInputType = {
    adults?: true
    children?: true
  }

  export type Checkin_sessionsSumAggregateInputType = {
    adults?: true
    children?: true
  }

  export type Checkin_sessionsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    session_number?: true
    reservation_id?: true
    room_id?: true
    adults?: true
    children?: true
    check_in_at?: true
    check_out_at?: true
    planned_check_out?: true
    status?: true
    special_requests?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Checkin_sessionsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    session_number?: true
    reservation_id?: true
    room_id?: true
    adults?: true
    children?: true
    check_in_at?: true
    check_out_at?: true
    planned_check_out?: true
    status?: true
    special_requests?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Checkin_sessionsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    session_number?: true
    reservation_id?: true
    room_id?: true
    guest_info?: true
    adults?: true
    children?: true
    check_in_at?: true
    check_out_at?: true
    planned_check_out?: true
    status?: true
    special_requests?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Checkin_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checkin_sessions to aggregate.
     */
    where?: checkin_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkin_sessions to fetch.
     */
    orderBy?: checkin_sessionsOrderByWithRelationInput | checkin_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: checkin_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkin_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkin_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned checkin_sessions
    **/
    _count?: true | Checkin_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Checkin_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Checkin_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Checkin_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Checkin_sessionsMaxAggregateInputType
  }

  export type GetCheckin_sessionsAggregateType<T extends Checkin_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckin_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckin_sessions[P]>
      : GetScalarType<T[P], AggregateCheckin_sessions[P]>
  }




  export type checkin_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkin_sessionsWhereInput
    orderBy?: checkin_sessionsOrderByWithAggregationInput | checkin_sessionsOrderByWithAggregationInput[]
    by: Checkin_sessionsScalarFieldEnum[] | Checkin_sessionsScalarFieldEnum
    having?: checkin_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Checkin_sessionsCountAggregateInputType | true
    _avg?: Checkin_sessionsAvgAggregateInputType
    _sum?: Checkin_sessionsSumAggregateInputType
    _min?: Checkin_sessionsMinAggregateInputType
    _max?: Checkin_sessionsMaxAggregateInputType
  }

  export type Checkin_sessionsGroupByOutputType = {
    id: string
    tenant_id: string
    session_number: string
    reservation_id: string | null
    room_id: string
    guest_info: JsonValue
    adults: number
    children: number
    check_in_at: Date
    check_out_at: Date | null
    planned_check_out: Date
    status: string
    special_requests: string | null
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: Checkin_sessionsCountAggregateOutputType | null
    _avg: Checkin_sessionsAvgAggregateOutputType | null
    _sum: Checkin_sessionsSumAggregateOutputType | null
    _min: Checkin_sessionsMinAggregateOutputType | null
    _max: Checkin_sessionsMaxAggregateOutputType | null
  }

  type GetCheckin_sessionsGroupByPayload<T extends checkin_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Checkin_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Checkin_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Checkin_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Checkin_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type checkin_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    session_number?: boolean
    reservation_id?: boolean
    room_id?: boolean
    guest_info?: boolean
    adults?: boolean
    children?: boolean
    check_in_at?: boolean
    check_out_at?: boolean
    planned_check_out?: boolean
    status?: boolean
    special_requests?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["checkin_sessions"]>

  export type checkin_sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    session_number?: boolean
    reservation_id?: boolean
    room_id?: boolean
    guest_info?: boolean
    adults?: boolean
    children?: boolean
    check_in_at?: boolean
    check_out_at?: boolean
    planned_check_out?: boolean
    status?: boolean
    special_requests?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["checkin_sessions"]>

  export type checkin_sessionsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    session_number?: boolean
    reservation_id?: boolean
    room_id?: boolean
    guest_info?: boolean
    adults?: boolean
    children?: boolean
    check_in_at?: boolean
    check_out_at?: boolean
    planned_check_out?: boolean
    status?: boolean
    special_requests?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $checkin_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "checkin_sessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      session_number: string
      reservation_id: string | null
      room_id: string
      guest_info: Prisma.JsonValue
      adults: number
      children: number
      check_in_at: Date
      check_out_at: Date | null
      planned_check_out: Date
      status: string
      special_requests: string | null
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["checkin_sessions"]>
    composites: {}
  }

  type checkin_sessionsGetPayload<S extends boolean | null | undefined | checkin_sessionsDefaultArgs> = $Result.GetResult<Prisma.$checkin_sessionsPayload, S>

  type checkin_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<checkin_sessionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Checkin_sessionsCountAggregateInputType | true
    }

  export interface checkin_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['checkin_sessions'], meta: { name: 'checkin_sessions' } }
    /**
     * Find zero or one Checkin_sessions that matches the filter.
     * @param {checkin_sessionsFindUniqueArgs} args - Arguments to find a Checkin_sessions
     * @example
     * // Get one Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends checkin_sessionsFindUniqueArgs>(args: SelectSubset<T, checkin_sessionsFindUniqueArgs<ExtArgs>>): Prisma__checkin_sessionsClient<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Checkin_sessions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {checkin_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Checkin_sessions
     * @example
     * // Get one Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends checkin_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, checkin_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__checkin_sessionsClient<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Checkin_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkin_sessionsFindFirstArgs} args - Arguments to find a Checkin_sessions
     * @example
     * // Get one Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends checkin_sessionsFindFirstArgs>(args?: SelectSubset<T, checkin_sessionsFindFirstArgs<ExtArgs>>): Prisma__checkin_sessionsClient<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Checkin_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkin_sessionsFindFirstOrThrowArgs} args - Arguments to find a Checkin_sessions
     * @example
     * // Get one Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends checkin_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, checkin_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__checkin_sessionsClient<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Checkin_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkin_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.findMany()
     * 
     * // Get first 10 Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkin_sessionsWithIdOnly = await prisma.checkin_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends checkin_sessionsFindManyArgs>(args?: SelectSubset<T, checkin_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Checkin_sessions.
     * @param {checkin_sessionsCreateArgs} args - Arguments to create a Checkin_sessions.
     * @example
     * // Create one Checkin_sessions
     * const Checkin_sessions = await prisma.checkin_sessions.create({
     *   data: {
     *     // ... data to create a Checkin_sessions
     *   }
     * })
     * 
     */
    create<T extends checkin_sessionsCreateArgs>(args: SelectSubset<T, checkin_sessionsCreateArgs<ExtArgs>>): Prisma__checkin_sessionsClient<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Checkin_sessions.
     * @param {checkin_sessionsCreateManyArgs} args - Arguments to create many Checkin_sessions.
     * @example
     * // Create many Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends checkin_sessionsCreateManyArgs>(args?: SelectSubset<T, checkin_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Checkin_sessions and returns the data saved in the database.
     * @param {checkin_sessionsCreateManyAndReturnArgs} args - Arguments to create many Checkin_sessions.
     * @example
     * // Create many Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Checkin_sessions and only return the `id`
     * const checkin_sessionsWithIdOnly = await prisma.checkin_sessions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends checkin_sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, checkin_sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Checkin_sessions.
     * @param {checkin_sessionsDeleteArgs} args - Arguments to delete one Checkin_sessions.
     * @example
     * // Delete one Checkin_sessions
     * const Checkin_sessions = await prisma.checkin_sessions.delete({
     *   where: {
     *     // ... filter to delete one Checkin_sessions
     *   }
     * })
     * 
     */
    delete<T extends checkin_sessionsDeleteArgs>(args: SelectSubset<T, checkin_sessionsDeleteArgs<ExtArgs>>): Prisma__checkin_sessionsClient<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Checkin_sessions.
     * @param {checkin_sessionsUpdateArgs} args - Arguments to update one Checkin_sessions.
     * @example
     * // Update one Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends checkin_sessionsUpdateArgs>(args: SelectSubset<T, checkin_sessionsUpdateArgs<ExtArgs>>): Prisma__checkin_sessionsClient<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Checkin_sessions.
     * @param {checkin_sessionsDeleteManyArgs} args - Arguments to filter Checkin_sessions to delete.
     * @example
     * // Delete a few Checkin_sessions
     * const { count } = await prisma.checkin_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends checkin_sessionsDeleteManyArgs>(args?: SelectSubset<T, checkin_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkin_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkin_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends checkin_sessionsUpdateManyArgs>(args: SelectSubset<T, checkin_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Checkin_sessions.
     * @param {checkin_sessionsUpsertArgs} args - Arguments to update or create a Checkin_sessions.
     * @example
     * // Update or create a Checkin_sessions
     * const checkin_sessions = await prisma.checkin_sessions.upsert({
     *   create: {
     *     // ... data to create a Checkin_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checkin_sessions we want to update
     *   }
     * })
     */
    upsert<T extends checkin_sessionsUpsertArgs>(args: SelectSubset<T, checkin_sessionsUpsertArgs<ExtArgs>>): Prisma__checkin_sessionsClient<$Result.GetResult<Prisma.$checkin_sessionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Checkin_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkin_sessionsCountArgs} args - Arguments to filter Checkin_sessions to count.
     * @example
     * // Count the number of Checkin_sessions
     * const count = await prisma.checkin_sessions.count({
     *   where: {
     *     // ... the filter for the Checkin_sessions we want to count
     *   }
     * })
    **/
    count<T extends checkin_sessionsCountArgs>(
      args?: Subset<T, checkin_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Checkin_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checkin_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Checkin_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Checkin_sessionsAggregateArgs>(args: Subset<T, Checkin_sessionsAggregateArgs>): Prisma.PrismaPromise<GetCheckin_sessionsAggregateType<T>>

    /**
     * Group by Checkin_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkin_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends checkin_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: checkin_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: checkin_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, checkin_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckin_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the checkin_sessions model
   */
  readonly fields: checkin_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for checkin_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__checkin_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the checkin_sessions model
   */ 
  interface checkin_sessionsFieldRefs {
    readonly id: FieldRef<"checkin_sessions", 'String'>
    readonly tenant_id: FieldRef<"checkin_sessions", 'String'>
    readonly session_number: FieldRef<"checkin_sessions", 'String'>
    readonly reservation_id: FieldRef<"checkin_sessions", 'String'>
    readonly room_id: FieldRef<"checkin_sessions", 'String'>
    readonly guest_info: FieldRef<"checkin_sessions", 'Json'>
    readonly adults: FieldRef<"checkin_sessions", 'Int'>
    readonly children: FieldRef<"checkin_sessions", 'Int'>
    readonly check_in_at: FieldRef<"checkin_sessions", 'DateTime'>
    readonly check_out_at: FieldRef<"checkin_sessions", 'DateTime'>
    readonly planned_check_out: FieldRef<"checkin_sessions", 'DateTime'>
    readonly status: FieldRef<"checkin_sessions", 'String'>
    readonly special_requests: FieldRef<"checkin_sessions", 'String'>
    readonly notes: FieldRef<"checkin_sessions", 'String'>
    readonly created_at: FieldRef<"checkin_sessions", 'DateTime'>
    readonly updated_at: FieldRef<"checkin_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * checkin_sessions findUnique
   */
  export type checkin_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
    /**
     * Filter, which checkin_sessions to fetch.
     */
    where: checkin_sessionsWhereUniqueInput
  }

  /**
   * checkin_sessions findUniqueOrThrow
   */
  export type checkin_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
    /**
     * Filter, which checkin_sessions to fetch.
     */
    where: checkin_sessionsWhereUniqueInput
  }

  /**
   * checkin_sessions findFirst
   */
  export type checkin_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
    /**
     * Filter, which checkin_sessions to fetch.
     */
    where?: checkin_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkin_sessions to fetch.
     */
    orderBy?: checkin_sessionsOrderByWithRelationInput | checkin_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checkin_sessions.
     */
    cursor?: checkin_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkin_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkin_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checkin_sessions.
     */
    distinct?: Checkin_sessionsScalarFieldEnum | Checkin_sessionsScalarFieldEnum[]
  }

  /**
   * checkin_sessions findFirstOrThrow
   */
  export type checkin_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
    /**
     * Filter, which checkin_sessions to fetch.
     */
    where?: checkin_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkin_sessions to fetch.
     */
    orderBy?: checkin_sessionsOrderByWithRelationInput | checkin_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checkin_sessions.
     */
    cursor?: checkin_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkin_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkin_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checkin_sessions.
     */
    distinct?: Checkin_sessionsScalarFieldEnum | Checkin_sessionsScalarFieldEnum[]
  }

  /**
   * checkin_sessions findMany
   */
  export type checkin_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
    /**
     * Filter, which checkin_sessions to fetch.
     */
    where?: checkin_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkin_sessions to fetch.
     */
    orderBy?: checkin_sessionsOrderByWithRelationInput | checkin_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing checkin_sessions.
     */
    cursor?: checkin_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkin_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkin_sessions.
     */
    skip?: number
    distinct?: Checkin_sessionsScalarFieldEnum | Checkin_sessionsScalarFieldEnum[]
  }

  /**
   * checkin_sessions create
   */
  export type checkin_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
    /**
     * The data needed to create a checkin_sessions.
     */
    data: XOR<checkin_sessionsCreateInput, checkin_sessionsUncheckedCreateInput>
  }

  /**
   * checkin_sessions createMany
   */
  export type checkin_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many checkin_sessions.
     */
    data: checkin_sessionsCreateManyInput | checkin_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * checkin_sessions createManyAndReturn
   */
  export type checkin_sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many checkin_sessions.
     */
    data: checkin_sessionsCreateManyInput | checkin_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * checkin_sessions update
   */
  export type checkin_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
    /**
     * The data needed to update a checkin_sessions.
     */
    data: XOR<checkin_sessionsUpdateInput, checkin_sessionsUncheckedUpdateInput>
    /**
     * Choose, which checkin_sessions to update.
     */
    where: checkin_sessionsWhereUniqueInput
  }

  /**
   * checkin_sessions updateMany
   */
  export type checkin_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update checkin_sessions.
     */
    data: XOR<checkin_sessionsUpdateManyMutationInput, checkin_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which checkin_sessions to update
     */
    where?: checkin_sessionsWhereInput
  }

  /**
   * checkin_sessions upsert
   */
  export type checkin_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
    /**
     * The filter to search for the checkin_sessions to update in case it exists.
     */
    where: checkin_sessionsWhereUniqueInput
    /**
     * In case the checkin_sessions found by the `where` argument doesn't exist, create a new checkin_sessions with this data.
     */
    create: XOR<checkin_sessionsCreateInput, checkin_sessionsUncheckedCreateInput>
    /**
     * In case the checkin_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<checkin_sessionsUpdateInput, checkin_sessionsUncheckedUpdateInput>
  }

  /**
   * checkin_sessions delete
   */
  export type checkin_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
    /**
     * Filter which checkin_sessions to delete.
     */
    where: checkin_sessionsWhereUniqueInput
  }

  /**
   * checkin_sessions deleteMany
   */
  export type checkin_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checkin_sessions to delete
     */
    where?: checkin_sessionsWhereInput
  }

  /**
   * checkin_sessions without action
   */
  export type checkin_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkin_sessions
     */
    select?: checkin_sessionsSelect<ExtArgs> | null
  }


  /**
   * Model session_billings
   */

  export type AggregateSession_billings = {
    _count: Session_billingsCountAggregateOutputType | null
    _avg: Session_billingsAvgAggregateOutputType | null
    _sum: Session_billingsSumAggregateOutputType | null
    _min: Session_billingsMinAggregateOutputType | null
    _max: Session_billingsMaxAggregateOutputType | null
  }

  export type Session_billingsAvgAggregateOutputType = {
    subtotal_amount: number | null
    tax_amount: number | null
    total_amount: number | null
    paid_amount: number | null
  }

  export type Session_billingsSumAggregateOutputType = {
    subtotal_amount: number | null
    tax_amount: number | null
    total_amount: number | null
    paid_amount: number | null
  }

  export type Session_billingsMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    session_id: string | null
    billing_number: string | null
    subtotal_amount: number | null
    tax_amount: number | null
    total_amount: number | null
    paid_amount: number | null
    status: string | null
    payment_method: string | null
    payment_date: Date | null
    due_date: Date | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Session_billingsMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    session_id: string | null
    billing_number: string | null
    subtotal_amount: number | null
    tax_amount: number | null
    total_amount: number | null
    paid_amount: number | null
    status: string | null
    payment_method: string | null
    payment_date: Date | null
    due_date: Date | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Session_billingsCountAggregateOutputType = {
    id: number
    tenant_id: number
    session_id: number
    billing_number: number
    room_charges: number
    service_charges: number
    taxes: number
    discounts: number
    subtotal_amount: number
    tax_amount: number
    total_amount: number
    paid_amount: number
    status: number
    payment_method: number
    payment_date: number
    due_date: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Session_billingsAvgAggregateInputType = {
    subtotal_amount?: true
    tax_amount?: true
    total_amount?: true
    paid_amount?: true
  }

  export type Session_billingsSumAggregateInputType = {
    subtotal_amount?: true
    tax_amount?: true
    total_amount?: true
    paid_amount?: true
  }

  export type Session_billingsMinAggregateInputType = {
    id?: true
    tenant_id?: true
    session_id?: true
    billing_number?: true
    subtotal_amount?: true
    tax_amount?: true
    total_amount?: true
    paid_amount?: true
    status?: true
    payment_method?: true
    payment_date?: true
    due_date?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Session_billingsMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    session_id?: true
    billing_number?: true
    subtotal_amount?: true
    tax_amount?: true
    total_amount?: true
    paid_amount?: true
    status?: true
    payment_method?: true
    payment_date?: true
    due_date?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type Session_billingsCountAggregateInputType = {
    id?: true
    tenant_id?: true
    session_id?: true
    billing_number?: true
    room_charges?: true
    service_charges?: true
    taxes?: true
    discounts?: true
    subtotal_amount?: true
    tax_amount?: true
    total_amount?: true
    paid_amount?: true
    status?: true
    payment_method?: true
    payment_date?: true
    due_date?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Session_billingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_billings to aggregate.
     */
    where?: session_billingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_billings to fetch.
     */
    orderBy?: session_billingsOrderByWithRelationInput | session_billingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: session_billingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned session_billings
    **/
    _count?: true | Session_billingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Session_billingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Session_billingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Session_billingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Session_billingsMaxAggregateInputType
  }

  export type GetSession_billingsAggregateType<T extends Session_billingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSession_billings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession_billings[P]>
      : GetScalarType<T[P], AggregateSession_billings[P]>
  }




  export type session_billingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_billingsWhereInput
    orderBy?: session_billingsOrderByWithAggregationInput | session_billingsOrderByWithAggregationInput[]
    by: Session_billingsScalarFieldEnum[] | Session_billingsScalarFieldEnum
    having?: session_billingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Session_billingsCountAggregateInputType | true
    _avg?: Session_billingsAvgAggregateInputType
    _sum?: Session_billingsSumAggregateInputType
    _min?: Session_billingsMinAggregateInputType
    _max?: Session_billingsMaxAggregateInputType
  }

  export type Session_billingsGroupByOutputType = {
    id: string
    tenant_id: string
    session_id: string
    billing_number: string
    room_charges: JsonValue
    service_charges: JsonValue
    taxes: JsonValue
    discounts: JsonValue
    subtotal_amount: number
    tax_amount: number
    total_amount: number
    paid_amount: number
    status: string
    payment_method: string | null
    payment_date: Date | null
    due_date: Date
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: Session_billingsCountAggregateOutputType | null
    _avg: Session_billingsAvgAggregateOutputType | null
    _sum: Session_billingsSumAggregateOutputType | null
    _min: Session_billingsMinAggregateOutputType | null
    _max: Session_billingsMaxAggregateOutputType | null
  }

  type GetSession_billingsGroupByPayload<T extends session_billingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Session_billingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Session_billingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Session_billingsGroupByOutputType[P]>
            : GetScalarType<T[P], Session_billingsGroupByOutputType[P]>
        }
      >
    >


  export type session_billingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    session_id?: boolean
    billing_number?: boolean
    room_charges?: boolean
    service_charges?: boolean
    taxes?: boolean
    discounts?: boolean
    subtotal_amount?: boolean
    tax_amount?: boolean
    total_amount?: boolean
    paid_amount?: boolean
    status?: boolean
    payment_method?: boolean
    payment_date?: boolean
    due_date?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["session_billings"]>

  export type session_billingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    session_id?: boolean
    billing_number?: boolean
    room_charges?: boolean
    service_charges?: boolean
    taxes?: boolean
    discounts?: boolean
    subtotal_amount?: boolean
    tax_amount?: boolean
    total_amount?: boolean
    paid_amount?: boolean
    status?: boolean
    payment_method?: boolean
    payment_date?: boolean
    due_date?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["session_billings"]>

  export type session_billingsSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    session_id?: boolean
    billing_number?: boolean
    room_charges?: boolean
    service_charges?: boolean
    taxes?: boolean
    discounts?: boolean
    subtotal_amount?: boolean
    tax_amount?: boolean
    total_amount?: boolean
    paid_amount?: boolean
    status?: boolean
    payment_method?: boolean
    payment_date?: boolean
    due_date?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $session_billingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session_billings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      session_id: string
      billing_number: string
      room_charges: Prisma.JsonValue
      service_charges: Prisma.JsonValue
      taxes: Prisma.JsonValue
      discounts: Prisma.JsonValue
      subtotal_amount: number
      tax_amount: number
      total_amount: number
      paid_amount: number
      status: string
      payment_method: string | null
      payment_date: Date | null
      due_date: Date
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["session_billings"]>
    composites: {}
  }

  type session_billingsGetPayload<S extends boolean | null | undefined | session_billingsDefaultArgs> = $Result.GetResult<Prisma.$session_billingsPayload, S>

  type session_billingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<session_billingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Session_billingsCountAggregateInputType | true
    }

  export interface session_billingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session_billings'], meta: { name: 'session_billings' } }
    /**
     * Find zero or one Session_billings that matches the filter.
     * @param {session_billingsFindUniqueArgs} args - Arguments to find a Session_billings
     * @example
     * // Get one Session_billings
     * const session_billings = await prisma.session_billings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends session_billingsFindUniqueArgs>(args: SelectSubset<T, session_billingsFindUniqueArgs<ExtArgs>>): Prisma__session_billingsClient<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session_billings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {session_billingsFindUniqueOrThrowArgs} args - Arguments to find a Session_billings
     * @example
     * // Get one Session_billings
     * const session_billings = await prisma.session_billings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends session_billingsFindUniqueOrThrowArgs>(args: SelectSubset<T, session_billingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__session_billingsClient<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session_billings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_billingsFindFirstArgs} args - Arguments to find a Session_billings
     * @example
     * // Get one Session_billings
     * const session_billings = await prisma.session_billings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends session_billingsFindFirstArgs>(args?: SelectSubset<T, session_billingsFindFirstArgs<ExtArgs>>): Prisma__session_billingsClient<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session_billings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_billingsFindFirstOrThrowArgs} args - Arguments to find a Session_billings
     * @example
     * // Get one Session_billings
     * const session_billings = await prisma.session_billings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends session_billingsFindFirstOrThrowArgs>(args?: SelectSubset<T, session_billingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__session_billingsClient<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Session_billings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_billingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Session_billings
     * const session_billings = await prisma.session_billings.findMany()
     * 
     * // Get first 10 Session_billings
     * const session_billings = await prisma.session_billings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const session_billingsWithIdOnly = await prisma.session_billings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends session_billingsFindManyArgs>(args?: SelectSubset<T, session_billingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session_billings.
     * @param {session_billingsCreateArgs} args - Arguments to create a Session_billings.
     * @example
     * // Create one Session_billings
     * const Session_billings = await prisma.session_billings.create({
     *   data: {
     *     // ... data to create a Session_billings
     *   }
     * })
     * 
     */
    create<T extends session_billingsCreateArgs>(args: SelectSubset<T, session_billingsCreateArgs<ExtArgs>>): Prisma__session_billingsClient<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Session_billings.
     * @param {session_billingsCreateManyArgs} args - Arguments to create many Session_billings.
     * @example
     * // Create many Session_billings
     * const session_billings = await prisma.session_billings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends session_billingsCreateManyArgs>(args?: SelectSubset<T, session_billingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Session_billings and returns the data saved in the database.
     * @param {session_billingsCreateManyAndReturnArgs} args - Arguments to create many Session_billings.
     * @example
     * // Create many Session_billings
     * const session_billings = await prisma.session_billings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Session_billings and only return the `id`
     * const session_billingsWithIdOnly = await prisma.session_billings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends session_billingsCreateManyAndReturnArgs>(args?: SelectSubset<T, session_billingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session_billings.
     * @param {session_billingsDeleteArgs} args - Arguments to delete one Session_billings.
     * @example
     * // Delete one Session_billings
     * const Session_billings = await prisma.session_billings.delete({
     *   where: {
     *     // ... filter to delete one Session_billings
     *   }
     * })
     * 
     */
    delete<T extends session_billingsDeleteArgs>(args: SelectSubset<T, session_billingsDeleteArgs<ExtArgs>>): Prisma__session_billingsClient<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session_billings.
     * @param {session_billingsUpdateArgs} args - Arguments to update one Session_billings.
     * @example
     * // Update one Session_billings
     * const session_billings = await prisma.session_billings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends session_billingsUpdateArgs>(args: SelectSubset<T, session_billingsUpdateArgs<ExtArgs>>): Prisma__session_billingsClient<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Session_billings.
     * @param {session_billingsDeleteManyArgs} args - Arguments to filter Session_billings to delete.
     * @example
     * // Delete a few Session_billings
     * const { count } = await prisma.session_billings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends session_billingsDeleteManyArgs>(args?: SelectSubset<T, session_billingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_billingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Session_billings
     * const session_billings = await prisma.session_billings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends session_billingsUpdateManyArgs>(args: SelectSubset<T, session_billingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session_billings.
     * @param {session_billingsUpsertArgs} args - Arguments to update or create a Session_billings.
     * @example
     * // Update or create a Session_billings
     * const session_billings = await prisma.session_billings.upsert({
     *   create: {
     *     // ... data to create a Session_billings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session_billings we want to update
     *   }
     * })
     */
    upsert<T extends session_billingsUpsertArgs>(args: SelectSubset<T, session_billingsUpsertArgs<ExtArgs>>): Prisma__session_billingsClient<$Result.GetResult<Prisma.$session_billingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Session_billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_billingsCountArgs} args - Arguments to filter Session_billings to count.
     * @example
     * // Count the number of Session_billings
     * const count = await prisma.session_billings.count({
     *   where: {
     *     // ... the filter for the Session_billings we want to count
     *   }
     * })
    **/
    count<T extends session_billingsCountArgs>(
      args?: Subset<T, session_billingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Session_billingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session_billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Session_billingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Session_billingsAggregateArgs>(args: Subset<T, Session_billingsAggregateArgs>): Prisma.PrismaPromise<GetSession_billingsAggregateType<T>>

    /**
     * Group by Session_billings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_billingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends session_billingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: session_billingsGroupByArgs['orderBy'] }
        : { orderBy?: session_billingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, session_billingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSession_billingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session_billings model
   */
  readonly fields: session_billingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session_billings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__session_billingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session_billings model
   */ 
  interface session_billingsFieldRefs {
    readonly id: FieldRef<"session_billings", 'String'>
    readonly tenant_id: FieldRef<"session_billings", 'String'>
    readonly session_id: FieldRef<"session_billings", 'String'>
    readonly billing_number: FieldRef<"session_billings", 'String'>
    readonly room_charges: FieldRef<"session_billings", 'Json'>
    readonly service_charges: FieldRef<"session_billings", 'Json'>
    readonly taxes: FieldRef<"session_billings", 'Json'>
    readonly discounts: FieldRef<"session_billings", 'Json'>
    readonly subtotal_amount: FieldRef<"session_billings", 'Int'>
    readonly tax_amount: FieldRef<"session_billings", 'Int'>
    readonly total_amount: FieldRef<"session_billings", 'Int'>
    readonly paid_amount: FieldRef<"session_billings", 'Int'>
    readonly status: FieldRef<"session_billings", 'String'>
    readonly payment_method: FieldRef<"session_billings", 'String'>
    readonly payment_date: FieldRef<"session_billings", 'DateTime'>
    readonly due_date: FieldRef<"session_billings", 'DateTime'>
    readonly notes: FieldRef<"session_billings", 'String'>
    readonly created_at: FieldRef<"session_billings", 'DateTime'>
    readonly updated_at: FieldRef<"session_billings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * session_billings findUnique
   */
  export type session_billingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
    /**
     * Filter, which session_billings to fetch.
     */
    where: session_billingsWhereUniqueInput
  }

  /**
   * session_billings findUniqueOrThrow
   */
  export type session_billingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
    /**
     * Filter, which session_billings to fetch.
     */
    where: session_billingsWhereUniqueInput
  }

  /**
   * session_billings findFirst
   */
  export type session_billingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
    /**
     * Filter, which session_billings to fetch.
     */
    where?: session_billingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_billings to fetch.
     */
    orderBy?: session_billingsOrderByWithRelationInput | session_billingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_billings.
     */
    cursor?: session_billingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_billings.
     */
    distinct?: Session_billingsScalarFieldEnum | Session_billingsScalarFieldEnum[]
  }

  /**
   * session_billings findFirstOrThrow
   */
  export type session_billingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
    /**
     * Filter, which session_billings to fetch.
     */
    where?: session_billingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_billings to fetch.
     */
    orderBy?: session_billingsOrderByWithRelationInput | session_billingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_billings.
     */
    cursor?: session_billingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_billings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_billings.
     */
    distinct?: Session_billingsScalarFieldEnum | Session_billingsScalarFieldEnum[]
  }

  /**
   * session_billings findMany
   */
  export type session_billingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
    /**
     * Filter, which session_billings to fetch.
     */
    where?: session_billingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_billings to fetch.
     */
    orderBy?: session_billingsOrderByWithRelationInput | session_billingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing session_billings.
     */
    cursor?: session_billingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_billings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_billings.
     */
    skip?: number
    distinct?: Session_billingsScalarFieldEnum | Session_billingsScalarFieldEnum[]
  }

  /**
   * session_billings create
   */
  export type session_billingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
    /**
     * The data needed to create a session_billings.
     */
    data: XOR<session_billingsCreateInput, session_billingsUncheckedCreateInput>
  }

  /**
   * session_billings createMany
   */
  export type session_billingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many session_billings.
     */
    data: session_billingsCreateManyInput | session_billingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session_billings createManyAndReturn
   */
  export type session_billingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many session_billings.
     */
    data: session_billingsCreateManyInput | session_billingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session_billings update
   */
  export type session_billingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
    /**
     * The data needed to update a session_billings.
     */
    data: XOR<session_billingsUpdateInput, session_billingsUncheckedUpdateInput>
    /**
     * Choose, which session_billings to update.
     */
    where: session_billingsWhereUniqueInput
  }

  /**
   * session_billings updateMany
   */
  export type session_billingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update session_billings.
     */
    data: XOR<session_billingsUpdateManyMutationInput, session_billingsUncheckedUpdateManyInput>
    /**
     * Filter which session_billings to update
     */
    where?: session_billingsWhereInput
  }

  /**
   * session_billings upsert
   */
  export type session_billingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
    /**
     * The filter to search for the session_billings to update in case it exists.
     */
    where: session_billingsWhereUniqueInput
    /**
     * In case the session_billings found by the `where` argument doesn't exist, create a new session_billings with this data.
     */
    create: XOR<session_billingsCreateInput, session_billingsUncheckedCreateInput>
    /**
     * In case the session_billings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<session_billingsUpdateInput, session_billingsUncheckedUpdateInput>
  }

  /**
   * session_billings delete
   */
  export type session_billingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
    /**
     * Filter which session_billings to delete.
     */
    where: session_billingsWhereUniqueInput
  }

  /**
   * session_billings deleteMany
   */
  export type session_billingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_billings to delete
     */
    where?: session_billingsWhereInput
  }

  /**
   * session_billings without action
   */
  export type session_billingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_billings
     */
    select?: session_billingsSelect<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    floor: number | null
    capacity: number | null
  }

  export type RoomSumAggregateOutputType = {
    floor: number | null
    capacity: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    roomNumber: string | null
    roomType: string | null
    floor: number | null
    status: string | null
    capacity: number | null
    notes: string | null
    lastCleaned: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    roomNumber: string | null
    roomType: string | null
    floor: number | null
    status: string | null
    capacity: number | null
    notes: string | null
    lastCleaned: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    tenantId: number
    roomNumber: number
    roomType: number
    floor: number
    status: number
    capacity: number
    amenities: number
    notes: number
    lastCleaned: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    floor?: true
    capacity?: true
  }

  export type RoomSumAggregateInputType = {
    floor?: true
    capacity?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    tenantId?: true
    roomNumber?: true
    roomType?: true
    floor?: true
    status?: true
    capacity?: true
    notes?: true
    lastCleaned?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    tenantId?: true
    roomNumber?: true
    roomType?: true
    floor?: true
    status?: true
    capacity?: true
    notes?: true
    lastCleaned?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    tenantId?: true
    roomNumber?: true
    roomType?: true
    floor?: true
    status?: true
    capacity?: true
    amenities?: true
    notes?: true
    lastCleaned?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    tenantId: string
    roomNumber: string
    roomType: string
    floor: number | null
    status: string
    capacity: number
    amenities: JsonValue | null
    notes: string | null
    lastCleaned: Date | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomNumber?: boolean
    roomType?: boolean
    floor?: boolean
    status?: boolean
    capacity?: boolean
    amenities?: boolean
    notes?: boolean
    lastCleaned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomNumber?: boolean
    roomType?: boolean
    floor?: boolean
    status?: boolean
    capacity?: boolean
    amenities?: boolean
    notes?: boolean
    lastCleaned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    tenantId?: boolean
    roomNumber?: boolean
    roomType?: boolean
    floor?: boolean
    status?: boolean
    capacity?: boolean
    amenities?: boolean
    notes?: boolean
    lastCleaned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }


  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      roomNumber: string
      roomType: string
      floor: number | null
      status: string
      capacity: number
      amenities: Prisma.JsonValue | null
      notes: string | null
      lastCleaned: Date | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly tenantId: FieldRef<"Room", 'String'>
    readonly roomNumber: FieldRef<"Room", 'String'>
    readonly roomType: FieldRef<"Room", 'String'>
    readonly floor: FieldRef<"Room", 'Int'>
    readonly status: FieldRef<"Room", 'String'>
    readonly capacity: FieldRef<"Room", 'Int'>
    readonly amenities: FieldRef<"Room", 'Json'>
    readonly notes: FieldRef<"Room", 'String'>
    readonly lastCleaned: FieldRef<"Room", 'DateTime'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
    readonly isDeleted: FieldRef<"Room", 'Boolean'>
    readonly deletedAt: FieldRef<"Room", 'DateTime'>
    readonly deletedBy: FieldRef<"Room", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    paymentId: string | null
    type: string | null
    amount: number | null
    taxAmount: number | null
    totalAmount: number | null
    status: string | null
    description: string | null
    reference: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    paymentId: string | null
    type: string | null
    amount: number | null
    taxAmount: number | null
    totalAmount: number | null
    status: string | null
    description: string | null
    reference: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    tenantId: number
    invoiceId: number
    paymentId: number
    type: number
    amount: number
    taxAmount: number
    totalAmount: number
    status: number
    description: number
    reference: number
    metadata: number
    createdAt: number
    updatedAt: number
    createdBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    paymentId?: true
    type?: true
    amount?: true
    taxAmount?: true
    totalAmount?: true
    status?: true
    description?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    paymentId?: true
    type?: true
    amount?: true
    taxAmount?: true
    totalAmount?: true
    status?: true
    description?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    paymentId?: true
    type?: true
    amount?: true
    taxAmount?: true
    totalAmount?: true
    status?: true
    description?: true
    reference?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    tenantId: string
    invoiceId: string | null
    paymentId: string | null
    type: string
    amount: number
    taxAmount: number
    totalAmount: number
    status: string
    description: string | null
    reference: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    paymentId?: boolean
    type?: boolean
    amount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    description?: boolean
    reference?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    payment?: boolean | Transaction$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    paymentId?: boolean
    type?: boolean
    amount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    description?: boolean
    reference?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    paymentId?: boolean
    type?: boolean
    amount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    description?: boolean
    reference?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    payment?: boolean | Transaction$paymentArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      invoiceId: string | null
      paymentId: string | null
      type: string
      amount: number
      taxAmount: number
      totalAmount: number
      status: string
      description: string | null
      reference: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends Transaction$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payment<T extends Transaction$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly tenantId: FieldRef<"Transaction", 'String'>
    readonly invoiceId: FieldRef<"Transaction", 'String'>
    readonly paymentId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Int'>
    readonly taxAmount: FieldRef<"Transaction", 'Int'>
    readonly totalAmount: FieldRef<"Transaction", 'Int'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly reference: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly createdBy: FieldRef<"Transaction", 'String'>
    readonly isDeleted: FieldRef<"Transaction", 'Boolean'>
    readonly deletedAt: FieldRef<"Transaction", 'DateTime'>
    readonly deletedBy: FieldRef<"Transaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.invoice
   */
  export type Transaction$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Transaction.payment
   */
  export type Transaction$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceNumber: string | null
    customerId: string | null
    customerName: string | null
    customerEmail: string | null
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
    status: string | null
    dueDate: Date | null
    issuedAt: Date | null
    paidAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceNumber: string | null
    customerId: string | null
    customerName: string | null
    customerEmail: string | null
    subtotal: number | null
    taxAmount: number | null
    totalAmount: number | null
    status: string | null
    dueDate: Date | null
    issuedAt: Date | null
    paidAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    invoiceNumber: number
    customerId: number
    customerName: number
    customerEmail: number
    billingAddress: number
    items: number
    subtotal: number
    taxAmount: number
    totalAmount: number
    status: number
    dueDate: number
    issuedAt: number
    paidAt: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    createdBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    customerId?: true
    customerName?: true
    customerEmail?: true
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
    status?: true
    dueDate?: true
    issuedAt?: true
    paidAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    customerId?: true
    customerName?: true
    customerEmail?: true
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
    status?: true
    dueDate?: true
    issuedAt?: true
    paidAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    customerId?: true
    customerName?: true
    customerEmail?: true
    billingAddress?: true
    items?: true
    subtotal?: true
    taxAmount?: true
    totalAmount?: true
    status?: true
    dueDate?: true
    issuedAt?: true
    paidAt?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    tenantId: string
    invoiceNumber: string
    customerId: string | null
    customerName: string
    customerEmail: string | null
    billingAddress: JsonValue | null
    items: JsonValue
    subtotal: number
    taxAmount: number
    totalAmount: number
    status: string
    dueDate: Date | null
    issuedAt: Date | null
    paidAt: Date | null
    notes: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    billingAddress?: boolean
    items?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    issuedAt?: boolean
    paidAt?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    billingAddress?: boolean
    items?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    issuedAt?: boolean
    paidAt?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    customerId?: boolean
    customerName?: boolean
    customerEmail?: boolean
    billingAddress?: boolean
    items?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    status?: boolean
    dueDate?: boolean
    issuedAt?: boolean
    paidAt?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      invoiceNumber: string
      customerId: string | null
      customerName: string
      customerEmail: string | null
      billingAddress: Prisma.JsonValue | null
      items: Prisma.JsonValue
      subtotal: number
      taxAmount: number
      totalAmount: number
      status: string
      dueDate: Date | null
      issuedAt: Date | null
      paidAt: Date | null
      notes: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Invoice$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly customerId: FieldRef<"Invoice", 'String'>
    readonly customerName: FieldRef<"Invoice", 'String'>
    readonly customerEmail: FieldRef<"Invoice", 'String'>
    readonly billingAddress: FieldRef<"Invoice", 'Json'>
    readonly items: FieldRef<"Invoice", 'Json'>
    readonly subtotal: FieldRef<"Invoice", 'Int'>
    readonly taxAmount: FieldRef<"Invoice", 'Int'>
    readonly totalAmount: FieldRef<"Invoice", 'Int'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly issuedAt: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly metadata: FieldRef<"Invoice", 'Json'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly createdBy: FieldRef<"Invoice", 'String'>
    readonly isDeleted: FieldRef<"Invoice", 'Boolean'>
    readonly deletedAt: FieldRef<"Invoice", 'DateTime'>
    readonly deletedBy: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.transactions
   */
  export type Invoice$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    transactionId: string | null
    invoiceId: string | null
    paymentMethod: string | null
    amount: number | null
    status: string | null
    reference: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    transactionId: string | null
    invoiceId: string | null
    paymentMethod: string | null
    amount: number | null
    status: string | null
    reference: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    tenantId: number
    transactionId: number
    invoiceId: number
    paymentMethod: number
    amount: number
    status: number
    reference: number
    metadata: number
    processedAt: number
    createdAt: number
    updatedAt: number
    createdBy: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    tenantId?: true
    transactionId?: true
    invoiceId?: true
    paymentMethod?: true
    amount?: true
    status?: true
    reference?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    transactionId?: true
    invoiceId?: true
    paymentMethod?: true
    amount?: true
    status?: true
    reference?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    tenantId?: true
    transactionId?: true
    invoiceId?: true
    paymentMethod?: true
    amount?: true
    status?: true
    reference?: true
    metadata?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    tenantId: string
    transactionId: string | null
    invoiceId: string | null
    paymentMethod: string
    amount: number
    status: string
    reference: string | null
    metadata: JsonValue | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    transactionId?: boolean
    invoiceId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    status?: boolean
    reference?: boolean
    metadata?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    transactionId?: boolean
    invoiceId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    status?: boolean
    reference?: boolean
    metadata?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    transactionId?: boolean
    invoiceId?: boolean
    paymentMethod?: boolean
    amount?: boolean
    status?: boolean
    reference?: boolean
    metadata?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      transactionId: string | null
      invoiceId: string | null
      paymentMethod: string
      amount: number
      status: string
      reference: string | null
      metadata: Prisma.JsonValue | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transaction<T extends Payment$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Payment$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly tenantId: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdBy: FieldRef<"Payment", 'String'>
    readonly isDeleted: FieldRef<"Payment", 'Boolean'>
    readonly deletedAt: FieldRef<"Payment", 'DateTime'>
    readonly deletedBy: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Payment.transaction
   */
  export type Payment$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DatabaseChangeLogScalarFieldEnum: {
    id: 'id',
    changeType: 'changeType',
    description: 'description',
    details: 'details',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type DatabaseChangeLogScalarFieldEnum = (typeof DatabaseChangeLogScalarFieldEnum)[keyof typeof DatabaseChangeLogScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    roomId: 'roomId',
    placeId: 'placeId',
    status: 'status',
    items: 'items',
    total: 'total',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paidAt: 'paidAt',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    uuid: 'uuid',
    sessionId: 'sessionId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    orderId: 'orderId',
    menuItemId: 'menuItemId',
    name: 'name',
    price: 'price',
    quantity: 'quantity',
    status: 'status',
    notes: 'notes',
    deliveredAt: 'deliveredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const SystemPlanRestrictionsScalarFieldEnum: {
    id: 'id',
    systemType: 'systemType',
    businessType: 'businessType',
    planType: 'planType',
    planCategory: 'planCategory',
    monthlyPrice: 'monthlyPrice',
    maxDevices: 'maxDevices',
    additionalDeviceCost: 'additionalDeviceCost',
    roomTerminalCost: 'roomTerminalCost',
    frontDeskCost: 'frontDeskCost',
    kitchenCost: 'kitchenCost',
    barCost: 'barCost',
    housekeepingCost: 'housekeepingCost',
    managerCost: 'managerCost',
    commonAreaCost: 'commonAreaCost',
    enableAiConcierge: 'enableAiConcierge',
    enableMultilingual: 'enableMultilingual',
    enableLayoutEditor: 'enableLayoutEditor',
    enableFacilityGuide: 'enableFacilityGuide',
    enableAiBusinessSupport: 'enableAiBusinessSupport',
    maxMonthlyOrders: 'maxMonthlyOrders',
    maxMonthlyAiRequests: 'maxMonthlyAiRequests',
    maxStorageGB: 'maxStorageGB',
    multilingualUpgradePrice: 'multilingualUpgradePrice',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type SystemPlanRestrictionsScalarFieldEnum = (typeof SystemPlanRestrictionsScalarFieldEnum)[keyof typeof SystemPlanRestrictionsScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    contactEmail: 'contactEmail',
    createdAt: 'createdAt',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    features: 'features',
    is_deleted: 'is_deleted',
    planType: 'planType',
    settings: 'settings',
    status: 'status'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantSystemPlanScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    systemType: 'systemType',
    planId: 'planId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    monthlyPrice: 'monthlyPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type TenantSystemPlanScalarFieldEnum = (typeof TenantSystemPlanScalarFieldEnum)[keyof typeof TenantSystemPlanScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    display_name: 'display_name',
    password_hash: 'password_hash',
    admin_level: 'admin_level',
    accessible_group_ids: 'accessible_group_ids',
    accessible_chain_ids: 'accessible_chain_ids',
    accessible_tenant_ids: 'accessible_tenant_ids',
    last_login_at: 'last_login_at',
    login_attempts: 'login_attempts',
    locked_until: 'locked_until',
    totp_secret: 'totp_secret',
    totp_enabled: 'totp_enabled',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by',
    is_active: 'is_active',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const Admin_logScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    action: 'action',
    target_type: 'target_type',
    target_id: 'target_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    success: 'success',
    error_message: 'error_message',
    created_at: 'created_at',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Admin_logScalarFieldEnum = (typeof Admin_logScalarFieldEnum)[keyof typeof Admin_logScalarFieldEnum]


  export const Campaign_categoriesScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    code: 'code',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Campaign_categoriesScalarFieldEnum = (typeof Campaign_categoriesScalarFieldEnum)[keyof typeof Campaign_categoriesScalarFieldEnum]


  export const Campaign_category_relationsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Campaign_category_relationsScalarFieldEnum = (typeof Campaign_category_relationsScalarFieldEnum)[keyof typeof Campaign_category_relationsScalarFieldEnum]


  export const Campaign_itemsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    itemId: 'itemId',
    itemType: 'itemType',
    priority: 'priority',
    createdAt: 'createdAt',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Campaign_itemsScalarFieldEnum = (typeof Campaign_itemsScalarFieldEnum)[keyof typeof Campaign_itemsScalarFieldEnum]


  export const Campaign_translationsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    locale: 'locale',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    languageCode: 'languageCode',
    name: 'name',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Campaign_translationsScalarFieldEnum = (typeof Campaign_translationsScalarFieldEnum)[keyof typeof Campaign_translationsScalarFieldEnum]


  export const Campaign_usage_logsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    userId: 'userId',
    deviceId: 'deviceId',
    action: 'action',
    createdAt: 'createdAt',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Campaign_usage_logsScalarFieldEnum = (typeof Campaign_usage_logsScalarFieldEnum)[keyof typeof Campaign_usage_logsScalarFieldEnum]


  export const CampaignsScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    code: 'code',
    status: 'status',
    displayType: 'displayType',
    startDate: 'startDate',
    endDate: 'endDate',
    priority: 'priority',
    ctaType: 'ctaType',
    ctaAction: 'ctaAction',
    ctaLabel: 'ctaLabel',
    discountType: 'discountType',
    discountValue: 'discountValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    dayRestrictions: 'dayRestrictions',
    description: 'description',
    displayPriority: 'displayPriority',
    maxUsageCount: 'maxUsageCount',
    name: 'name',
    timeRestrictions: 'timeRestrictions',
    welcomeSettings: 'welcomeSettings',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type CampaignsScalarFieldEnum = (typeof CampaignsScalarFieldEnum)[keyof typeof CampaignsScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    birth_date: 'birth_date',
    member_id: 'member_id',
    rank_id: 'rank_id',
    total_points: 'total_points',
    total_stays: 'total_stays',
    pms_updatable_fields: 'pms_updatable_fields',
    origin_system: 'origin_system',
    synced_at: 'synced_at',
    updated_by_system: 'updated_by_system',
    preferences: 'preferences',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    is_deleted: 'is_deleted',
    deleted_by: 'deleted_by'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const Device_roomsScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    roomId: 'roomId',
    roomName: 'roomName',
    deviceId: 'deviceId',
    deviceType: 'deviceType',
    placeId: 'placeId',
    status: 'status',
    ipAddress: 'ipAddress',
    macAddress: 'macAddress',
    lastUsedAt: 'lastUsedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by'
  };

  export type Device_roomsScalarFieldEnum = (typeof Device_roomsScalarFieldEnum)[keyof typeof Device_roomsScalarFieldEnum]


  export const Device_video_cachesScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    videoIds: 'videoIds',
    lastShownAt: 'lastShownAt',
    updatedAt: 'updatedAt',
    lastViewedAt: 'lastViewedAt',
    userId: 'userId',
    viewed: 'viewed',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Device_video_cachesScalarFieldEnum = (typeof Device_video_cachesScalarFieldEnum)[keyof typeof Device_video_cachesScalarFieldEnum]


  export const Notification_templatesScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    type: 'type',
    code: 'code',
    subject: 'subject',
    content: 'content',
    variables: 'variables',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    body: 'body',
    html: 'html',
    locale: 'locale',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Notification_templatesScalarFieldEnum = (typeof Notification_templatesScalarFieldEnum)[keyof typeof Notification_templatesScalarFieldEnum]


  export const Page_historiesScalarFieldEnum: {
    Id: 'Id',
    PageId: 'PageId',
    Html: 'Html',
    Css: 'Css',
    Content: 'Content',
    Template: 'Template',
    Version: 'Version',
    CreatedAt: 'CreatedAt',
    CreatedBy: 'CreatedBy',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Page_historiesScalarFieldEnum = (typeof Page_historiesScalarFieldEnum)[keyof typeof Page_historiesScalarFieldEnum]


  export const PagesScalarFieldEnum: {
    Id: 'Id',
    TenantId: 'TenantId',
    Slug: 'Slug',
    Title: 'Title',
    Html: 'Html',
    Css: 'Css',
    Content: 'Content',
    Template: 'Template',
    IsPublished: 'IsPublished',
    PublishedAt: 'PublishedAt',
    Version: 'Version',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type PagesScalarFieldEnum = (typeof PagesScalarFieldEnum)[keyof typeof PagesScalarFieldEnum]


  export const ReservationsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    customer_id: 'customer_id',
    guest_name: 'guest_name',
    guest_phone: 'guest_phone',
    guest_email: 'guest_email',
    checkin_date: 'checkin_date',
    checkout_date: 'checkout_date',
    adult_count: 'adult_count',
    child_count: 'child_count',
    room_type: 'room_type',
    room_number: 'room_number',
    total_amount: 'total_amount',
    deposit_amount: 'deposit_amount',
    status: 'status',
    origin: 'origin',
    ota_id: 'ota_id',
    confirmation_number: 'confirmation_number',
    special_requests: 'special_requests',
    internal_notes: 'internal_notes',
    origin_system: 'origin_system',
    synced_at: 'synced_at',
    updated_by_system: 'updated_by_system',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    is_deleted: 'is_deleted',
    deleted_by: 'deleted_by'
  };

  export type ReservationsScalarFieldEnum = (typeof ReservationsScalarFieldEnum)[keyof typeof ReservationsScalarFieldEnum]


  export const Response_node_translationsScalarFieldEnum: {
    id: 'id',
    nodeId: 'nodeId',
    locale: 'locale',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    answer: 'answer',
    language: 'language',
    title: 'title',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Response_node_translationsScalarFieldEnum = (typeof Response_node_translationsScalarFieldEnum)[keyof typeof Response_node_translationsScalarFieldEnum]


  export const Response_nodesScalarFieldEnum: {
    id: 'id',
    treeId: 'treeId',
    nodeType: 'nodeType',
    content: 'content',
    metadata: 'metadata',
    isRoot: 'isRoot',
    parentId: 'parentId',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    answer: 'answer',
    description: 'description',
    icon: 'icon',
    order: 'order',
    title: 'title',
    type: 'type'
  };

  export type Response_nodesScalarFieldEnum = (typeof Response_nodesScalarFieldEnum)[keyof typeof Response_nodesScalarFieldEnum]


  export const Response_tree_historyScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    nodeId: 'nodeId',
    response: 'response',
    metadata: 'metadata',
    createdAt: 'createdAt',
    action: 'action',
    timestamp: 'timestamp'
  };

  export type Response_tree_historyScalarFieldEnum = (typeof Response_tree_historyScalarFieldEnum)[keyof typeof Response_tree_historyScalarFieldEnum]


  export const Response_tree_mobile_linksScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    code: 'code',
    qrCodeData: 'qrCodeData',
    isActive: 'isActive',
    connectionId: 'connectionId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    connectedAt: 'connectedAt',
    deviceId: 'deviceId'
  };

  export type Response_tree_mobile_linksScalarFieldEnum = (typeof Response_tree_mobile_linksScalarFieldEnum)[keyof typeof Response_tree_mobile_linksScalarFieldEnum]


  export const Response_tree_sessionsScalarFieldEnum: {
    id: 'id',
    treeId: 'treeId',
    userId: 'userId',
    deviceId: 'deviceId',
    currentNodeId: 'currentNodeId',
    metadata: 'metadata',
    isComplete: 'isComplete',
    startedAt: 'startedAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    endedAt: 'endedAt',
    interfaceType: 'interfaceType',
    language: 'language',
    lastActivityAt: 'lastActivityAt',
    roomId: 'roomId',
    sessionId: 'sessionId'
  };

  export type Response_tree_sessionsScalarFieldEnum = (typeof Response_tree_sessionsScalarFieldEnum)[keyof typeof Response_tree_sessionsScalarFieldEnum]


  export const Response_tree_versionsScalarFieldEnum: {
    id: 'id',
    treeId: 'treeId',
    version: 'version',
    snapshot: 'snapshot',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    data: 'data'
  };

  export type Response_tree_versionsScalarFieldEnum = (typeof Response_tree_versionsScalarFieldEnum)[keyof typeof Response_tree_versionsScalarFieldEnum]


  export const Response_treesScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    isPublished: 'isPublished',
    publishedAt: 'publishedAt',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type Response_treesScalarFieldEnum = (typeof Response_treesScalarFieldEnum)[keyof typeof Response_treesScalarFieldEnum]


  export const Room_gradesScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    code: 'code',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Room_gradesScalarFieldEnum = (typeof Room_gradesScalarFieldEnum)[keyof typeof Room_gradesScalarFieldEnum]


  export const Schema_versionScalarFieldEnum: {
    version: 'version',
    description: 'description',
    rollback_sql: 'rollback_sql',
    applied_at: 'applied_at',
    applied_by: 'applied_by'
  };

  export type Schema_versionScalarFieldEnum = (typeof Schema_versionScalarFieldEnum)[keyof typeof Schema_versionScalarFieldEnum]


  export const Service_plan_restrictionsScalarFieldEnum: {
    id: 'id',
    service_type: 'service_type',
    plan_type: 'plan_type',
    plan_category: 'plan_category',
    max_users: 'max_users',
    max_devices: 'max_devices',
    max_monthly_orders: 'max_monthly_orders',
    enable_ai_concierge: 'enable_ai_concierge',
    enable_multilingual: 'enable_multilingual',
    max_rooms: 'max_rooms',
    enable_revenue_management: 'enable_revenue_management',
    max_monthly_ai_requests: 'max_monthly_ai_requests',
    enable_ai_crm: 'enable_ai_crm',
    monthly_price: 'monthly_price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Service_plan_restrictionsScalarFieldEnum = (typeof Service_plan_restrictionsScalarFieldEnum)[keyof typeof Service_plan_restrictionsScalarFieldEnum]


  export const Service_usage_statisticsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    service_type: 'service_type',
    month: 'month',
    active_users_count: 'active_users_count',
    active_devices_count: 'active_devices_count',
    usage_data: 'usage_data',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Service_usage_statisticsScalarFieldEnum = (typeof Service_usage_statisticsScalarFieldEnum)[keyof typeof Service_usage_statisticsScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    email: 'email',
    name: 'name',
    role: 'role',
    department: 'department',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    failed_login_count: 'failed_login_count',
    last_login_at: 'last_login_at',
    locked_until: 'locked_until',
    password_hash: 'password_hash',
    deleted_at: 'deleted_at',
    deleted_by: 'deleted_by',
    is_deleted: 'is_deleted'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const System_eventScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    user_id: 'user_id',
    event_type: 'event_type',
    source_system: 'source_system',
    target_system: 'target_system',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    action: 'action',
    event_data: 'event_data',
    created_at: 'created_at',
    processed_at: 'processed_at',
    status: 'status'
  };

  export type System_eventScalarFieldEnum = (typeof System_eventScalarFieldEnum)[keyof typeof System_eventScalarFieldEnum]


  export const Tenant_access_logsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    user_id: 'user_id',
    action: 'action',
    resource: 'resource',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    created_at: 'created_at',
    source_system: 'source_system'
  };

  export type Tenant_access_logsScalarFieldEnum = (typeof Tenant_access_logsScalarFieldEnum)[keyof typeof Tenant_access_logsScalarFieldEnum]


  export const Tenant_servicesScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    service_type: 'service_type',
    plan_type: 'plan_type',
    is_active: 'is_active',
    activated_at: 'activated_at',
    expires_at: 'expires_at',
    service_config: 'service_config',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Tenant_servicesScalarFieldEnum = (typeof Tenant_servicesScalarFieldEnum)[keyof typeof Tenant_servicesScalarFieldEnum]


  export const Checkin_sessionsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    session_number: 'session_number',
    reservation_id: 'reservation_id',
    room_id: 'room_id',
    guest_info: 'guest_info',
    adults: 'adults',
    children: 'children',
    check_in_at: 'check_in_at',
    check_out_at: 'check_out_at',
    planned_check_out: 'planned_check_out',
    status: 'status',
    special_requests: 'special_requests',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Checkin_sessionsScalarFieldEnum = (typeof Checkin_sessionsScalarFieldEnum)[keyof typeof Checkin_sessionsScalarFieldEnum]


  export const Session_billingsScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    session_id: 'session_id',
    billing_number: 'billing_number',
    room_charges: 'room_charges',
    service_charges: 'service_charges',
    taxes: 'taxes',
    discounts: 'discounts',
    subtotal_amount: 'subtotal_amount',
    tax_amount: 'tax_amount',
    total_amount: 'total_amount',
    paid_amount: 'paid_amount',
    status: 'status',
    payment_method: 'payment_method',
    payment_date: 'payment_date',
    due_date: 'due_date',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Session_billingsScalarFieldEnum = (typeof Session_billingsScalarFieldEnum)[keyof typeof Session_billingsScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    roomNumber: 'roomNumber',
    roomType: 'roomType',
    floor: 'floor',
    status: 'status',
    capacity: 'capacity',
    amenities: 'amenities',
    notes: 'notes',
    lastCleaned: 'lastCleaned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    invoiceId: 'invoiceId',
    paymentId: 'paymentId',
    type: 'type',
    amount: 'amount',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    status: 'status',
    description: 'description',
    reference: 'reference',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    invoiceNumber: 'invoiceNumber',
    customerId: 'customerId',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    billingAddress: 'billingAddress',
    items: 'items',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    status: 'status',
    dueDate: 'dueDate',
    issuedAt: 'issuedAt',
    paidAt: 'paidAt',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    transactionId: 'transactionId',
    invoiceId: 'invoiceId',
    paymentMethod: 'paymentMethod',
    amount: 'amount',
    status: 'status',
    reference: 'reference',
    metadata: 'metadata',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'AdminLevel'
   */
  export type EnumAdminLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminLevel'>
    


  /**
   * Reference to a field of type 'AdminLevel[]'
   */
  export type ListEnumAdminLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminLevel[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'CampaignDisplayType'
   */
  export type EnumCampaignDisplayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignDisplayType'>
    


  /**
   * Reference to a field of type 'CampaignDisplayType[]'
   */
  export type ListEnumCampaignDisplayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignDisplayType[]'>
    


  /**
   * Reference to a field of type 'CampaignCtaType'
   */
  export type EnumCampaignCtaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignCtaType'>
    


  /**
   * Reference to a field of type 'CampaignCtaType[]'
   */
  export type ListEnumCampaignCtaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignCtaType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type DatabaseChangeLogWhereInput = {
    AND?: DatabaseChangeLogWhereInput | DatabaseChangeLogWhereInput[]
    OR?: DatabaseChangeLogWhereInput[]
    NOT?: DatabaseChangeLogWhereInput | DatabaseChangeLogWhereInput[]
    id?: IntFilter<"DatabaseChangeLog"> | number
    changeType?: StringFilter<"DatabaseChangeLog"> | string
    description?: StringFilter<"DatabaseChangeLog"> | string
    details?: JsonNullableFilter<"DatabaseChangeLog">
    createdBy?: StringNullableFilter<"DatabaseChangeLog"> | string | null
    createdAt?: DateTimeFilter<"DatabaseChangeLog"> | Date | string
  }

  export type DatabaseChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    changeType?: SortOrder
    description?: SortOrder
    details?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type DatabaseChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DatabaseChangeLogWhereInput | DatabaseChangeLogWhereInput[]
    OR?: DatabaseChangeLogWhereInput[]
    NOT?: DatabaseChangeLogWhereInput | DatabaseChangeLogWhereInput[]
    changeType?: StringFilter<"DatabaseChangeLog"> | string
    description?: StringFilter<"DatabaseChangeLog"> | string
    details?: JsonNullableFilter<"DatabaseChangeLog">
    createdBy?: StringNullableFilter<"DatabaseChangeLog"> | string | null
    createdAt?: DateTimeFilter<"DatabaseChangeLog"> | Date | string
  }, "id">

  export type DatabaseChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    changeType?: SortOrder
    description?: SortOrder
    details?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DatabaseChangeLogCountOrderByAggregateInput
    _avg?: DatabaseChangeLogAvgOrderByAggregateInput
    _max?: DatabaseChangeLogMaxOrderByAggregateInput
    _min?: DatabaseChangeLogMinOrderByAggregateInput
    _sum?: DatabaseChangeLogSumOrderByAggregateInput
  }

  export type DatabaseChangeLogScalarWhereWithAggregatesInput = {
    AND?: DatabaseChangeLogScalarWhereWithAggregatesInput | DatabaseChangeLogScalarWhereWithAggregatesInput[]
    OR?: DatabaseChangeLogScalarWhereWithAggregatesInput[]
    NOT?: DatabaseChangeLogScalarWhereWithAggregatesInput | DatabaseChangeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DatabaseChangeLog"> | number
    changeType?: StringWithAggregatesFilter<"DatabaseChangeLog"> | string
    description?: StringWithAggregatesFilter<"DatabaseChangeLog"> | string
    details?: JsonNullableWithAggregatesFilter<"DatabaseChangeLog">
    createdBy?: StringNullableWithAggregatesFilter<"DatabaseChangeLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DatabaseChangeLog"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    tenantId?: StringFilter<"Order"> | string
    roomId?: StringFilter<"Order"> | string
    placeId?: IntNullableFilter<"Order"> | number | null
    status?: StringFilter<"Order"> | string
    items?: JsonFilter<"Order">
    total?: IntFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    isDeleted?: BoolFilter<"Order"> | boolean
    deletedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    uuid?: StringNullableFilter<"Order"> | string | null
    sessionId?: StringNullableFilter<"Order"> | string | null
    OrderItem?: OrderItemListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    placeId?: SortOrderInput | SortOrder
    status?: SortOrder
    items?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    uuid?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    OrderItem?: OrderItemOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    tenantId?: StringFilter<"Order"> | string
    roomId?: StringFilter<"Order"> | string
    placeId?: IntNullableFilter<"Order"> | number | null
    status?: StringFilter<"Order"> | string
    items?: JsonFilter<"Order">
    total?: IntFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    isDeleted?: BoolFilter<"Order"> | boolean
    deletedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    sessionId?: StringNullableFilter<"Order"> | string | null
    OrderItem?: OrderItemListRelationFilter
  }, "id" | "uuid">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    placeId?: SortOrderInput | SortOrder
    status?: SortOrder
    items?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    uuid?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    tenantId?: StringWithAggregatesFilter<"Order"> | string
    roomId?: StringWithAggregatesFilter<"Order"> | string
    placeId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    status?: StringWithAggregatesFilter<"Order"> | string
    items?: JsonWithAggregatesFilter<"Order">
    total?: IntWithAggregatesFilter<"Order"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Order"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    uuid?: StringNullableWithAggregatesFilter<"Order"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    tenantId?: StringFilter<"OrderItem"> | string
    orderId?: IntFilter<"OrderItem"> | number
    menuItemId?: IntFilter<"OrderItem"> | number
    name?: StringFilter<"OrderItem"> | string
    price?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    status?: StringFilter<"OrderItem"> | string
    notes?: StringNullableFilter<"OrderItem"> | string | null
    deliveredAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    deleted_at?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deleted_by?: StringNullableFilter<"OrderItem"> | string | null
    is_deleted?: BoolFilter<"OrderItem"> | boolean
    Order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    Order?: OrderOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    tenantId?: StringFilter<"OrderItem"> | string
    orderId?: IntFilter<"OrderItem"> | number
    menuItemId?: IntFilter<"OrderItem"> | number
    name?: StringFilter<"OrderItem"> | string
    price?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    status?: StringFilter<"OrderItem"> | string
    notes?: StringNullableFilter<"OrderItem"> | string | null
    deliveredAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    deleted_at?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deleted_by?: StringNullableFilter<"OrderItem"> | string | null
    is_deleted?: BoolFilter<"OrderItem"> | boolean
    Order?: XOR<OrderRelationFilter, OrderWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    tenantId?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    menuItemId?: IntWithAggregatesFilter<"OrderItem"> | number
    name?: StringWithAggregatesFilter<"OrderItem"> | string
    price?: IntWithAggregatesFilter<"OrderItem"> | number
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    status?: StringWithAggregatesFilter<"OrderItem"> | string
    notes?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"OrderItem"> | boolean
  }

  export type SystemPlanRestrictionsWhereInput = {
    AND?: SystemPlanRestrictionsWhereInput | SystemPlanRestrictionsWhereInput[]
    OR?: SystemPlanRestrictionsWhereInput[]
    NOT?: SystemPlanRestrictionsWhereInput | SystemPlanRestrictionsWhereInput[]
    id?: StringFilter<"SystemPlanRestrictions"> | string
    systemType?: StringFilter<"SystemPlanRestrictions"> | string
    businessType?: StringFilter<"SystemPlanRestrictions"> | string
    planType?: StringFilter<"SystemPlanRestrictions"> | string
    planCategory?: StringFilter<"SystemPlanRestrictions"> | string
    monthlyPrice?: IntFilter<"SystemPlanRestrictions"> | number
    maxDevices?: IntFilter<"SystemPlanRestrictions"> | number
    additionalDeviceCost?: IntFilter<"SystemPlanRestrictions"> | number
    roomTerminalCost?: IntFilter<"SystemPlanRestrictions"> | number
    frontDeskCost?: IntFilter<"SystemPlanRestrictions"> | number
    kitchenCost?: IntFilter<"SystemPlanRestrictions"> | number
    barCost?: IntFilter<"SystemPlanRestrictions"> | number
    housekeepingCost?: IntFilter<"SystemPlanRestrictions"> | number
    managerCost?: IntFilter<"SystemPlanRestrictions"> | number
    commonAreaCost?: IntFilter<"SystemPlanRestrictions"> | number
    enableAiConcierge?: BoolFilter<"SystemPlanRestrictions"> | boolean
    enableMultilingual?: BoolFilter<"SystemPlanRestrictions"> | boolean
    enableLayoutEditor?: BoolFilter<"SystemPlanRestrictions"> | boolean
    enableFacilityGuide?: BoolFilter<"SystemPlanRestrictions"> | boolean
    enableAiBusinessSupport?: BoolFilter<"SystemPlanRestrictions"> | boolean
    maxMonthlyOrders?: IntFilter<"SystemPlanRestrictions"> | number
    maxMonthlyAiRequests?: IntFilter<"SystemPlanRestrictions"> | number
    maxStorageGB?: FloatFilter<"SystemPlanRestrictions"> | number
    multilingualUpgradePrice?: IntFilter<"SystemPlanRestrictions"> | number
    description?: StringNullableFilter<"SystemPlanRestrictions"> | string | null
    createdAt?: DateTimeFilter<"SystemPlanRestrictions"> | Date | string
    updatedAt?: DateTimeFilter<"SystemPlanRestrictions"> | Date | string
    deleted_at?: DateTimeNullableFilter<"SystemPlanRestrictions"> | Date | string | null
    deleted_by?: StringNullableFilter<"SystemPlanRestrictions"> | string | null
    is_deleted?: BoolFilter<"SystemPlanRestrictions"> | boolean
    TenantSystemPlan?: TenantSystemPlanListRelationFilter
  }

  export type SystemPlanRestrictionsOrderByWithRelationInput = {
    id?: SortOrder
    systemType?: SortOrder
    businessType?: SortOrder
    planType?: SortOrder
    planCategory?: SortOrder
    monthlyPrice?: SortOrder
    maxDevices?: SortOrder
    additionalDeviceCost?: SortOrder
    roomTerminalCost?: SortOrder
    frontDeskCost?: SortOrder
    kitchenCost?: SortOrder
    barCost?: SortOrder
    housekeepingCost?: SortOrder
    managerCost?: SortOrder
    commonAreaCost?: SortOrder
    enableAiConcierge?: SortOrder
    enableMultilingual?: SortOrder
    enableLayoutEditor?: SortOrder
    enableFacilityGuide?: SortOrder
    enableAiBusinessSupport?: SortOrder
    maxMonthlyOrders?: SortOrder
    maxMonthlyAiRequests?: SortOrder
    maxStorageGB?: SortOrder
    multilingualUpgradePrice?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    TenantSystemPlan?: TenantSystemPlanOrderByRelationAggregateInput
  }

  export type SystemPlanRestrictionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    systemType_businessType_planType_planCategory?: SystemPlanRestrictionsSystemTypeBusinessTypePlanTypePlanCategoryCompoundUniqueInput
    AND?: SystemPlanRestrictionsWhereInput | SystemPlanRestrictionsWhereInput[]
    OR?: SystemPlanRestrictionsWhereInput[]
    NOT?: SystemPlanRestrictionsWhereInput | SystemPlanRestrictionsWhereInput[]
    systemType?: StringFilter<"SystemPlanRestrictions"> | string
    businessType?: StringFilter<"SystemPlanRestrictions"> | string
    planType?: StringFilter<"SystemPlanRestrictions"> | string
    planCategory?: StringFilter<"SystemPlanRestrictions"> | string
    monthlyPrice?: IntFilter<"SystemPlanRestrictions"> | number
    maxDevices?: IntFilter<"SystemPlanRestrictions"> | number
    additionalDeviceCost?: IntFilter<"SystemPlanRestrictions"> | number
    roomTerminalCost?: IntFilter<"SystemPlanRestrictions"> | number
    frontDeskCost?: IntFilter<"SystemPlanRestrictions"> | number
    kitchenCost?: IntFilter<"SystemPlanRestrictions"> | number
    barCost?: IntFilter<"SystemPlanRestrictions"> | number
    housekeepingCost?: IntFilter<"SystemPlanRestrictions"> | number
    managerCost?: IntFilter<"SystemPlanRestrictions"> | number
    commonAreaCost?: IntFilter<"SystemPlanRestrictions"> | number
    enableAiConcierge?: BoolFilter<"SystemPlanRestrictions"> | boolean
    enableMultilingual?: BoolFilter<"SystemPlanRestrictions"> | boolean
    enableLayoutEditor?: BoolFilter<"SystemPlanRestrictions"> | boolean
    enableFacilityGuide?: BoolFilter<"SystemPlanRestrictions"> | boolean
    enableAiBusinessSupport?: BoolFilter<"SystemPlanRestrictions"> | boolean
    maxMonthlyOrders?: IntFilter<"SystemPlanRestrictions"> | number
    maxMonthlyAiRequests?: IntFilter<"SystemPlanRestrictions"> | number
    maxStorageGB?: FloatFilter<"SystemPlanRestrictions"> | number
    multilingualUpgradePrice?: IntFilter<"SystemPlanRestrictions"> | number
    description?: StringNullableFilter<"SystemPlanRestrictions"> | string | null
    createdAt?: DateTimeFilter<"SystemPlanRestrictions"> | Date | string
    updatedAt?: DateTimeFilter<"SystemPlanRestrictions"> | Date | string
    deleted_at?: DateTimeNullableFilter<"SystemPlanRestrictions"> | Date | string | null
    deleted_by?: StringNullableFilter<"SystemPlanRestrictions"> | string | null
    is_deleted?: BoolFilter<"SystemPlanRestrictions"> | boolean
    TenantSystemPlan?: TenantSystemPlanListRelationFilter
  }, "id" | "systemType_businessType_planType_planCategory">

  export type SystemPlanRestrictionsOrderByWithAggregationInput = {
    id?: SortOrder
    systemType?: SortOrder
    businessType?: SortOrder
    planType?: SortOrder
    planCategory?: SortOrder
    monthlyPrice?: SortOrder
    maxDevices?: SortOrder
    additionalDeviceCost?: SortOrder
    roomTerminalCost?: SortOrder
    frontDeskCost?: SortOrder
    kitchenCost?: SortOrder
    barCost?: SortOrder
    housekeepingCost?: SortOrder
    managerCost?: SortOrder
    commonAreaCost?: SortOrder
    enableAiConcierge?: SortOrder
    enableMultilingual?: SortOrder
    enableLayoutEditor?: SortOrder
    enableFacilityGuide?: SortOrder
    enableAiBusinessSupport?: SortOrder
    maxMonthlyOrders?: SortOrder
    maxMonthlyAiRequests?: SortOrder
    maxStorageGB?: SortOrder
    multilingualUpgradePrice?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: SystemPlanRestrictionsCountOrderByAggregateInput
    _avg?: SystemPlanRestrictionsAvgOrderByAggregateInput
    _max?: SystemPlanRestrictionsMaxOrderByAggregateInput
    _min?: SystemPlanRestrictionsMinOrderByAggregateInput
    _sum?: SystemPlanRestrictionsSumOrderByAggregateInput
  }

  export type SystemPlanRestrictionsScalarWhereWithAggregatesInput = {
    AND?: SystemPlanRestrictionsScalarWhereWithAggregatesInput | SystemPlanRestrictionsScalarWhereWithAggregatesInput[]
    OR?: SystemPlanRestrictionsScalarWhereWithAggregatesInput[]
    NOT?: SystemPlanRestrictionsScalarWhereWithAggregatesInput | SystemPlanRestrictionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemPlanRestrictions"> | string
    systemType?: StringWithAggregatesFilter<"SystemPlanRestrictions"> | string
    businessType?: StringWithAggregatesFilter<"SystemPlanRestrictions"> | string
    planType?: StringWithAggregatesFilter<"SystemPlanRestrictions"> | string
    planCategory?: StringWithAggregatesFilter<"SystemPlanRestrictions"> | string
    monthlyPrice?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    maxDevices?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    additionalDeviceCost?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    roomTerminalCost?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    frontDeskCost?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    kitchenCost?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    barCost?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    housekeepingCost?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    managerCost?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    commonAreaCost?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    enableAiConcierge?: BoolWithAggregatesFilter<"SystemPlanRestrictions"> | boolean
    enableMultilingual?: BoolWithAggregatesFilter<"SystemPlanRestrictions"> | boolean
    enableLayoutEditor?: BoolWithAggregatesFilter<"SystemPlanRestrictions"> | boolean
    enableFacilityGuide?: BoolWithAggregatesFilter<"SystemPlanRestrictions"> | boolean
    enableAiBusinessSupport?: BoolWithAggregatesFilter<"SystemPlanRestrictions"> | boolean
    maxMonthlyOrders?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    maxMonthlyAiRequests?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    maxStorageGB?: FloatWithAggregatesFilter<"SystemPlanRestrictions"> | number
    multilingualUpgradePrice?: IntWithAggregatesFilter<"SystemPlanRestrictions"> | number
    description?: StringNullableWithAggregatesFilter<"SystemPlanRestrictions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemPlanRestrictions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemPlanRestrictions"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"SystemPlanRestrictions"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"SystemPlanRestrictions"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"SystemPlanRestrictions"> | boolean
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    contactEmail?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    deleted_by?: StringNullableFilter<"Tenant"> | string | null
    features?: StringNullableListFilter<"Tenant">
    is_deleted?: BoolFilter<"Tenant"> | boolean
    planType?: StringNullableFilter<"Tenant"> | string | null
    settings?: JsonNullableFilter<"Tenant">
    status?: StringFilter<"Tenant"> | string
    TenantSystemPlan?: TenantSystemPlanListRelationFilter
    device_rooms?: Device_roomsListRelationFilter
    pages?: PagesListRelationFilter
    service_usage_statistics?: Service_usage_statisticsListRelationFilter
    tenant_services?: Tenant_servicesListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    features?: SortOrder
    is_deleted?: SortOrder
    planType?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    status?: SortOrder
    TenantSystemPlan?: TenantSystemPlanOrderByRelationAggregateInput
    device_rooms?: device_roomsOrderByRelationAggregateInput
    pages?: pagesOrderByRelationAggregateInput
    service_usage_statistics?: service_usage_statisticsOrderByRelationAggregateInput
    tenant_services?: tenant_servicesOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    contactEmail?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    deleted_at?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    deleted_by?: StringNullableFilter<"Tenant"> | string | null
    features?: StringNullableListFilter<"Tenant">
    is_deleted?: BoolFilter<"Tenant"> | boolean
    planType?: StringNullableFilter<"Tenant"> | string | null
    settings?: JsonNullableFilter<"Tenant">
    status?: StringFilter<"Tenant"> | string
    TenantSystemPlan?: TenantSystemPlanListRelationFilter
    device_rooms?: Device_roomsListRelationFilter
    pages?: PagesListRelationFilter
    service_usage_statistics?: Service_usage_statisticsListRelationFilter
    tenant_services?: Tenant_servicesListRelationFilter
  }, "id" | "domain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    features?: SortOrder
    is_deleted?: SortOrder
    planType?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    features?: StringNullableListFilter<"Tenant">
    is_deleted?: BoolWithAggregatesFilter<"Tenant"> | boolean
    planType?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    settings?: JsonNullableWithAggregatesFilter<"Tenant">
    status?: StringWithAggregatesFilter<"Tenant"> | string
  }

  export type TenantSystemPlanWhereInput = {
    AND?: TenantSystemPlanWhereInput | TenantSystemPlanWhereInput[]
    OR?: TenantSystemPlanWhereInput[]
    NOT?: TenantSystemPlanWhereInput | TenantSystemPlanWhereInput[]
    id?: StringFilter<"TenantSystemPlan"> | string
    tenantId?: StringFilter<"TenantSystemPlan"> | string
    systemType?: StringFilter<"TenantSystemPlan"> | string
    planId?: StringFilter<"TenantSystemPlan"> | string
    startDate?: DateTimeFilter<"TenantSystemPlan"> | Date | string
    endDate?: DateTimeNullableFilter<"TenantSystemPlan"> | Date | string | null
    isActive?: BoolFilter<"TenantSystemPlan"> | boolean
    monthlyPrice?: IntFilter<"TenantSystemPlan"> | number
    createdAt?: DateTimeFilter<"TenantSystemPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TenantSystemPlan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"TenantSystemPlan"> | Date | string | null
    deleted_by?: StringNullableFilter<"TenantSystemPlan"> | string | null
    is_deleted?: BoolFilter<"TenantSystemPlan"> | boolean
    SystemPlanRestrictions?: XOR<SystemPlanRestrictionsRelationFilter, SystemPlanRestrictionsWhereInput>
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type TenantSystemPlanOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    systemType?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    monthlyPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    SystemPlanRestrictions?: SystemPlanRestrictionsOrderByWithRelationInput
    Tenant?: TenantOrderByWithRelationInput
  }

  export type TenantSystemPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_systemType?: TenantSystemPlanTenantIdSystemTypeCompoundUniqueInput
    AND?: TenantSystemPlanWhereInput | TenantSystemPlanWhereInput[]
    OR?: TenantSystemPlanWhereInput[]
    NOT?: TenantSystemPlanWhereInput | TenantSystemPlanWhereInput[]
    tenantId?: StringFilter<"TenantSystemPlan"> | string
    systemType?: StringFilter<"TenantSystemPlan"> | string
    planId?: StringFilter<"TenantSystemPlan"> | string
    startDate?: DateTimeFilter<"TenantSystemPlan"> | Date | string
    endDate?: DateTimeNullableFilter<"TenantSystemPlan"> | Date | string | null
    isActive?: BoolFilter<"TenantSystemPlan"> | boolean
    monthlyPrice?: IntFilter<"TenantSystemPlan"> | number
    createdAt?: DateTimeFilter<"TenantSystemPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TenantSystemPlan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"TenantSystemPlan"> | Date | string | null
    deleted_by?: StringNullableFilter<"TenantSystemPlan"> | string | null
    is_deleted?: BoolFilter<"TenantSystemPlan"> | boolean
    SystemPlanRestrictions?: XOR<SystemPlanRestrictionsRelationFilter, SystemPlanRestrictionsWhereInput>
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_systemType">

  export type TenantSystemPlanOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    systemType?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    monthlyPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: TenantSystemPlanCountOrderByAggregateInput
    _avg?: TenantSystemPlanAvgOrderByAggregateInput
    _max?: TenantSystemPlanMaxOrderByAggregateInput
    _min?: TenantSystemPlanMinOrderByAggregateInput
    _sum?: TenantSystemPlanSumOrderByAggregateInput
  }

  export type TenantSystemPlanScalarWhereWithAggregatesInput = {
    AND?: TenantSystemPlanScalarWhereWithAggregatesInput | TenantSystemPlanScalarWhereWithAggregatesInput[]
    OR?: TenantSystemPlanScalarWhereWithAggregatesInput[]
    NOT?: TenantSystemPlanScalarWhereWithAggregatesInput | TenantSystemPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantSystemPlan"> | string
    tenantId?: StringWithAggregatesFilter<"TenantSystemPlan"> | string
    systemType?: StringWithAggregatesFilter<"TenantSystemPlan"> | string
    planId?: StringWithAggregatesFilter<"TenantSystemPlan"> | string
    startDate?: DateTimeWithAggregatesFilter<"TenantSystemPlan"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"TenantSystemPlan"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"TenantSystemPlan"> | boolean
    monthlyPrice?: IntWithAggregatesFilter<"TenantSystemPlan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TenantSystemPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantSystemPlan"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"TenantSystemPlan"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"TenantSystemPlan"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"TenantSystemPlan"> | boolean
  }

  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    id?: StringFilter<"admin"> | string
    email?: StringFilter<"admin"> | string
    username?: StringFilter<"admin"> | string
    display_name?: StringFilter<"admin"> | string
    password_hash?: StringFilter<"admin"> | string
    admin_level?: EnumAdminLevelFilter<"admin"> | $Enums.AdminLevel
    accessible_group_ids?: StringNullableListFilter<"admin">
    accessible_chain_ids?: StringNullableListFilter<"admin">
    accessible_tenant_ids?: StringNullableListFilter<"admin">
    last_login_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    login_attempts?: IntFilter<"admin"> | number
    locked_until?: DateTimeNullableFilter<"admin"> | Date | string | null
    totp_secret?: StringNullableFilter<"admin"> | string | null
    totp_enabled?: BoolFilter<"admin"> | boolean
    created_at?: DateTimeFilter<"admin"> | Date | string
    updated_at?: DateTimeFilter<"admin"> | Date | string
    created_by?: StringNullableFilter<"admin"> | string | null
    is_active?: BoolFilter<"admin"> | boolean
    deleted_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    deleted_by?: StringNullableFilter<"admin"> | string | null
    is_deleted?: BoolFilter<"admin"> | boolean
    admin_log?: Admin_logListRelationFilter
  }

  export type adminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    password_hash?: SortOrder
    admin_level?: SortOrder
    accessible_group_ids?: SortOrder
    accessible_chain_ids?: SortOrder
    accessible_tenant_ids?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrderInput | SortOrder
    totp_secret?: SortOrderInput | SortOrder
    totp_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    admin_log?: admin_logOrderByRelationAggregateInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    display_name?: StringFilter<"admin"> | string
    password_hash?: StringFilter<"admin"> | string
    admin_level?: EnumAdminLevelFilter<"admin"> | $Enums.AdminLevel
    accessible_group_ids?: StringNullableListFilter<"admin">
    accessible_chain_ids?: StringNullableListFilter<"admin">
    accessible_tenant_ids?: StringNullableListFilter<"admin">
    last_login_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    login_attempts?: IntFilter<"admin"> | number
    locked_until?: DateTimeNullableFilter<"admin"> | Date | string | null
    totp_secret?: StringNullableFilter<"admin"> | string | null
    totp_enabled?: BoolFilter<"admin"> | boolean
    created_at?: DateTimeFilter<"admin"> | Date | string
    updated_at?: DateTimeFilter<"admin"> | Date | string
    created_by?: StringNullableFilter<"admin"> | string | null
    is_active?: BoolFilter<"admin"> | boolean
    deleted_at?: DateTimeNullableFilter<"admin"> | Date | string | null
    deleted_by?: StringNullableFilter<"admin"> | string | null
    is_deleted?: BoolFilter<"admin"> | boolean
    admin_log?: Admin_logListRelationFilter
  }, "id" | "email" | "username">

  export type adminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    password_hash?: SortOrder
    admin_level?: SortOrder
    accessible_group_ids?: SortOrder
    accessible_chain_ids?: SortOrder
    accessible_tenant_ids?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrderInput | SortOrder
    totp_secret?: SortOrderInput | SortOrder
    totp_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"admin"> | string
    email?: StringWithAggregatesFilter<"admin"> | string
    username?: StringWithAggregatesFilter<"admin"> | string
    display_name?: StringWithAggregatesFilter<"admin"> | string
    password_hash?: StringWithAggregatesFilter<"admin"> | string
    admin_level?: EnumAdminLevelWithAggregatesFilter<"admin"> | $Enums.AdminLevel
    accessible_group_ids?: StringNullableListFilter<"admin">
    accessible_chain_ids?: StringNullableListFilter<"admin">
    accessible_tenant_ids?: StringNullableListFilter<"admin">
    last_login_at?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    login_attempts?: IntWithAggregatesFilter<"admin"> | number
    locked_until?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    totp_secret?: StringNullableWithAggregatesFilter<"admin"> | string | null
    totp_enabled?: BoolWithAggregatesFilter<"admin"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"admin"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"admin"> | Date | string
    created_by?: StringNullableWithAggregatesFilter<"admin"> | string | null
    is_active?: BoolWithAggregatesFilter<"admin"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"admin"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"admin"> | boolean
  }

  export type admin_logWhereInput = {
    AND?: admin_logWhereInput | admin_logWhereInput[]
    OR?: admin_logWhereInput[]
    NOT?: admin_logWhereInput | admin_logWhereInput[]
    id?: StringFilter<"admin_log"> | string
    admin_id?: StringFilter<"admin_log"> | string
    action?: StringFilter<"admin_log"> | string
    target_type?: StringNullableFilter<"admin_log"> | string | null
    target_id?: StringNullableFilter<"admin_log"> | string | null
    ip_address?: StringNullableFilter<"admin_log"> | string | null
    user_agent?: StringNullableFilter<"admin_log"> | string | null
    success?: BoolFilter<"admin_log"> | boolean
    error_message?: StringNullableFilter<"admin_log"> | string | null
    created_at?: DateTimeFilter<"admin_log"> | Date | string
    deleted_at?: DateTimeNullableFilter<"admin_log"> | Date | string | null
    deleted_by?: StringNullableFilter<"admin_log"> | string | null
    is_deleted?: BoolFilter<"admin_log"> | boolean
    admin?: XOR<AdminRelationFilter, adminWhereInput>
  }

  export type admin_logOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    action?: SortOrder
    target_type?: SortOrderInput | SortOrder
    target_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    success?: SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    admin?: adminOrderByWithRelationInput
  }

  export type admin_logWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: admin_logWhereInput | admin_logWhereInput[]
    OR?: admin_logWhereInput[]
    NOT?: admin_logWhereInput | admin_logWhereInput[]
    admin_id?: StringFilter<"admin_log"> | string
    action?: StringFilter<"admin_log"> | string
    target_type?: StringNullableFilter<"admin_log"> | string | null
    target_id?: StringNullableFilter<"admin_log"> | string | null
    ip_address?: StringNullableFilter<"admin_log"> | string | null
    user_agent?: StringNullableFilter<"admin_log"> | string | null
    success?: BoolFilter<"admin_log"> | boolean
    error_message?: StringNullableFilter<"admin_log"> | string | null
    created_at?: DateTimeFilter<"admin_log"> | Date | string
    deleted_at?: DateTimeNullableFilter<"admin_log"> | Date | string | null
    deleted_by?: StringNullableFilter<"admin_log"> | string | null
    is_deleted?: BoolFilter<"admin_log"> | boolean
    admin?: XOR<AdminRelationFilter, adminWhereInput>
  }, "id">

  export type admin_logOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    action?: SortOrder
    target_type?: SortOrderInput | SortOrder
    target_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    success?: SortOrder
    error_message?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: admin_logCountOrderByAggregateInput
    _max?: admin_logMaxOrderByAggregateInput
    _min?: admin_logMinOrderByAggregateInput
  }

  export type admin_logScalarWhereWithAggregatesInput = {
    AND?: admin_logScalarWhereWithAggregatesInput | admin_logScalarWhereWithAggregatesInput[]
    OR?: admin_logScalarWhereWithAggregatesInput[]
    NOT?: admin_logScalarWhereWithAggregatesInput | admin_logScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"admin_log"> | string
    admin_id?: StringWithAggregatesFilter<"admin_log"> | string
    action?: StringWithAggregatesFilter<"admin_log"> | string
    target_type?: StringNullableWithAggregatesFilter<"admin_log"> | string | null
    target_id?: StringNullableWithAggregatesFilter<"admin_log"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"admin_log"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"admin_log"> | string | null
    success?: BoolWithAggregatesFilter<"admin_log"> | boolean
    error_message?: StringNullableWithAggregatesFilter<"admin_log"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"admin_log"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"admin_log"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"admin_log"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"admin_log"> | boolean
  }

  export type campaign_categoriesWhereInput = {
    AND?: campaign_categoriesWhereInput | campaign_categoriesWhereInput[]
    OR?: campaign_categoriesWhereInput[]
    NOT?: campaign_categoriesWhereInput | campaign_categoriesWhereInput[]
    id?: StringFilter<"campaign_categories"> | string
    tenantId?: StringFilter<"campaign_categories"> | string
    code?: StringFilter<"campaign_categories"> | string
    name?: StringFilter<"campaign_categories"> | string
    description?: StringNullableFilter<"campaign_categories"> | string | null
    createdAt?: DateTimeFilter<"campaign_categories"> | Date | string
    updatedAt?: DateTimeFilter<"campaign_categories"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_categories"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_categories"> | string | null
    is_deleted?: BoolFilter<"campaign_categories"> | boolean
    campaign_category_relations?: Campaign_category_relationsListRelationFilter
  }

  export type campaign_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    campaign_category_relations?: campaign_category_relationsOrderByRelationAggregateInput
  }

  export type campaign_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: campaign_categoriesWhereInput | campaign_categoriesWhereInput[]
    OR?: campaign_categoriesWhereInput[]
    NOT?: campaign_categoriesWhereInput | campaign_categoriesWhereInput[]
    tenantId?: StringFilter<"campaign_categories"> | string
    name?: StringFilter<"campaign_categories"> | string
    description?: StringNullableFilter<"campaign_categories"> | string | null
    createdAt?: DateTimeFilter<"campaign_categories"> | Date | string
    updatedAt?: DateTimeFilter<"campaign_categories"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_categories"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_categories"> | string | null
    is_deleted?: BoolFilter<"campaign_categories"> | boolean
    campaign_category_relations?: Campaign_category_relationsListRelationFilter
  }, "id" | "code">

  export type campaign_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: campaign_categoriesCountOrderByAggregateInput
    _max?: campaign_categoriesMaxOrderByAggregateInput
    _min?: campaign_categoriesMinOrderByAggregateInput
  }

  export type campaign_categoriesScalarWhereWithAggregatesInput = {
    AND?: campaign_categoriesScalarWhereWithAggregatesInput | campaign_categoriesScalarWhereWithAggregatesInput[]
    OR?: campaign_categoriesScalarWhereWithAggregatesInput[]
    NOT?: campaign_categoriesScalarWhereWithAggregatesInput | campaign_categoriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"campaign_categories"> | string
    tenantId?: StringWithAggregatesFilter<"campaign_categories"> | string
    code?: StringWithAggregatesFilter<"campaign_categories"> | string
    name?: StringWithAggregatesFilter<"campaign_categories"> | string
    description?: StringNullableWithAggregatesFilter<"campaign_categories"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"campaign_categories"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"campaign_categories"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"campaign_categories"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"campaign_categories"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"campaign_categories"> | boolean
  }

  export type campaign_category_relationsWhereInput = {
    AND?: campaign_category_relationsWhereInput | campaign_category_relationsWhereInput[]
    OR?: campaign_category_relationsWhereInput[]
    NOT?: campaign_category_relationsWhereInput | campaign_category_relationsWhereInput[]
    id?: StringFilter<"campaign_category_relations"> | string
    campaignId?: StringFilter<"campaign_category_relations"> | string
    categoryId?: StringFilter<"campaign_category_relations"> | string
    createdAt?: DateTimeFilter<"campaign_category_relations"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_category_relations"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_category_relations"> | string | null
    is_deleted?: BoolFilter<"campaign_category_relations"> | boolean
    campaigns?: XOR<CampaignsRelationFilter, campaignsWhereInput>
    campaign_categories?: XOR<Campaign_categoriesRelationFilter, campaign_categoriesWhereInput>
  }

  export type campaign_category_relationsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    campaigns?: campaignsOrderByWithRelationInput
    campaign_categories?: campaign_categoriesOrderByWithRelationInput
  }

  export type campaign_category_relationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_categoryId?: campaign_category_relationsCampaignIdCategoryIdCompoundUniqueInput
    AND?: campaign_category_relationsWhereInput | campaign_category_relationsWhereInput[]
    OR?: campaign_category_relationsWhereInput[]
    NOT?: campaign_category_relationsWhereInput | campaign_category_relationsWhereInput[]
    campaignId?: StringFilter<"campaign_category_relations"> | string
    categoryId?: StringFilter<"campaign_category_relations"> | string
    createdAt?: DateTimeFilter<"campaign_category_relations"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_category_relations"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_category_relations"> | string | null
    is_deleted?: BoolFilter<"campaign_category_relations"> | boolean
    campaigns?: XOR<CampaignsRelationFilter, campaignsWhereInput>
    campaign_categories?: XOR<Campaign_categoriesRelationFilter, campaign_categoriesWhereInput>
  }, "id" | "campaignId_categoryId">

  export type campaign_category_relationsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: campaign_category_relationsCountOrderByAggregateInput
    _max?: campaign_category_relationsMaxOrderByAggregateInput
    _min?: campaign_category_relationsMinOrderByAggregateInput
  }

  export type campaign_category_relationsScalarWhereWithAggregatesInput = {
    AND?: campaign_category_relationsScalarWhereWithAggregatesInput | campaign_category_relationsScalarWhereWithAggregatesInput[]
    OR?: campaign_category_relationsScalarWhereWithAggregatesInput[]
    NOT?: campaign_category_relationsScalarWhereWithAggregatesInput | campaign_category_relationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"campaign_category_relations"> | string
    campaignId?: StringWithAggregatesFilter<"campaign_category_relations"> | string
    categoryId?: StringWithAggregatesFilter<"campaign_category_relations"> | string
    createdAt?: DateTimeWithAggregatesFilter<"campaign_category_relations"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"campaign_category_relations"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"campaign_category_relations"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"campaign_category_relations"> | boolean
  }

  export type campaign_itemsWhereInput = {
    AND?: campaign_itemsWhereInput | campaign_itemsWhereInput[]
    OR?: campaign_itemsWhereInput[]
    NOT?: campaign_itemsWhereInput | campaign_itemsWhereInput[]
    id?: StringFilter<"campaign_items"> | string
    campaignId?: StringFilter<"campaign_items"> | string
    itemId?: StringFilter<"campaign_items"> | string
    itemType?: StringFilter<"campaign_items"> | string
    priority?: IntFilter<"campaign_items"> | number
    createdAt?: DateTimeFilter<"campaign_items"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_items"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_items"> | string | null
    is_deleted?: BoolFilter<"campaign_items"> | boolean
    campaigns?: XOR<CampaignsRelationFilter, campaignsWhereInput>
  }

  export type campaign_itemsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    campaigns?: campaignsOrderByWithRelationInput
  }

  export type campaign_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_itemId_itemType?: campaign_itemsCampaignIdItemIdItemTypeCompoundUniqueInput
    AND?: campaign_itemsWhereInput | campaign_itemsWhereInput[]
    OR?: campaign_itemsWhereInput[]
    NOT?: campaign_itemsWhereInput | campaign_itemsWhereInput[]
    campaignId?: StringFilter<"campaign_items"> | string
    itemId?: StringFilter<"campaign_items"> | string
    itemType?: StringFilter<"campaign_items"> | string
    priority?: IntFilter<"campaign_items"> | number
    createdAt?: DateTimeFilter<"campaign_items"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_items"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_items"> | string | null
    is_deleted?: BoolFilter<"campaign_items"> | boolean
    campaigns?: XOR<CampaignsRelationFilter, campaignsWhereInput>
  }, "id" | "campaignId_itemId_itemType">

  export type campaign_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: campaign_itemsCountOrderByAggregateInput
    _avg?: campaign_itemsAvgOrderByAggregateInput
    _max?: campaign_itemsMaxOrderByAggregateInput
    _min?: campaign_itemsMinOrderByAggregateInput
    _sum?: campaign_itemsSumOrderByAggregateInput
  }

  export type campaign_itemsScalarWhereWithAggregatesInput = {
    AND?: campaign_itemsScalarWhereWithAggregatesInput | campaign_itemsScalarWhereWithAggregatesInput[]
    OR?: campaign_itemsScalarWhereWithAggregatesInput[]
    NOT?: campaign_itemsScalarWhereWithAggregatesInput | campaign_itemsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"campaign_items"> | string
    campaignId?: StringWithAggregatesFilter<"campaign_items"> | string
    itemId?: StringWithAggregatesFilter<"campaign_items"> | string
    itemType?: StringWithAggregatesFilter<"campaign_items"> | string
    priority?: IntWithAggregatesFilter<"campaign_items"> | number
    createdAt?: DateTimeWithAggregatesFilter<"campaign_items"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"campaign_items"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"campaign_items"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"campaign_items"> | boolean
  }

  export type campaign_translationsWhereInput = {
    AND?: campaign_translationsWhereInput | campaign_translationsWhereInput[]
    OR?: campaign_translationsWhereInput[]
    NOT?: campaign_translationsWhereInput | campaign_translationsWhereInput[]
    id?: StringFilter<"campaign_translations"> | string
    campaignId?: StringFilter<"campaign_translations"> | string
    locale?: StringFilter<"campaign_translations"> | string
    title?: StringFilter<"campaign_translations"> | string
    description?: StringNullableFilter<"campaign_translations"> | string | null
    imageUrl?: StringNullableFilter<"campaign_translations"> | string | null
    languageCode?: StringNullableFilter<"campaign_translations"> | string | null
    name?: StringNullableFilter<"campaign_translations"> | string | null
    deleted_at?: DateTimeNullableFilter<"campaign_translations"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_translations"> | string | null
    is_deleted?: BoolFilter<"campaign_translations"> | boolean
    campaigns?: XOR<CampaignsRelationFilter, campaignsWhereInput>
  }

  export type campaign_translationsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    languageCode?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    campaigns?: campaignsOrderByWithRelationInput
  }

  export type campaign_translationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_locale?: campaign_translationsCampaignIdLocaleCompoundUniqueInput
    AND?: campaign_translationsWhereInput | campaign_translationsWhereInput[]
    OR?: campaign_translationsWhereInput[]
    NOT?: campaign_translationsWhereInput | campaign_translationsWhereInput[]
    campaignId?: StringFilter<"campaign_translations"> | string
    locale?: StringFilter<"campaign_translations"> | string
    title?: StringFilter<"campaign_translations"> | string
    description?: StringNullableFilter<"campaign_translations"> | string | null
    imageUrl?: StringNullableFilter<"campaign_translations"> | string | null
    languageCode?: StringNullableFilter<"campaign_translations"> | string | null
    name?: StringNullableFilter<"campaign_translations"> | string | null
    deleted_at?: DateTimeNullableFilter<"campaign_translations"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_translations"> | string | null
    is_deleted?: BoolFilter<"campaign_translations"> | boolean
    campaigns?: XOR<CampaignsRelationFilter, campaignsWhereInput>
  }, "id" | "campaignId_locale">

  export type campaign_translationsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    languageCode?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: campaign_translationsCountOrderByAggregateInput
    _max?: campaign_translationsMaxOrderByAggregateInput
    _min?: campaign_translationsMinOrderByAggregateInput
  }

  export type campaign_translationsScalarWhereWithAggregatesInput = {
    AND?: campaign_translationsScalarWhereWithAggregatesInput | campaign_translationsScalarWhereWithAggregatesInput[]
    OR?: campaign_translationsScalarWhereWithAggregatesInput[]
    NOT?: campaign_translationsScalarWhereWithAggregatesInput | campaign_translationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"campaign_translations"> | string
    campaignId?: StringWithAggregatesFilter<"campaign_translations"> | string
    locale?: StringWithAggregatesFilter<"campaign_translations"> | string
    title?: StringWithAggregatesFilter<"campaign_translations"> | string
    description?: StringNullableWithAggregatesFilter<"campaign_translations"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"campaign_translations"> | string | null
    languageCode?: StringNullableWithAggregatesFilter<"campaign_translations"> | string | null
    name?: StringNullableWithAggregatesFilter<"campaign_translations"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"campaign_translations"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"campaign_translations"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"campaign_translations"> | boolean
  }

  export type campaign_usage_logsWhereInput = {
    AND?: campaign_usage_logsWhereInput | campaign_usage_logsWhereInput[]
    OR?: campaign_usage_logsWhereInput[]
    NOT?: campaign_usage_logsWhereInput | campaign_usage_logsWhereInput[]
    id?: StringFilter<"campaign_usage_logs"> | string
    campaignId?: StringFilter<"campaign_usage_logs"> | string
    userId?: StringNullableFilter<"campaign_usage_logs"> | string | null
    deviceId?: StringNullableFilter<"campaign_usage_logs"> | string | null
    action?: StringFilter<"campaign_usage_logs"> | string
    createdAt?: DateTimeFilter<"campaign_usage_logs"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_usage_logs"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_usage_logs"> | string | null
    is_deleted?: BoolFilter<"campaign_usage_logs"> | boolean
    campaigns?: XOR<CampaignsRelationFilter, campaignsWhereInput>
  }

  export type campaign_usage_logsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    campaigns?: campaignsOrderByWithRelationInput
  }

  export type campaign_usage_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: campaign_usage_logsWhereInput | campaign_usage_logsWhereInput[]
    OR?: campaign_usage_logsWhereInput[]
    NOT?: campaign_usage_logsWhereInput | campaign_usage_logsWhereInput[]
    campaignId?: StringFilter<"campaign_usage_logs"> | string
    userId?: StringNullableFilter<"campaign_usage_logs"> | string | null
    deviceId?: StringNullableFilter<"campaign_usage_logs"> | string | null
    action?: StringFilter<"campaign_usage_logs"> | string
    createdAt?: DateTimeFilter<"campaign_usage_logs"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_usage_logs"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_usage_logs"> | string | null
    is_deleted?: BoolFilter<"campaign_usage_logs"> | boolean
    campaigns?: XOR<CampaignsRelationFilter, campaignsWhereInput>
  }, "id">

  export type campaign_usage_logsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: campaign_usage_logsCountOrderByAggregateInput
    _max?: campaign_usage_logsMaxOrderByAggregateInput
    _min?: campaign_usage_logsMinOrderByAggregateInput
  }

  export type campaign_usage_logsScalarWhereWithAggregatesInput = {
    AND?: campaign_usage_logsScalarWhereWithAggregatesInput | campaign_usage_logsScalarWhereWithAggregatesInput[]
    OR?: campaign_usage_logsScalarWhereWithAggregatesInput[]
    NOT?: campaign_usage_logsScalarWhereWithAggregatesInput | campaign_usage_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"campaign_usage_logs"> | string
    campaignId?: StringWithAggregatesFilter<"campaign_usage_logs"> | string
    userId?: StringNullableWithAggregatesFilter<"campaign_usage_logs"> | string | null
    deviceId?: StringNullableWithAggregatesFilter<"campaign_usage_logs"> | string | null
    action?: StringWithAggregatesFilter<"campaign_usage_logs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"campaign_usage_logs"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"campaign_usage_logs"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"campaign_usage_logs"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"campaign_usage_logs"> | boolean
  }

  export type campaignsWhereInput = {
    AND?: campaignsWhereInput | campaignsWhereInput[]
    OR?: campaignsWhereInput[]
    NOT?: campaignsWhereInput | campaignsWhereInput[]
    id?: StringFilter<"campaigns"> | string
    tenantId?: StringFilter<"campaigns"> | string
    code?: StringFilter<"campaigns"> | string
    status?: EnumCampaignStatusFilter<"campaigns"> | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFilter<"campaigns"> | $Enums.CampaignDisplayType
    startDate?: DateTimeNullableFilter<"campaigns"> | Date | string | null
    endDate?: DateTimeNullableFilter<"campaigns"> | Date | string | null
    priority?: IntFilter<"campaigns"> | number
    ctaType?: EnumCampaignCtaTypeFilter<"campaigns"> | $Enums.CampaignCtaType
    ctaAction?: StringNullableFilter<"campaigns"> | string | null
    ctaLabel?: StringNullableFilter<"campaigns"> | string | null
    discountType?: StringNullableFilter<"campaigns"> | string | null
    discountValue?: DecimalNullableFilter<"campaigns"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"campaigns"> | Date | string
    updatedAt?: DateTimeFilter<"campaigns"> | Date | string
    dayRestrictions?: JsonNullableFilter<"campaigns">
    description?: StringNullableFilter<"campaigns"> | string | null
    displayPriority?: IntFilter<"campaigns"> | number
    maxUsageCount?: IntNullableFilter<"campaigns"> | number | null
    name?: StringFilter<"campaigns"> | string
    timeRestrictions?: JsonNullableFilter<"campaigns">
    welcomeSettings?: JsonNullableFilter<"campaigns">
    deleted_at?: DateTimeNullableFilter<"campaigns"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaigns"> | string | null
    is_deleted?: BoolFilter<"campaigns"> | boolean
    campaign_category_relations?: Campaign_category_relationsListRelationFilter
    campaign_items?: Campaign_itemsListRelationFilter
    campaign_translations?: Campaign_translationsListRelationFilter
    campaign_usage_logs?: Campaign_usage_logsListRelationFilter
  }

  export type campaignsOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    displayType?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    priority?: SortOrder
    ctaType?: SortOrder
    ctaAction?: SortOrderInput | SortOrder
    ctaLabel?: SortOrderInput | SortOrder
    discountType?: SortOrderInput | SortOrder
    discountValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayRestrictions?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    displayPriority?: SortOrder
    maxUsageCount?: SortOrderInput | SortOrder
    name?: SortOrder
    timeRestrictions?: SortOrderInput | SortOrder
    welcomeSettings?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    campaign_category_relations?: campaign_category_relationsOrderByRelationAggregateInput
    campaign_items?: campaign_itemsOrderByRelationAggregateInput
    campaign_translations?: campaign_translationsOrderByRelationAggregateInput
    campaign_usage_logs?: campaign_usage_logsOrderByRelationAggregateInput
  }

  export type campaignsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: campaignsWhereInput | campaignsWhereInput[]
    OR?: campaignsWhereInput[]
    NOT?: campaignsWhereInput | campaignsWhereInput[]
    tenantId?: StringFilter<"campaigns"> | string
    status?: EnumCampaignStatusFilter<"campaigns"> | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFilter<"campaigns"> | $Enums.CampaignDisplayType
    startDate?: DateTimeNullableFilter<"campaigns"> | Date | string | null
    endDate?: DateTimeNullableFilter<"campaigns"> | Date | string | null
    priority?: IntFilter<"campaigns"> | number
    ctaType?: EnumCampaignCtaTypeFilter<"campaigns"> | $Enums.CampaignCtaType
    ctaAction?: StringNullableFilter<"campaigns"> | string | null
    ctaLabel?: StringNullableFilter<"campaigns"> | string | null
    discountType?: StringNullableFilter<"campaigns"> | string | null
    discountValue?: DecimalNullableFilter<"campaigns"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"campaigns"> | Date | string
    updatedAt?: DateTimeFilter<"campaigns"> | Date | string
    dayRestrictions?: JsonNullableFilter<"campaigns">
    description?: StringNullableFilter<"campaigns"> | string | null
    displayPriority?: IntFilter<"campaigns"> | number
    maxUsageCount?: IntNullableFilter<"campaigns"> | number | null
    name?: StringFilter<"campaigns"> | string
    timeRestrictions?: JsonNullableFilter<"campaigns">
    welcomeSettings?: JsonNullableFilter<"campaigns">
    deleted_at?: DateTimeNullableFilter<"campaigns"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaigns"> | string | null
    is_deleted?: BoolFilter<"campaigns"> | boolean
    campaign_category_relations?: Campaign_category_relationsListRelationFilter
    campaign_items?: Campaign_itemsListRelationFilter
    campaign_translations?: Campaign_translationsListRelationFilter
    campaign_usage_logs?: Campaign_usage_logsListRelationFilter
  }, "id" | "code">

  export type campaignsOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    displayType?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    priority?: SortOrder
    ctaType?: SortOrder
    ctaAction?: SortOrderInput | SortOrder
    ctaLabel?: SortOrderInput | SortOrder
    discountType?: SortOrderInput | SortOrder
    discountValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayRestrictions?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    displayPriority?: SortOrder
    maxUsageCount?: SortOrderInput | SortOrder
    name?: SortOrder
    timeRestrictions?: SortOrderInput | SortOrder
    welcomeSettings?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: campaignsCountOrderByAggregateInput
    _avg?: campaignsAvgOrderByAggregateInput
    _max?: campaignsMaxOrderByAggregateInput
    _min?: campaignsMinOrderByAggregateInput
    _sum?: campaignsSumOrderByAggregateInput
  }

  export type campaignsScalarWhereWithAggregatesInput = {
    AND?: campaignsScalarWhereWithAggregatesInput | campaignsScalarWhereWithAggregatesInput[]
    OR?: campaignsScalarWhereWithAggregatesInput[]
    NOT?: campaignsScalarWhereWithAggregatesInput | campaignsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"campaigns"> | string
    tenantId?: StringWithAggregatesFilter<"campaigns"> | string
    code?: StringWithAggregatesFilter<"campaigns"> | string
    status?: EnumCampaignStatusWithAggregatesFilter<"campaigns"> | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeWithAggregatesFilter<"campaigns"> | $Enums.CampaignDisplayType
    startDate?: DateTimeNullableWithAggregatesFilter<"campaigns"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"campaigns"> | Date | string | null
    priority?: IntWithAggregatesFilter<"campaigns"> | number
    ctaType?: EnumCampaignCtaTypeWithAggregatesFilter<"campaigns"> | $Enums.CampaignCtaType
    ctaAction?: StringNullableWithAggregatesFilter<"campaigns"> | string | null
    ctaLabel?: StringNullableWithAggregatesFilter<"campaigns"> | string | null
    discountType?: StringNullableWithAggregatesFilter<"campaigns"> | string | null
    discountValue?: DecimalNullableWithAggregatesFilter<"campaigns"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"campaigns"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"campaigns"> | Date | string
    dayRestrictions?: JsonNullableWithAggregatesFilter<"campaigns">
    description?: StringNullableWithAggregatesFilter<"campaigns"> | string | null
    displayPriority?: IntWithAggregatesFilter<"campaigns"> | number
    maxUsageCount?: IntNullableWithAggregatesFilter<"campaigns"> | number | null
    name?: StringWithAggregatesFilter<"campaigns"> | string
    timeRestrictions?: JsonNullableWithAggregatesFilter<"campaigns">
    welcomeSettings?: JsonNullableWithAggregatesFilter<"campaigns">
    deleted_at?: DateTimeNullableWithAggregatesFilter<"campaigns"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"campaigns"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"campaigns"> | boolean
  }

  export type customersWhereInput = {
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    id?: StringFilter<"customers"> | string
    tenant_id?: StringFilter<"customers"> | string
    name?: StringFilter<"customers"> | string
    email?: StringNullableFilter<"customers"> | string | null
    phone?: StringNullableFilter<"customers"> | string | null
    address?: StringNullableFilter<"customers"> | string | null
    birth_date?: DateTimeNullableFilter<"customers"> | Date | string | null
    member_id?: StringNullableFilter<"customers"> | string | null
    rank_id?: StringNullableFilter<"customers"> | string | null
    total_points?: IntFilter<"customers"> | number
    total_stays?: IntFilter<"customers"> | number
    pms_updatable_fields?: StringNullableListFilter<"customers">
    origin_system?: StringFilter<"customers"> | string
    synced_at?: DateTimeFilter<"customers"> | Date | string
    updated_by_system?: StringFilter<"customers"> | string
    preferences?: JsonFilter<"customers">
    created_at?: DateTimeFilter<"customers"> | Date | string
    updated_at?: DateTimeFilter<"customers"> | Date | string
    deleted_at?: DateTimeNullableFilter<"customers"> | Date | string | null
    is_deleted?: BoolFilter<"customers"> | boolean
    deleted_by?: StringNullableFilter<"customers"> | string | null
    reservations?: ReservationsListRelationFilter
  }

  export type customersOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    member_id?: SortOrderInput | SortOrder
    rank_id?: SortOrderInput | SortOrder
    total_points?: SortOrder
    total_stays?: SortOrder
    pms_updatable_fields?: SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    preferences?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrderInput | SortOrder
    reservations?: reservationsOrderByRelationAggregateInput
  }

  export type customersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    tenant_id?: StringFilter<"customers"> | string
    name?: StringFilter<"customers"> | string
    email?: StringNullableFilter<"customers"> | string | null
    phone?: StringNullableFilter<"customers"> | string | null
    address?: StringNullableFilter<"customers"> | string | null
    birth_date?: DateTimeNullableFilter<"customers"> | Date | string | null
    member_id?: StringNullableFilter<"customers"> | string | null
    rank_id?: StringNullableFilter<"customers"> | string | null
    total_points?: IntFilter<"customers"> | number
    total_stays?: IntFilter<"customers"> | number
    pms_updatable_fields?: StringNullableListFilter<"customers">
    origin_system?: StringFilter<"customers"> | string
    synced_at?: DateTimeFilter<"customers"> | Date | string
    updated_by_system?: StringFilter<"customers"> | string
    preferences?: JsonFilter<"customers">
    created_at?: DateTimeFilter<"customers"> | Date | string
    updated_at?: DateTimeFilter<"customers"> | Date | string
    deleted_at?: DateTimeNullableFilter<"customers"> | Date | string | null
    is_deleted?: BoolFilter<"customers"> | boolean
    deleted_by?: StringNullableFilter<"customers"> | string | null
    reservations?: ReservationsListRelationFilter
  }, "id">

  export type customersOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    member_id?: SortOrderInput | SortOrder
    rank_id?: SortOrderInput | SortOrder
    total_points?: SortOrder
    total_stays?: SortOrder
    pms_updatable_fields?: SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    preferences?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrderInput | SortOrder
    _count?: customersCountOrderByAggregateInput
    _avg?: customersAvgOrderByAggregateInput
    _max?: customersMaxOrderByAggregateInput
    _min?: customersMinOrderByAggregateInput
    _sum?: customersSumOrderByAggregateInput
  }

  export type customersScalarWhereWithAggregatesInput = {
    AND?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    OR?: customersScalarWhereWithAggregatesInput[]
    NOT?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"customers"> | string
    tenant_id?: StringWithAggregatesFilter<"customers"> | string
    name?: StringWithAggregatesFilter<"customers"> | string
    email?: StringNullableWithAggregatesFilter<"customers"> | string | null
    phone?: StringNullableWithAggregatesFilter<"customers"> | string | null
    address?: StringNullableWithAggregatesFilter<"customers"> | string | null
    birth_date?: DateTimeNullableWithAggregatesFilter<"customers"> | Date | string | null
    member_id?: StringNullableWithAggregatesFilter<"customers"> | string | null
    rank_id?: StringNullableWithAggregatesFilter<"customers"> | string | null
    total_points?: IntWithAggregatesFilter<"customers"> | number
    total_stays?: IntWithAggregatesFilter<"customers"> | number
    pms_updatable_fields?: StringNullableListFilter<"customers">
    origin_system?: StringWithAggregatesFilter<"customers"> | string
    synced_at?: DateTimeWithAggregatesFilter<"customers"> | Date | string
    updated_by_system?: StringWithAggregatesFilter<"customers"> | string
    preferences?: JsonWithAggregatesFilter<"customers">
    created_at?: DateTimeWithAggregatesFilter<"customers"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"customers"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"customers"> | Date | string | null
    is_deleted?: BoolWithAggregatesFilter<"customers"> | boolean
    deleted_by?: StringNullableWithAggregatesFilter<"customers"> | string | null
  }

  export type device_roomsWhereInput = {
    AND?: device_roomsWhereInput | device_roomsWhereInput[]
    OR?: device_roomsWhereInput[]
    NOT?: device_roomsWhereInput | device_roomsWhereInput[]
    id?: IntFilter<"device_rooms"> | number
    tenantId?: StringFilter<"device_rooms"> | string
    roomId?: StringFilter<"device_rooms"> | string
    roomName?: StringNullableFilter<"device_rooms"> | string | null
    deviceId?: StringNullableFilter<"device_rooms"> | string | null
    deviceType?: StringNullableFilter<"device_rooms"> | string | null
    placeId?: StringNullableFilter<"device_rooms"> | string | null
    status?: StringNullableFilter<"device_rooms"> | string | null
    ipAddress?: StringNullableFilter<"device_rooms"> | string | null
    macAddress?: StringNullableFilter<"device_rooms"> | string | null
    lastUsedAt?: DateTimeNullableFilter<"device_rooms"> | Date | string | null
    isActive?: BoolFilter<"device_rooms"> | boolean
    createdAt?: DateTimeFilter<"device_rooms"> | Date | string
    updatedAt?: DateTimeFilter<"device_rooms"> | Date | string
    is_deleted?: BoolFilter<"device_rooms"> | boolean
    deleted_at?: DateTimeNullableFilter<"device_rooms"> | Date | string | null
    deleted_by?: StringNullableFilter<"device_rooms"> | string | null
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type device_roomsOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    placeId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    macAddress?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    Tenant?: TenantOrderByWithRelationInput
  }

  export type device_roomsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: device_roomsWhereInput | device_roomsWhereInput[]
    OR?: device_roomsWhereInput[]
    NOT?: device_roomsWhereInput | device_roomsWhereInput[]
    tenantId?: StringFilter<"device_rooms"> | string
    roomId?: StringFilter<"device_rooms"> | string
    roomName?: StringNullableFilter<"device_rooms"> | string | null
    deviceId?: StringNullableFilter<"device_rooms"> | string | null
    deviceType?: StringNullableFilter<"device_rooms"> | string | null
    placeId?: StringNullableFilter<"device_rooms"> | string | null
    status?: StringNullableFilter<"device_rooms"> | string | null
    ipAddress?: StringNullableFilter<"device_rooms"> | string | null
    macAddress?: StringNullableFilter<"device_rooms"> | string | null
    lastUsedAt?: DateTimeNullableFilter<"device_rooms"> | Date | string | null
    isActive?: BoolFilter<"device_rooms"> | boolean
    createdAt?: DateTimeFilter<"device_rooms"> | Date | string
    updatedAt?: DateTimeFilter<"device_rooms"> | Date | string
    is_deleted?: BoolFilter<"device_rooms"> | boolean
    deleted_at?: DateTimeNullableFilter<"device_rooms"> | Date | string | null
    deleted_by?: StringNullableFilter<"device_rooms"> | string | null
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type device_roomsOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    placeId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    macAddress?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    _count?: device_roomsCountOrderByAggregateInput
    _avg?: device_roomsAvgOrderByAggregateInput
    _max?: device_roomsMaxOrderByAggregateInput
    _min?: device_roomsMinOrderByAggregateInput
    _sum?: device_roomsSumOrderByAggregateInput
  }

  export type device_roomsScalarWhereWithAggregatesInput = {
    AND?: device_roomsScalarWhereWithAggregatesInput | device_roomsScalarWhereWithAggregatesInput[]
    OR?: device_roomsScalarWhereWithAggregatesInput[]
    NOT?: device_roomsScalarWhereWithAggregatesInput | device_roomsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"device_rooms"> | number
    tenantId?: StringWithAggregatesFilter<"device_rooms"> | string
    roomId?: StringWithAggregatesFilter<"device_rooms"> | string
    roomName?: StringNullableWithAggregatesFilter<"device_rooms"> | string | null
    deviceId?: StringNullableWithAggregatesFilter<"device_rooms"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"device_rooms"> | string | null
    placeId?: StringNullableWithAggregatesFilter<"device_rooms"> | string | null
    status?: StringNullableWithAggregatesFilter<"device_rooms"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"device_rooms"> | string | null
    macAddress?: StringNullableWithAggregatesFilter<"device_rooms"> | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"device_rooms"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"device_rooms"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"device_rooms"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"device_rooms"> | Date | string
    is_deleted?: BoolWithAggregatesFilter<"device_rooms"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"device_rooms"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"device_rooms"> | string | null
  }

  export type device_video_cachesWhereInput = {
    AND?: device_video_cachesWhereInput | device_video_cachesWhereInput[]
    OR?: device_video_cachesWhereInput[]
    NOT?: device_video_cachesWhereInput | device_video_cachesWhereInput[]
    id?: StringFilter<"device_video_caches"> | string
    deviceId?: StringFilter<"device_video_caches"> | string
    videoIds?: StringNullableListFilter<"device_video_caches">
    lastShownAt?: DateTimeFilter<"device_video_caches"> | Date | string
    updatedAt?: DateTimeFilter<"device_video_caches"> | Date | string
    lastViewedAt?: DateTimeNullableFilter<"device_video_caches"> | Date | string | null
    userId?: StringNullableFilter<"device_video_caches"> | string | null
    viewed?: BoolFilter<"device_video_caches"> | boolean
    deleted_at?: DateTimeNullableFilter<"device_video_caches"> | Date | string | null
    deleted_by?: StringNullableFilter<"device_video_caches"> | string | null
    is_deleted?: BoolFilter<"device_video_caches"> | boolean
  }

  export type device_video_cachesOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    videoIds?: SortOrder
    lastShownAt?: SortOrder
    updatedAt?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    viewed?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
  }

  export type device_video_cachesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceId_userId?: device_video_cachesDeviceIdUserIdCompoundUniqueInput
    AND?: device_video_cachesWhereInput | device_video_cachesWhereInput[]
    OR?: device_video_cachesWhereInput[]
    NOT?: device_video_cachesWhereInput | device_video_cachesWhereInput[]
    deviceId?: StringFilter<"device_video_caches"> | string
    videoIds?: StringNullableListFilter<"device_video_caches">
    lastShownAt?: DateTimeFilter<"device_video_caches"> | Date | string
    updatedAt?: DateTimeFilter<"device_video_caches"> | Date | string
    lastViewedAt?: DateTimeNullableFilter<"device_video_caches"> | Date | string | null
    userId?: StringNullableFilter<"device_video_caches"> | string | null
    viewed?: BoolFilter<"device_video_caches"> | boolean
    deleted_at?: DateTimeNullableFilter<"device_video_caches"> | Date | string | null
    deleted_by?: StringNullableFilter<"device_video_caches"> | string | null
    is_deleted?: BoolFilter<"device_video_caches"> | boolean
  }, "id" | "deviceId_userId">

  export type device_video_cachesOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    videoIds?: SortOrder
    lastShownAt?: SortOrder
    updatedAt?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    viewed?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: device_video_cachesCountOrderByAggregateInput
    _max?: device_video_cachesMaxOrderByAggregateInput
    _min?: device_video_cachesMinOrderByAggregateInput
  }

  export type device_video_cachesScalarWhereWithAggregatesInput = {
    AND?: device_video_cachesScalarWhereWithAggregatesInput | device_video_cachesScalarWhereWithAggregatesInput[]
    OR?: device_video_cachesScalarWhereWithAggregatesInput[]
    NOT?: device_video_cachesScalarWhereWithAggregatesInput | device_video_cachesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"device_video_caches"> | string
    deviceId?: StringWithAggregatesFilter<"device_video_caches"> | string
    videoIds?: StringNullableListFilter<"device_video_caches">
    lastShownAt?: DateTimeWithAggregatesFilter<"device_video_caches"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"device_video_caches"> | Date | string
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"device_video_caches"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"device_video_caches"> | string | null
    viewed?: BoolWithAggregatesFilter<"device_video_caches"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"device_video_caches"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"device_video_caches"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"device_video_caches"> | boolean
  }

  export type notification_templatesWhereInput = {
    AND?: notification_templatesWhereInput | notification_templatesWhereInput[]
    OR?: notification_templatesWhereInput[]
    NOT?: notification_templatesWhereInput | notification_templatesWhereInput[]
    id?: StringFilter<"notification_templates"> | string
    tenant_id?: StringFilter<"notification_templates"> | string
    type?: StringFilter<"notification_templates"> | string
    code?: StringFilter<"notification_templates"> | string
    subject?: StringNullableFilter<"notification_templates"> | string | null
    content?: StringFilter<"notification_templates"> | string
    variables?: StringNullableListFilter<"notification_templates">
    is_active?: BoolFilter<"notification_templates"> | boolean
    created_at?: DateTimeFilter<"notification_templates"> | Date | string
    updated_at?: DateTimeFilter<"notification_templates"> | Date | string
    body?: StringFilter<"notification_templates"> | string
    html?: BoolFilter<"notification_templates"> | boolean
    locale?: StringFilter<"notification_templates"> | string
    deleted_at?: DateTimeNullableFilter<"notification_templates"> | Date | string | null
    deleted_by?: StringNullableFilter<"notification_templates"> | string | null
    is_deleted?: BoolFilter<"notification_templates"> | boolean
  }

  export type notification_templatesOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    variables?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    body?: SortOrder
    html?: SortOrder
    locale?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
  }

  export type notification_templatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_type_code_locale?: notification_templatesTenant_idTypeCodeLocaleCompoundUniqueInput
    AND?: notification_templatesWhereInput | notification_templatesWhereInput[]
    OR?: notification_templatesWhereInput[]
    NOT?: notification_templatesWhereInput | notification_templatesWhereInput[]
    tenant_id?: StringFilter<"notification_templates"> | string
    type?: StringFilter<"notification_templates"> | string
    code?: StringFilter<"notification_templates"> | string
    subject?: StringNullableFilter<"notification_templates"> | string | null
    content?: StringFilter<"notification_templates"> | string
    variables?: StringNullableListFilter<"notification_templates">
    is_active?: BoolFilter<"notification_templates"> | boolean
    created_at?: DateTimeFilter<"notification_templates"> | Date | string
    updated_at?: DateTimeFilter<"notification_templates"> | Date | string
    body?: StringFilter<"notification_templates"> | string
    html?: BoolFilter<"notification_templates"> | boolean
    locale?: StringFilter<"notification_templates"> | string
    deleted_at?: DateTimeNullableFilter<"notification_templates"> | Date | string | null
    deleted_by?: StringNullableFilter<"notification_templates"> | string | null
    is_deleted?: BoolFilter<"notification_templates"> | boolean
  }, "id" | "tenant_id_type_code_locale">

  export type notification_templatesOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    variables?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    body?: SortOrder
    html?: SortOrder
    locale?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: notification_templatesCountOrderByAggregateInput
    _max?: notification_templatesMaxOrderByAggregateInput
    _min?: notification_templatesMinOrderByAggregateInput
  }

  export type notification_templatesScalarWhereWithAggregatesInput = {
    AND?: notification_templatesScalarWhereWithAggregatesInput | notification_templatesScalarWhereWithAggregatesInput[]
    OR?: notification_templatesScalarWhereWithAggregatesInput[]
    NOT?: notification_templatesScalarWhereWithAggregatesInput | notification_templatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification_templates"> | string
    tenant_id?: StringWithAggregatesFilter<"notification_templates"> | string
    type?: StringWithAggregatesFilter<"notification_templates"> | string
    code?: StringWithAggregatesFilter<"notification_templates"> | string
    subject?: StringNullableWithAggregatesFilter<"notification_templates"> | string | null
    content?: StringWithAggregatesFilter<"notification_templates"> | string
    variables?: StringNullableListFilter<"notification_templates">
    is_active?: BoolWithAggregatesFilter<"notification_templates"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"notification_templates"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"notification_templates"> | Date | string
    body?: StringWithAggregatesFilter<"notification_templates"> | string
    html?: BoolWithAggregatesFilter<"notification_templates"> | boolean
    locale?: StringWithAggregatesFilter<"notification_templates"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"notification_templates"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"notification_templates"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"notification_templates"> | boolean
  }

  export type page_historiesWhereInput = {
    AND?: page_historiesWhereInput | page_historiesWhereInput[]
    OR?: page_historiesWhereInput[]
    NOT?: page_historiesWhereInput | page_historiesWhereInput[]
    Id?: StringFilter<"page_histories"> | string
    PageId?: StringFilter<"page_histories"> | string
    Html?: StringNullableFilter<"page_histories"> | string | null
    Css?: StringNullableFilter<"page_histories"> | string | null
    Content?: StringNullableFilter<"page_histories"> | string | null
    Template?: StringNullableFilter<"page_histories"> | string | null
    Version?: IntFilter<"page_histories"> | number
    CreatedAt?: DateTimeFilter<"page_histories"> | Date | string
    CreatedBy?: StringNullableFilter<"page_histories"> | string | null
    deleted_at?: DateTimeNullableFilter<"page_histories"> | Date | string | null
    deleted_by?: StringNullableFilter<"page_histories"> | string | null
    is_deleted?: BoolFilter<"page_histories"> | boolean
    pages?: XOR<PagesRelationFilter, pagesWhereInput>
  }

  export type page_historiesOrderByWithRelationInput = {
    Id?: SortOrder
    PageId?: SortOrder
    Html?: SortOrderInput | SortOrder
    Css?: SortOrderInput | SortOrder
    Content?: SortOrderInput | SortOrder
    Template?: SortOrderInput | SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    CreatedBy?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    pages?: pagesOrderByWithRelationInput
  }

  export type page_historiesWhereUniqueInput = Prisma.AtLeast<{
    Id?: string
    AND?: page_historiesWhereInput | page_historiesWhereInput[]
    OR?: page_historiesWhereInput[]
    NOT?: page_historiesWhereInput | page_historiesWhereInput[]
    PageId?: StringFilter<"page_histories"> | string
    Html?: StringNullableFilter<"page_histories"> | string | null
    Css?: StringNullableFilter<"page_histories"> | string | null
    Content?: StringNullableFilter<"page_histories"> | string | null
    Template?: StringNullableFilter<"page_histories"> | string | null
    Version?: IntFilter<"page_histories"> | number
    CreatedAt?: DateTimeFilter<"page_histories"> | Date | string
    CreatedBy?: StringNullableFilter<"page_histories"> | string | null
    deleted_at?: DateTimeNullableFilter<"page_histories"> | Date | string | null
    deleted_by?: StringNullableFilter<"page_histories"> | string | null
    is_deleted?: BoolFilter<"page_histories"> | boolean
    pages?: XOR<PagesRelationFilter, pagesWhereInput>
  }, "Id">

  export type page_historiesOrderByWithAggregationInput = {
    Id?: SortOrder
    PageId?: SortOrder
    Html?: SortOrderInput | SortOrder
    Css?: SortOrderInput | SortOrder
    Content?: SortOrderInput | SortOrder
    Template?: SortOrderInput | SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    CreatedBy?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: page_historiesCountOrderByAggregateInput
    _avg?: page_historiesAvgOrderByAggregateInput
    _max?: page_historiesMaxOrderByAggregateInput
    _min?: page_historiesMinOrderByAggregateInput
    _sum?: page_historiesSumOrderByAggregateInput
  }

  export type page_historiesScalarWhereWithAggregatesInput = {
    AND?: page_historiesScalarWhereWithAggregatesInput | page_historiesScalarWhereWithAggregatesInput[]
    OR?: page_historiesScalarWhereWithAggregatesInput[]
    NOT?: page_historiesScalarWhereWithAggregatesInput | page_historiesScalarWhereWithAggregatesInput[]
    Id?: StringWithAggregatesFilter<"page_histories"> | string
    PageId?: StringWithAggregatesFilter<"page_histories"> | string
    Html?: StringNullableWithAggregatesFilter<"page_histories"> | string | null
    Css?: StringNullableWithAggregatesFilter<"page_histories"> | string | null
    Content?: StringNullableWithAggregatesFilter<"page_histories"> | string | null
    Template?: StringNullableWithAggregatesFilter<"page_histories"> | string | null
    Version?: IntWithAggregatesFilter<"page_histories"> | number
    CreatedAt?: DateTimeWithAggregatesFilter<"page_histories"> | Date | string
    CreatedBy?: StringNullableWithAggregatesFilter<"page_histories"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"page_histories"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"page_histories"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"page_histories"> | boolean
  }

  export type pagesWhereInput = {
    AND?: pagesWhereInput | pagesWhereInput[]
    OR?: pagesWhereInput[]
    NOT?: pagesWhereInput | pagesWhereInput[]
    Id?: StringFilter<"pages"> | string
    TenantId?: StringFilter<"pages"> | string
    Slug?: StringFilter<"pages"> | string
    Title?: StringFilter<"pages"> | string
    Html?: StringNullableFilter<"pages"> | string | null
    Css?: StringNullableFilter<"pages"> | string | null
    Content?: StringNullableFilter<"pages"> | string | null
    Template?: StringNullableFilter<"pages"> | string | null
    IsPublished?: BoolFilter<"pages"> | boolean
    PublishedAt?: DateTimeNullableFilter<"pages"> | Date | string | null
    Version?: IntFilter<"pages"> | number
    CreatedAt?: DateTimeFilter<"pages"> | Date | string
    UpdatedAt?: DateTimeFilter<"pages"> | Date | string
    deleted_at?: DateTimeNullableFilter<"pages"> | Date | string | null
    deleted_by?: StringNullableFilter<"pages"> | string | null
    is_deleted?: BoolFilter<"pages"> | boolean
    page_histories?: Page_historiesListRelationFilter
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type pagesOrderByWithRelationInput = {
    Id?: SortOrder
    TenantId?: SortOrder
    Slug?: SortOrder
    Title?: SortOrder
    Html?: SortOrderInput | SortOrder
    Css?: SortOrderInput | SortOrder
    Content?: SortOrderInput | SortOrder
    Template?: SortOrderInput | SortOrder
    IsPublished?: SortOrder
    PublishedAt?: SortOrderInput | SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    page_histories?: page_historiesOrderByRelationAggregateInput
    Tenant?: TenantOrderByWithRelationInput
  }

  export type pagesWhereUniqueInput = Prisma.AtLeast<{
    Id?: string
    TenantId_Slug?: pagesTenantIdSlugCompoundUniqueInput
    AND?: pagesWhereInput | pagesWhereInput[]
    OR?: pagesWhereInput[]
    NOT?: pagesWhereInput | pagesWhereInput[]
    TenantId?: StringFilter<"pages"> | string
    Slug?: StringFilter<"pages"> | string
    Title?: StringFilter<"pages"> | string
    Html?: StringNullableFilter<"pages"> | string | null
    Css?: StringNullableFilter<"pages"> | string | null
    Content?: StringNullableFilter<"pages"> | string | null
    Template?: StringNullableFilter<"pages"> | string | null
    IsPublished?: BoolFilter<"pages"> | boolean
    PublishedAt?: DateTimeNullableFilter<"pages"> | Date | string | null
    Version?: IntFilter<"pages"> | number
    CreatedAt?: DateTimeFilter<"pages"> | Date | string
    UpdatedAt?: DateTimeFilter<"pages"> | Date | string
    deleted_at?: DateTimeNullableFilter<"pages"> | Date | string | null
    deleted_by?: StringNullableFilter<"pages"> | string | null
    is_deleted?: BoolFilter<"pages"> | boolean
    page_histories?: Page_historiesListRelationFilter
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "Id" | "TenantId_Slug">

  export type pagesOrderByWithAggregationInput = {
    Id?: SortOrder
    TenantId?: SortOrder
    Slug?: SortOrder
    Title?: SortOrder
    Html?: SortOrderInput | SortOrder
    Css?: SortOrderInput | SortOrder
    Content?: SortOrderInput | SortOrder
    Template?: SortOrderInput | SortOrder
    IsPublished?: SortOrder
    PublishedAt?: SortOrderInput | SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: pagesCountOrderByAggregateInput
    _avg?: pagesAvgOrderByAggregateInput
    _max?: pagesMaxOrderByAggregateInput
    _min?: pagesMinOrderByAggregateInput
    _sum?: pagesSumOrderByAggregateInput
  }

  export type pagesScalarWhereWithAggregatesInput = {
    AND?: pagesScalarWhereWithAggregatesInput | pagesScalarWhereWithAggregatesInput[]
    OR?: pagesScalarWhereWithAggregatesInput[]
    NOT?: pagesScalarWhereWithAggregatesInput | pagesScalarWhereWithAggregatesInput[]
    Id?: StringWithAggregatesFilter<"pages"> | string
    TenantId?: StringWithAggregatesFilter<"pages"> | string
    Slug?: StringWithAggregatesFilter<"pages"> | string
    Title?: StringWithAggregatesFilter<"pages"> | string
    Html?: StringNullableWithAggregatesFilter<"pages"> | string | null
    Css?: StringNullableWithAggregatesFilter<"pages"> | string | null
    Content?: StringNullableWithAggregatesFilter<"pages"> | string | null
    Template?: StringNullableWithAggregatesFilter<"pages"> | string | null
    IsPublished?: BoolWithAggregatesFilter<"pages"> | boolean
    PublishedAt?: DateTimeNullableWithAggregatesFilter<"pages"> | Date | string | null
    Version?: IntWithAggregatesFilter<"pages"> | number
    CreatedAt?: DateTimeWithAggregatesFilter<"pages"> | Date | string
    UpdatedAt?: DateTimeWithAggregatesFilter<"pages"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"pages"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"pages"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"pages"> | boolean
  }

  export type reservationsWhereInput = {
    AND?: reservationsWhereInput | reservationsWhereInput[]
    OR?: reservationsWhereInput[]
    NOT?: reservationsWhereInput | reservationsWhereInput[]
    id?: StringFilter<"reservations"> | string
    tenant_id?: StringFilter<"reservations"> | string
    customer_id?: StringNullableFilter<"reservations"> | string | null
    guest_name?: StringFilter<"reservations"> | string
    guest_phone?: StringNullableFilter<"reservations"> | string | null
    guest_email?: StringNullableFilter<"reservations"> | string | null
    checkin_date?: DateTimeFilter<"reservations"> | Date | string
    checkout_date?: DateTimeFilter<"reservations"> | Date | string
    adult_count?: IntFilter<"reservations"> | number
    child_count?: IntFilter<"reservations"> | number
    room_type?: StringFilter<"reservations"> | string
    room_number?: StringNullableFilter<"reservations"> | string | null
    total_amount?: DecimalFilter<"reservations"> | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFilter<"reservations"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"reservations"> | string
    origin?: StringFilter<"reservations"> | string
    ota_id?: StringNullableFilter<"reservations"> | string | null
    confirmation_number?: StringFilter<"reservations"> | string
    special_requests?: StringNullableFilter<"reservations"> | string | null
    internal_notes?: StringNullableFilter<"reservations"> | string | null
    origin_system?: StringFilter<"reservations"> | string
    synced_at?: DateTimeFilter<"reservations"> | Date | string
    updated_by_system?: StringFilter<"reservations"> | string
    created_at?: DateTimeFilter<"reservations"> | Date | string
    updated_at?: DateTimeFilter<"reservations"> | Date | string
    deleted_at?: DateTimeNullableFilter<"reservations"> | Date | string | null
    is_deleted?: BoolFilter<"reservations"> | boolean
    deleted_by?: StringNullableFilter<"reservations"> | string | null
    customers?: XOR<CustomersNullableRelationFilter, customersWhereInput> | null
  }

  export type reservationsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    guest_name?: SortOrder
    guest_phone?: SortOrderInput | SortOrder
    guest_email?: SortOrderInput | SortOrder
    checkin_date?: SortOrder
    checkout_date?: SortOrder
    adult_count?: SortOrder
    child_count?: SortOrder
    room_type?: SortOrder
    room_number?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    deposit_amount?: SortOrder
    status?: SortOrder
    origin?: SortOrder
    ota_id?: SortOrderInput | SortOrder
    confirmation_number?: SortOrder
    special_requests?: SortOrderInput | SortOrder
    internal_notes?: SortOrderInput | SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrderInput | SortOrder
    customers?: customersOrderByWithRelationInput
  }

  export type reservationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reservationsWhereInput | reservationsWhereInput[]
    OR?: reservationsWhereInput[]
    NOT?: reservationsWhereInput | reservationsWhereInput[]
    tenant_id?: StringFilter<"reservations"> | string
    customer_id?: StringNullableFilter<"reservations"> | string | null
    guest_name?: StringFilter<"reservations"> | string
    guest_phone?: StringNullableFilter<"reservations"> | string | null
    guest_email?: StringNullableFilter<"reservations"> | string | null
    checkin_date?: DateTimeFilter<"reservations"> | Date | string
    checkout_date?: DateTimeFilter<"reservations"> | Date | string
    adult_count?: IntFilter<"reservations"> | number
    child_count?: IntFilter<"reservations"> | number
    room_type?: StringFilter<"reservations"> | string
    room_number?: StringNullableFilter<"reservations"> | string | null
    total_amount?: DecimalFilter<"reservations"> | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFilter<"reservations"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"reservations"> | string
    origin?: StringFilter<"reservations"> | string
    ota_id?: StringNullableFilter<"reservations"> | string | null
    confirmation_number?: StringFilter<"reservations"> | string
    special_requests?: StringNullableFilter<"reservations"> | string | null
    internal_notes?: StringNullableFilter<"reservations"> | string | null
    origin_system?: StringFilter<"reservations"> | string
    synced_at?: DateTimeFilter<"reservations"> | Date | string
    updated_by_system?: StringFilter<"reservations"> | string
    created_at?: DateTimeFilter<"reservations"> | Date | string
    updated_at?: DateTimeFilter<"reservations"> | Date | string
    deleted_at?: DateTimeNullableFilter<"reservations"> | Date | string | null
    is_deleted?: BoolFilter<"reservations"> | boolean
    deleted_by?: StringNullableFilter<"reservations"> | string | null
    customers?: XOR<CustomersNullableRelationFilter, customersWhereInput> | null
  }, "id">

  export type reservationsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    guest_name?: SortOrder
    guest_phone?: SortOrderInput | SortOrder
    guest_email?: SortOrderInput | SortOrder
    checkin_date?: SortOrder
    checkout_date?: SortOrder
    adult_count?: SortOrder
    child_count?: SortOrder
    room_type?: SortOrder
    room_number?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    deposit_amount?: SortOrder
    status?: SortOrder
    origin?: SortOrder
    ota_id?: SortOrderInput | SortOrder
    confirmation_number?: SortOrder
    special_requests?: SortOrderInput | SortOrder
    internal_notes?: SortOrderInput | SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrderInput | SortOrder
    _count?: reservationsCountOrderByAggregateInput
    _avg?: reservationsAvgOrderByAggregateInput
    _max?: reservationsMaxOrderByAggregateInput
    _min?: reservationsMinOrderByAggregateInput
    _sum?: reservationsSumOrderByAggregateInput
  }

  export type reservationsScalarWhereWithAggregatesInput = {
    AND?: reservationsScalarWhereWithAggregatesInput | reservationsScalarWhereWithAggregatesInput[]
    OR?: reservationsScalarWhereWithAggregatesInput[]
    NOT?: reservationsScalarWhereWithAggregatesInput | reservationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reservations"> | string
    tenant_id?: StringWithAggregatesFilter<"reservations"> | string
    customer_id?: StringNullableWithAggregatesFilter<"reservations"> | string | null
    guest_name?: StringWithAggregatesFilter<"reservations"> | string
    guest_phone?: StringNullableWithAggregatesFilter<"reservations"> | string | null
    guest_email?: StringNullableWithAggregatesFilter<"reservations"> | string | null
    checkin_date?: DateTimeWithAggregatesFilter<"reservations"> | Date | string
    checkout_date?: DateTimeWithAggregatesFilter<"reservations"> | Date | string
    adult_count?: IntWithAggregatesFilter<"reservations"> | number
    child_count?: IntWithAggregatesFilter<"reservations"> | number
    room_type?: StringWithAggregatesFilter<"reservations"> | string
    room_number?: StringNullableWithAggregatesFilter<"reservations"> | string | null
    total_amount?: DecimalWithAggregatesFilter<"reservations"> | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalWithAggregatesFilter<"reservations"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"reservations"> | string
    origin?: StringWithAggregatesFilter<"reservations"> | string
    ota_id?: StringNullableWithAggregatesFilter<"reservations"> | string | null
    confirmation_number?: StringWithAggregatesFilter<"reservations"> | string
    special_requests?: StringNullableWithAggregatesFilter<"reservations"> | string | null
    internal_notes?: StringNullableWithAggregatesFilter<"reservations"> | string | null
    origin_system?: StringWithAggregatesFilter<"reservations"> | string
    synced_at?: DateTimeWithAggregatesFilter<"reservations"> | Date | string
    updated_by_system?: StringWithAggregatesFilter<"reservations"> | string
    created_at?: DateTimeWithAggregatesFilter<"reservations"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"reservations"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"reservations"> | Date | string | null
    is_deleted?: BoolWithAggregatesFilter<"reservations"> | boolean
    deleted_by?: StringNullableWithAggregatesFilter<"reservations"> | string | null
  }

  export type response_node_translationsWhereInput = {
    AND?: response_node_translationsWhereInput | response_node_translationsWhereInput[]
    OR?: response_node_translationsWhereInput[]
    NOT?: response_node_translationsWhereInput | response_node_translationsWhereInput[]
    id?: StringFilter<"response_node_translations"> | string
    nodeId?: StringFilter<"response_node_translations"> | string
    locale?: StringFilter<"response_node_translations"> | string
    content?: StringNullableFilter<"response_node_translations"> | string | null
    createdAt?: DateTimeFilter<"response_node_translations"> | Date | string
    updatedAt?: DateTimeFilter<"response_node_translations"> | Date | string
    answer?: JsonNullableFilter<"response_node_translations">
    language?: StringNullableFilter<"response_node_translations"> | string | null
    title?: StringNullableFilter<"response_node_translations"> | string | null
    deleted_at?: DateTimeNullableFilter<"response_node_translations"> | Date | string | null
    deleted_by?: StringNullableFilter<"response_node_translations"> | string | null
    is_deleted?: BoolFilter<"response_node_translations"> | boolean
    response_nodes?: XOR<Response_nodesRelationFilter, response_nodesWhereInput>
  }

  export type response_node_translationsOrderByWithRelationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    locale?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answer?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    response_nodes?: response_nodesOrderByWithRelationInput
  }

  export type response_node_translationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nodeId_language?: response_node_translationsNodeIdLanguageCompoundUniqueInput
    nodeId_locale?: response_node_translationsNodeIdLocaleCompoundUniqueInput
    AND?: response_node_translationsWhereInput | response_node_translationsWhereInput[]
    OR?: response_node_translationsWhereInput[]
    NOT?: response_node_translationsWhereInput | response_node_translationsWhereInput[]
    nodeId?: StringFilter<"response_node_translations"> | string
    locale?: StringFilter<"response_node_translations"> | string
    content?: StringNullableFilter<"response_node_translations"> | string | null
    createdAt?: DateTimeFilter<"response_node_translations"> | Date | string
    updatedAt?: DateTimeFilter<"response_node_translations"> | Date | string
    answer?: JsonNullableFilter<"response_node_translations">
    language?: StringNullableFilter<"response_node_translations"> | string | null
    title?: StringNullableFilter<"response_node_translations"> | string | null
    deleted_at?: DateTimeNullableFilter<"response_node_translations"> | Date | string | null
    deleted_by?: StringNullableFilter<"response_node_translations"> | string | null
    is_deleted?: BoolFilter<"response_node_translations"> | boolean
    response_nodes?: XOR<Response_nodesRelationFilter, response_nodesWhereInput>
  }, "id" | "nodeId_language" | "nodeId_locale">

  export type response_node_translationsOrderByWithAggregationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    locale?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answer?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: response_node_translationsCountOrderByAggregateInput
    _max?: response_node_translationsMaxOrderByAggregateInput
    _min?: response_node_translationsMinOrderByAggregateInput
  }

  export type response_node_translationsScalarWhereWithAggregatesInput = {
    AND?: response_node_translationsScalarWhereWithAggregatesInput | response_node_translationsScalarWhereWithAggregatesInput[]
    OR?: response_node_translationsScalarWhereWithAggregatesInput[]
    NOT?: response_node_translationsScalarWhereWithAggregatesInput | response_node_translationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"response_node_translations"> | string
    nodeId?: StringWithAggregatesFilter<"response_node_translations"> | string
    locale?: StringWithAggregatesFilter<"response_node_translations"> | string
    content?: StringNullableWithAggregatesFilter<"response_node_translations"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"response_node_translations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"response_node_translations"> | Date | string
    answer?: JsonNullableWithAggregatesFilter<"response_node_translations">
    language?: StringNullableWithAggregatesFilter<"response_node_translations"> | string | null
    title?: StringNullableWithAggregatesFilter<"response_node_translations"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"response_node_translations"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"response_node_translations"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"response_node_translations"> | boolean
  }

  export type response_nodesWhereInput = {
    AND?: response_nodesWhereInput | response_nodesWhereInput[]
    OR?: response_nodesWhereInput[]
    NOT?: response_nodesWhereInput | response_nodesWhereInput[]
    id?: StringFilter<"response_nodes"> | string
    treeId?: StringFilter<"response_nodes"> | string
    nodeType?: StringFilter<"response_nodes"> | string
    content?: StringNullableFilter<"response_nodes"> | string | null
    metadata?: JsonNullableFilter<"response_nodes">
    isRoot?: BoolFilter<"response_nodes"> | boolean
    parentId?: StringNullableFilter<"response_nodes"> | string | null
    position?: IntFilter<"response_nodes"> | number
    createdAt?: DateTimeFilter<"response_nodes"> | Date | string
    updatedAt?: DateTimeFilter<"response_nodes"> | Date | string
    answer?: JsonNullableFilter<"response_nodes">
    description?: StringNullableFilter<"response_nodes"> | string | null
    icon?: StringNullableFilter<"response_nodes"> | string | null
    order?: IntFilter<"response_nodes"> | number
    title?: StringNullableFilter<"response_nodes"> | string | null
    type?: StringNullableFilter<"response_nodes"> | string | null
    response_node_translations?: Response_node_translationsListRelationFilter
    response_nodes?: XOR<Response_nodesNullableRelationFilter, response_nodesWhereInput> | null
    other_response_nodes?: Response_nodesListRelationFilter
    response_trees?: XOR<Response_treesRelationFilter, response_treesWhereInput>
    response_tree_history?: Response_tree_historyListRelationFilter
    response_tree_sessions?: Response_tree_sessionsListRelationFilter
  }

  export type response_nodesOrderByWithRelationInput = {
    id?: SortOrder
    treeId?: SortOrder
    nodeType?: SortOrder
    content?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isRoot?: SortOrder
    parentId?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answer?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    title?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    response_node_translations?: response_node_translationsOrderByRelationAggregateInput
    response_nodes?: response_nodesOrderByWithRelationInput
    other_response_nodes?: response_nodesOrderByRelationAggregateInput
    response_trees?: response_treesOrderByWithRelationInput
    response_tree_history?: response_tree_historyOrderByRelationAggregateInput
    response_tree_sessions?: response_tree_sessionsOrderByRelationAggregateInput
  }

  export type response_nodesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: response_nodesWhereInput | response_nodesWhereInput[]
    OR?: response_nodesWhereInput[]
    NOT?: response_nodesWhereInput | response_nodesWhereInput[]
    treeId?: StringFilter<"response_nodes"> | string
    nodeType?: StringFilter<"response_nodes"> | string
    content?: StringNullableFilter<"response_nodes"> | string | null
    metadata?: JsonNullableFilter<"response_nodes">
    isRoot?: BoolFilter<"response_nodes"> | boolean
    parentId?: StringNullableFilter<"response_nodes"> | string | null
    position?: IntFilter<"response_nodes"> | number
    createdAt?: DateTimeFilter<"response_nodes"> | Date | string
    updatedAt?: DateTimeFilter<"response_nodes"> | Date | string
    answer?: JsonNullableFilter<"response_nodes">
    description?: StringNullableFilter<"response_nodes"> | string | null
    icon?: StringNullableFilter<"response_nodes"> | string | null
    order?: IntFilter<"response_nodes"> | number
    title?: StringNullableFilter<"response_nodes"> | string | null
    type?: StringNullableFilter<"response_nodes"> | string | null
    response_node_translations?: Response_node_translationsListRelationFilter
    response_nodes?: XOR<Response_nodesNullableRelationFilter, response_nodesWhereInput> | null
    other_response_nodes?: Response_nodesListRelationFilter
    response_trees?: XOR<Response_treesRelationFilter, response_treesWhereInput>
    response_tree_history?: Response_tree_historyListRelationFilter
    response_tree_sessions?: Response_tree_sessionsListRelationFilter
  }, "id">

  export type response_nodesOrderByWithAggregationInput = {
    id?: SortOrder
    treeId?: SortOrder
    nodeType?: SortOrder
    content?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isRoot?: SortOrder
    parentId?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answer?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    title?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: response_nodesCountOrderByAggregateInput
    _avg?: response_nodesAvgOrderByAggregateInput
    _max?: response_nodesMaxOrderByAggregateInput
    _min?: response_nodesMinOrderByAggregateInput
    _sum?: response_nodesSumOrderByAggregateInput
  }

  export type response_nodesScalarWhereWithAggregatesInput = {
    AND?: response_nodesScalarWhereWithAggregatesInput | response_nodesScalarWhereWithAggregatesInput[]
    OR?: response_nodesScalarWhereWithAggregatesInput[]
    NOT?: response_nodesScalarWhereWithAggregatesInput | response_nodesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"response_nodes"> | string
    treeId?: StringWithAggregatesFilter<"response_nodes"> | string
    nodeType?: StringWithAggregatesFilter<"response_nodes"> | string
    content?: StringNullableWithAggregatesFilter<"response_nodes"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"response_nodes">
    isRoot?: BoolWithAggregatesFilter<"response_nodes"> | boolean
    parentId?: StringNullableWithAggregatesFilter<"response_nodes"> | string | null
    position?: IntWithAggregatesFilter<"response_nodes"> | number
    createdAt?: DateTimeWithAggregatesFilter<"response_nodes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"response_nodes"> | Date | string
    answer?: JsonNullableWithAggregatesFilter<"response_nodes">
    description?: StringNullableWithAggregatesFilter<"response_nodes"> | string | null
    icon?: StringNullableWithAggregatesFilter<"response_nodes"> | string | null
    order?: IntWithAggregatesFilter<"response_nodes"> | number
    title?: StringNullableWithAggregatesFilter<"response_nodes"> | string | null
    type?: StringNullableWithAggregatesFilter<"response_nodes"> | string | null
  }

  export type response_tree_historyWhereInput = {
    AND?: response_tree_historyWhereInput | response_tree_historyWhereInput[]
    OR?: response_tree_historyWhereInput[]
    NOT?: response_tree_historyWhereInput | response_tree_historyWhereInput[]
    id?: StringFilter<"response_tree_history"> | string
    sessionId?: StringFilter<"response_tree_history"> | string
    nodeId?: StringFilter<"response_tree_history"> | string
    response?: StringNullableFilter<"response_tree_history"> | string | null
    metadata?: JsonNullableFilter<"response_tree_history">
    createdAt?: DateTimeFilter<"response_tree_history"> | Date | string
    action?: StringNullableFilter<"response_tree_history"> | string | null
    timestamp?: DateTimeFilter<"response_tree_history"> | Date | string
    response_nodes?: XOR<Response_nodesRelationFilter, response_nodesWhereInput>
    response_tree_sessions?: XOR<Response_tree_sessionsRelationFilter, response_tree_sessionsWhereInput>
  }

  export type response_tree_historyOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    nodeId?: SortOrder
    response?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    action?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    response_nodes?: response_nodesOrderByWithRelationInput
    response_tree_sessions?: response_tree_sessionsOrderByWithRelationInput
  }

  export type response_tree_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: response_tree_historyWhereInput | response_tree_historyWhereInput[]
    OR?: response_tree_historyWhereInput[]
    NOT?: response_tree_historyWhereInput | response_tree_historyWhereInput[]
    sessionId?: StringFilter<"response_tree_history"> | string
    nodeId?: StringFilter<"response_tree_history"> | string
    response?: StringNullableFilter<"response_tree_history"> | string | null
    metadata?: JsonNullableFilter<"response_tree_history">
    createdAt?: DateTimeFilter<"response_tree_history"> | Date | string
    action?: StringNullableFilter<"response_tree_history"> | string | null
    timestamp?: DateTimeFilter<"response_tree_history"> | Date | string
    response_nodes?: XOR<Response_nodesRelationFilter, response_nodesWhereInput>
    response_tree_sessions?: XOR<Response_tree_sessionsRelationFilter, response_tree_sessionsWhereInput>
  }, "id">

  export type response_tree_historyOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    nodeId?: SortOrder
    response?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    action?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: response_tree_historyCountOrderByAggregateInput
    _max?: response_tree_historyMaxOrderByAggregateInput
    _min?: response_tree_historyMinOrderByAggregateInput
  }

  export type response_tree_historyScalarWhereWithAggregatesInput = {
    AND?: response_tree_historyScalarWhereWithAggregatesInput | response_tree_historyScalarWhereWithAggregatesInput[]
    OR?: response_tree_historyScalarWhereWithAggregatesInput[]
    NOT?: response_tree_historyScalarWhereWithAggregatesInput | response_tree_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"response_tree_history"> | string
    sessionId?: StringWithAggregatesFilter<"response_tree_history"> | string
    nodeId?: StringWithAggregatesFilter<"response_tree_history"> | string
    response?: StringNullableWithAggregatesFilter<"response_tree_history"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"response_tree_history">
    createdAt?: DateTimeWithAggregatesFilter<"response_tree_history"> | Date | string
    action?: StringNullableWithAggregatesFilter<"response_tree_history"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"response_tree_history"> | Date | string
  }

  export type response_tree_mobile_linksWhereInput = {
    AND?: response_tree_mobile_linksWhereInput | response_tree_mobile_linksWhereInput[]
    OR?: response_tree_mobile_linksWhereInput[]
    NOT?: response_tree_mobile_linksWhereInput | response_tree_mobile_linksWhereInput[]
    id?: StringFilter<"response_tree_mobile_links"> | string
    sessionId?: StringFilter<"response_tree_mobile_links"> | string
    code?: StringFilter<"response_tree_mobile_links"> | string
    qrCodeData?: StringNullableFilter<"response_tree_mobile_links"> | string | null
    isActive?: BoolFilter<"response_tree_mobile_links"> | boolean
    connectionId?: StringNullableFilter<"response_tree_mobile_links"> | string | null
    createdAt?: DateTimeFilter<"response_tree_mobile_links"> | Date | string
    expiresAt?: DateTimeFilter<"response_tree_mobile_links"> | Date | string
    connectedAt?: DateTimeNullableFilter<"response_tree_mobile_links"> | Date | string | null
    deviceId?: IntNullableFilter<"response_tree_mobile_links"> | number | null
    response_tree_sessions?: XOR<Response_tree_sessionsRelationFilter, response_tree_sessionsWhereInput>
  }

  export type response_tree_mobile_linksOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    code?: SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    isActive?: SortOrder
    connectionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    connectedAt?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    response_tree_sessions?: response_tree_sessionsOrderByWithRelationInput
  }

  export type response_tree_mobile_linksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: response_tree_mobile_linksWhereInput | response_tree_mobile_linksWhereInput[]
    OR?: response_tree_mobile_linksWhereInput[]
    NOT?: response_tree_mobile_linksWhereInput | response_tree_mobile_linksWhereInput[]
    sessionId?: StringFilter<"response_tree_mobile_links"> | string
    qrCodeData?: StringNullableFilter<"response_tree_mobile_links"> | string | null
    isActive?: BoolFilter<"response_tree_mobile_links"> | boolean
    connectionId?: StringNullableFilter<"response_tree_mobile_links"> | string | null
    createdAt?: DateTimeFilter<"response_tree_mobile_links"> | Date | string
    expiresAt?: DateTimeFilter<"response_tree_mobile_links"> | Date | string
    connectedAt?: DateTimeNullableFilter<"response_tree_mobile_links"> | Date | string | null
    deviceId?: IntNullableFilter<"response_tree_mobile_links"> | number | null
    response_tree_sessions?: XOR<Response_tree_sessionsRelationFilter, response_tree_sessionsWhereInput>
  }, "id" | "code">

  export type response_tree_mobile_linksOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    code?: SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    isActive?: SortOrder
    connectionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    connectedAt?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    _count?: response_tree_mobile_linksCountOrderByAggregateInput
    _avg?: response_tree_mobile_linksAvgOrderByAggregateInput
    _max?: response_tree_mobile_linksMaxOrderByAggregateInput
    _min?: response_tree_mobile_linksMinOrderByAggregateInput
    _sum?: response_tree_mobile_linksSumOrderByAggregateInput
  }

  export type response_tree_mobile_linksScalarWhereWithAggregatesInput = {
    AND?: response_tree_mobile_linksScalarWhereWithAggregatesInput | response_tree_mobile_linksScalarWhereWithAggregatesInput[]
    OR?: response_tree_mobile_linksScalarWhereWithAggregatesInput[]
    NOT?: response_tree_mobile_linksScalarWhereWithAggregatesInput | response_tree_mobile_linksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"response_tree_mobile_links"> | string
    sessionId?: StringWithAggregatesFilter<"response_tree_mobile_links"> | string
    code?: StringWithAggregatesFilter<"response_tree_mobile_links"> | string
    qrCodeData?: StringNullableWithAggregatesFilter<"response_tree_mobile_links"> | string | null
    isActive?: BoolWithAggregatesFilter<"response_tree_mobile_links"> | boolean
    connectionId?: StringNullableWithAggregatesFilter<"response_tree_mobile_links"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"response_tree_mobile_links"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"response_tree_mobile_links"> | Date | string
    connectedAt?: DateTimeNullableWithAggregatesFilter<"response_tree_mobile_links"> | Date | string | null
    deviceId?: IntNullableWithAggregatesFilter<"response_tree_mobile_links"> | number | null
  }

  export type response_tree_sessionsWhereInput = {
    AND?: response_tree_sessionsWhereInput | response_tree_sessionsWhereInput[]
    OR?: response_tree_sessionsWhereInput[]
    NOT?: response_tree_sessionsWhereInput | response_tree_sessionsWhereInput[]
    id?: StringFilter<"response_tree_sessions"> | string
    treeId?: StringFilter<"response_tree_sessions"> | string
    userId?: StringNullableFilter<"response_tree_sessions"> | string | null
    deviceId?: StringNullableFilter<"response_tree_sessions"> | string | null
    currentNodeId?: StringNullableFilter<"response_tree_sessions"> | string | null
    metadata?: JsonNullableFilter<"response_tree_sessions">
    isComplete?: BoolFilter<"response_tree_sessions"> | boolean
    startedAt?: DateTimeFilter<"response_tree_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"response_tree_sessions"> | Date | string
    completedAt?: DateTimeNullableFilter<"response_tree_sessions"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"response_tree_sessions"> | Date | string | null
    interfaceType?: StringNullableFilter<"response_tree_sessions"> | string | null
    language?: StringNullableFilter<"response_tree_sessions"> | string | null
    lastActivityAt?: DateTimeNullableFilter<"response_tree_sessions"> | Date | string | null
    roomId?: StringNullableFilter<"response_tree_sessions"> | string | null
    sessionId?: StringFilter<"response_tree_sessions"> | string
    response_tree_history?: Response_tree_historyListRelationFilter
    response_tree_mobile_links?: Response_tree_mobile_linksListRelationFilter
    response_nodes?: XOR<Response_nodesNullableRelationFilter, response_nodesWhereInput> | null
    response_trees?: XOR<Response_treesRelationFilter, response_treesWhereInput>
  }

  export type response_tree_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    treeId?: SortOrder
    userId?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    currentNodeId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    interfaceType?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    sessionId?: SortOrder
    response_tree_history?: response_tree_historyOrderByRelationAggregateInput
    response_tree_mobile_links?: response_tree_mobile_linksOrderByRelationAggregateInput
    response_nodes?: response_nodesOrderByWithRelationInput
    response_trees?: response_treesOrderByWithRelationInput
  }

  export type response_tree_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: response_tree_sessionsWhereInput | response_tree_sessionsWhereInput[]
    OR?: response_tree_sessionsWhereInput[]
    NOT?: response_tree_sessionsWhereInput | response_tree_sessionsWhereInput[]
    treeId?: StringFilter<"response_tree_sessions"> | string
    userId?: StringNullableFilter<"response_tree_sessions"> | string | null
    deviceId?: StringNullableFilter<"response_tree_sessions"> | string | null
    currentNodeId?: StringNullableFilter<"response_tree_sessions"> | string | null
    metadata?: JsonNullableFilter<"response_tree_sessions">
    isComplete?: BoolFilter<"response_tree_sessions"> | boolean
    startedAt?: DateTimeFilter<"response_tree_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"response_tree_sessions"> | Date | string
    completedAt?: DateTimeNullableFilter<"response_tree_sessions"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"response_tree_sessions"> | Date | string | null
    interfaceType?: StringNullableFilter<"response_tree_sessions"> | string | null
    language?: StringNullableFilter<"response_tree_sessions"> | string | null
    lastActivityAt?: DateTimeNullableFilter<"response_tree_sessions"> | Date | string | null
    roomId?: StringNullableFilter<"response_tree_sessions"> | string | null
    response_tree_history?: Response_tree_historyListRelationFilter
    response_tree_mobile_links?: Response_tree_mobile_linksListRelationFilter
    response_nodes?: XOR<Response_nodesNullableRelationFilter, response_nodesWhereInput> | null
    response_trees?: XOR<Response_treesRelationFilter, response_treesWhereInput>
  }, "id" | "sessionId">

  export type response_tree_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    treeId?: SortOrder
    userId?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    currentNodeId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isComplete?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    interfaceType?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    sessionId?: SortOrder
    _count?: response_tree_sessionsCountOrderByAggregateInput
    _max?: response_tree_sessionsMaxOrderByAggregateInput
    _min?: response_tree_sessionsMinOrderByAggregateInput
  }

  export type response_tree_sessionsScalarWhereWithAggregatesInput = {
    AND?: response_tree_sessionsScalarWhereWithAggregatesInput | response_tree_sessionsScalarWhereWithAggregatesInput[]
    OR?: response_tree_sessionsScalarWhereWithAggregatesInput[]
    NOT?: response_tree_sessionsScalarWhereWithAggregatesInput | response_tree_sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"response_tree_sessions"> | string
    treeId?: StringWithAggregatesFilter<"response_tree_sessions"> | string
    userId?: StringNullableWithAggregatesFilter<"response_tree_sessions"> | string | null
    deviceId?: StringNullableWithAggregatesFilter<"response_tree_sessions"> | string | null
    currentNodeId?: StringNullableWithAggregatesFilter<"response_tree_sessions"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"response_tree_sessions">
    isComplete?: BoolWithAggregatesFilter<"response_tree_sessions"> | boolean
    startedAt?: DateTimeWithAggregatesFilter<"response_tree_sessions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"response_tree_sessions"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"response_tree_sessions"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"response_tree_sessions"> | Date | string | null
    interfaceType?: StringNullableWithAggregatesFilter<"response_tree_sessions"> | string | null
    language?: StringNullableWithAggregatesFilter<"response_tree_sessions"> | string | null
    lastActivityAt?: DateTimeNullableWithAggregatesFilter<"response_tree_sessions"> | Date | string | null
    roomId?: StringNullableWithAggregatesFilter<"response_tree_sessions"> | string | null
    sessionId?: StringWithAggregatesFilter<"response_tree_sessions"> | string
  }

  export type response_tree_versionsWhereInput = {
    AND?: response_tree_versionsWhereInput | response_tree_versionsWhereInput[]
    OR?: response_tree_versionsWhereInput[]
    NOT?: response_tree_versionsWhereInput | response_tree_versionsWhereInput[]
    id?: StringFilter<"response_tree_versions"> | string
    treeId?: StringFilter<"response_tree_versions"> | string
    version?: IntFilter<"response_tree_versions"> | number
    snapshot?: JsonFilter<"response_tree_versions">
    createdAt?: DateTimeFilter<"response_tree_versions"> | Date | string
    createdBy?: StringNullableFilter<"response_tree_versions"> | string | null
    data?: JsonNullableFilter<"response_tree_versions">
    response_trees?: XOR<Response_treesRelationFilter, response_treesWhereInput>
  }

  export type response_tree_versionsOrderByWithRelationInput = {
    id?: SortOrder
    treeId?: SortOrder
    version?: SortOrder
    snapshot?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    response_trees?: response_treesOrderByWithRelationInput
  }

  export type response_tree_versionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    treeId_version?: response_tree_versionsTreeIdVersionCompoundUniqueInput
    AND?: response_tree_versionsWhereInput | response_tree_versionsWhereInput[]
    OR?: response_tree_versionsWhereInput[]
    NOT?: response_tree_versionsWhereInput | response_tree_versionsWhereInput[]
    treeId?: StringFilter<"response_tree_versions"> | string
    version?: IntFilter<"response_tree_versions"> | number
    snapshot?: JsonFilter<"response_tree_versions">
    createdAt?: DateTimeFilter<"response_tree_versions"> | Date | string
    createdBy?: StringNullableFilter<"response_tree_versions"> | string | null
    data?: JsonNullableFilter<"response_tree_versions">
    response_trees?: XOR<Response_treesRelationFilter, response_treesWhereInput>
  }, "id" | "treeId_version">

  export type response_tree_versionsOrderByWithAggregationInput = {
    id?: SortOrder
    treeId?: SortOrder
    version?: SortOrder
    snapshot?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    _count?: response_tree_versionsCountOrderByAggregateInput
    _avg?: response_tree_versionsAvgOrderByAggregateInput
    _max?: response_tree_versionsMaxOrderByAggregateInput
    _min?: response_tree_versionsMinOrderByAggregateInput
    _sum?: response_tree_versionsSumOrderByAggregateInput
  }

  export type response_tree_versionsScalarWhereWithAggregatesInput = {
    AND?: response_tree_versionsScalarWhereWithAggregatesInput | response_tree_versionsScalarWhereWithAggregatesInput[]
    OR?: response_tree_versionsScalarWhereWithAggregatesInput[]
    NOT?: response_tree_versionsScalarWhereWithAggregatesInput | response_tree_versionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"response_tree_versions"> | string
    treeId?: StringWithAggregatesFilter<"response_tree_versions"> | string
    version?: IntWithAggregatesFilter<"response_tree_versions"> | number
    snapshot?: JsonWithAggregatesFilter<"response_tree_versions">
    createdAt?: DateTimeWithAggregatesFilter<"response_tree_versions"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"response_tree_versions"> | string | null
    data?: JsonNullableWithAggregatesFilter<"response_tree_versions">
  }

  export type response_treesWhereInput = {
    AND?: response_treesWhereInput | response_treesWhereInput[]
    OR?: response_treesWhereInput[]
    NOT?: response_treesWhereInput | response_treesWhereInput[]
    id?: StringFilter<"response_trees"> | string
    tenantId?: StringFilter<"response_trees"> | string
    name?: StringFilter<"response_trees"> | string
    description?: StringNullableFilter<"response_trees"> | string | null
    isPublished?: BoolFilter<"response_trees"> | boolean
    publishedAt?: DateTimeNullableFilter<"response_trees"> | Date | string | null
    version?: IntFilter<"response_trees"> | number
    createdAt?: DateTimeFilter<"response_trees"> | Date | string
    updatedAt?: DateTimeFilter<"response_trees"> | Date | string
    isActive?: BoolFilter<"response_trees"> | boolean
    deleted_at?: DateTimeNullableFilter<"response_trees"> | Date | string | null
    deleted_by?: StringNullableFilter<"response_trees"> | string | null
    is_deleted?: BoolFilter<"response_trees"> | boolean
    response_nodes?: Response_nodesListRelationFilter
    response_tree_sessions?: Response_tree_sessionsListRelationFilter
    response_tree_versions?: Response_tree_versionsListRelationFilter
  }

  export type response_treesOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    response_nodes?: response_nodesOrderByRelationAggregateInput
    response_tree_sessions?: response_tree_sessionsOrderByRelationAggregateInput
    response_tree_versions?: response_tree_versionsOrderByRelationAggregateInput
  }

  export type response_treesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: response_treesWhereInput | response_treesWhereInput[]
    OR?: response_treesWhereInput[]
    NOT?: response_treesWhereInput | response_treesWhereInput[]
    tenantId?: StringFilter<"response_trees"> | string
    name?: StringFilter<"response_trees"> | string
    description?: StringNullableFilter<"response_trees"> | string | null
    isPublished?: BoolFilter<"response_trees"> | boolean
    publishedAt?: DateTimeNullableFilter<"response_trees"> | Date | string | null
    version?: IntFilter<"response_trees"> | number
    createdAt?: DateTimeFilter<"response_trees"> | Date | string
    updatedAt?: DateTimeFilter<"response_trees"> | Date | string
    isActive?: BoolFilter<"response_trees"> | boolean
    deleted_at?: DateTimeNullableFilter<"response_trees"> | Date | string | null
    deleted_by?: StringNullableFilter<"response_trees"> | string | null
    is_deleted?: BoolFilter<"response_trees"> | boolean
    response_nodes?: Response_nodesListRelationFilter
    response_tree_sessions?: Response_tree_sessionsListRelationFilter
    response_tree_versions?: Response_tree_versionsListRelationFilter
  }, "id">

  export type response_treesOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: response_treesCountOrderByAggregateInput
    _avg?: response_treesAvgOrderByAggregateInput
    _max?: response_treesMaxOrderByAggregateInput
    _min?: response_treesMinOrderByAggregateInput
    _sum?: response_treesSumOrderByAggregateInput
  }

  export type response_treesScalarWhereWithAggregatesInput = {
    AND?: response_treesScalarWhereWithAggregatesInput | response_treesScalarWhereWithAggregatesInput[]
    OR?: response_treesScalarWhereWithAggregatesInput[]
    NOT?: response_treesScalarWhereWithAggregatesInput | response_treesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"response_trees"> | string
    tenantId?: StringWithAggregatesFilter<"response_trees"> | string
    name?: StringWithAggregatesFilter<"response_trees"> | string
    description?: StringNullableWithAggregatesFilter<"response_trees"> | string | null
    isPublished?: BoolWithAggregatesFilter<"response_trees"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"response_trees"> | Date | string | null
    version?: IntWithAggregatesFilter<"response_trees"> | number
    createdAt?: DateTimeWithAggregatesFilter<"response_trees"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"response_trees"> | Date | string
    isActive?: BoolWithAggregatesFilter<"response_trees"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"response_trees"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"response_trees"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"response_trees"> | boolean
  }

  export type room_gradesWhereInput = {
    AND?: room_gradesWhereInput | room_gradesWhereInput[]
    OR?: room_gradesWhereInput[]
    NOT?: room_gradesWhereInput | room_gradesWhereInput[]
    id?: StringFilter<"room_grades"> | string
    tenant_id?: StringFilter<"room_grades"> | string
    code?: StringFilter<"room_grades"> | string
    name?: StringFilter<"room_grades"> | string
    description?: StringNullableFilter<"room_grades"> | string | null
    created_at?: DateTimeFilter<"room_grades"> | Date | string
    updated_at?: DateTimeFilter<"room_grades"> | Date | string
  }

  export type room_gradesOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type room_gradesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_code?: room_gradesTenant_idCodeCompoundUniqueInput
    AND?: room_gradesWhereInput | room_gradesWhereInput[]
    OR?: room_gradesWhereInput[]
    NOT?: room_gradesWhereInput | room_gradesWhereInput[]
    tenant_id?: StringFilter<"room_grades"> | string
    code?: StringFilter<"room_grades"> | string
    name?: StringFilter<"room_grades"> | string
    description?: StringNullableFilter<"room_grades"> | string | null
    created_at?: DateTimeFilter<"room_grades"> | Date | string
    updated_at?: DateTimeFilter<"room_grades"> | Date | string
  }, "id" | "tenant_id_code">

  export type room_gradesOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: room_gradesCountOrderByAggregateInput
    _max?: room_gradesMaxOrderByAggregateInput
    _min?: room_gradesMinOrderByAggregateInput
  }

  export type room_gradesScalarWhereWithAggregatesInput = {
    AND?: room_gradesScalarWhereWithAggregatesInput | room_gradesScalarWhereWithAggregatesInput[]
    OR?: room_gradesScalarWhereWithAggregatesInput[]
    NOT?: room_gradesScalarWhereWithAggregatesInput | room_gradesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"room_grades"> | string
    tenant_id?: StringWithAggregatesFilter<"room_grades"> | string
    code?: StringWithAggregatesFilter<"room_grades"> | string
    name?: StringWithAggregatesFilter<"room_grades"> | string
    description?: StringNullableWithAggregatesFilter<"room_grades"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"room_grades"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"room_grades"> | Date | string
  }

  export type schema_versionWhereInput = {
    AND?: schema_versionWhereInput | schema_versionWhereInput[]
    OR?: schema_versionWhereInput[]
    NOT?: schema_versionWhereInput | schema_versionWhereInput[]
    version?: StringFilter<"schema_version"> | string
    description?: StringFilter<"schema_version"> | string
    rollback_sql?: StringNullableFilter<"schema_version"> | string | null
    applied_at?: DateTimeFilter<"schema_version"> | Date | string
    applied_by?: StringNullableFilter<"schema_version"> | string | null
  }

  export type schema_versionOrderByWithRelationInput = {
    version?: SortOrder
    description?: SortOrder
    rollback_sql?: SortOrderInput | SortOrder
    applied_at?: SortOrder
    applied_by?: SortOrderInput | SortOrder
  }

  export type schema_versionWhereUniqueInput = Prisma.AtLeast<{
    version?: string
    AND?: schema_versionWhereInput | schema_versionWhereInput[]
    OR?: schema_versionWhereInput[]
    NOT?: schema_versionWhereInput | schema_versionWhereInput[]
    description?: StringFilter<"schema_version"> | string
    rollback_sql?: StringNullableFilter<"schema_version"> | string | null
    applied_at?: DateTimeFilter<"schema_version"> | Date | string
    applied_by?: StringNullableFilter<"schema_version"> | string | null
  }, "version">

  export type schema_versionOrderByWithAggregationInput = {
    version?: SortOrder
    description?: SortOrder
    rollback_sql?: SortOrderInput | SortOrder
    applied_at?: SortOrder
    applied_by?: SortOrderInput | SortOrder
    _count?: schema_versionCountOrderByAggregateInput
    _max?: schema_versionMaxOrderByAggregateInput
    _min?: schema_versionMinOrderByAggregateInput
  }

  export type schema_versionScalarWhereWithAggregatesInput = {
    AND?: schema_versionScalarWhereWithAggregatesInput | schema_versionScalarWhereWithAggregatesInput[]
    OR?: schema_versionScalarWhereWithAggregatesInput[]
    NOT?: schema_versionScalarWhereWithAggregatesInput | schema_versionScalarWhereWithAggregatesInput[]
    version?: StringWithAggregatesFilter<"schema_version"> | string
    description?: StringWithAggregatesFilter<"schema_version"> | string
    rollback_sql?: StringNullableWithAggregatesFilter<"schema_version"> | string | null
    applied_at?: DateTimeWithAggregatesFilter<"schema_version"> | Date | string
    applied_by?: StringNullableWithAggregatesFilter<"schema_version"> | string | null
  }

  export type service_plan_restrictionsWhereInput = {
    AND?: service_plan_restrictionsWhereInput | service_plan_restrictionsWhereInput[]
    OR?: service_plan_restrictionsWhereInput[]
    NOT?: service_plan_restrictionsWhereInput | service_plan_restrictionsWhereInput[]
    id?: StringFilter<"service_plan_restrictions"> | string
    service_type?: StringFilter<"service_plan_restrictions"> | string
    plan_type?: StringFilter<"service_plan_restrictions"> | string
    plan_category?: StringFilter<"service_plan_restrictions"> | string
    max_users?: IntFilter<"service_plan_restrictions"> | number
    max_devices?: IntFilter<"service_plan_restrictions"> | number
    max_monthly_orders?: IntNullableFilter<"service_plan_restrictions"> | number | null
    enable_ai_concierge?: BoolNullableFilter<"service_plan_restrictions"> | boolean | null
    enable_multilingual?: BoolNullableFilter<"service_plan_restrictions"> | boolean | null
    max_rooms?: IntNullableFilter<"service_plan_restrictions"> | number | null
    enable_revenue_management?: BoolNullableFilter<"service_plan_restrictions"> | boolean | null
    max_monthly_ai_requests?: IntNullableFilter<"service_plan_restrictions"> | number | null
    enable_ai_crm?: BoolNullableFilter<"service_plan_restrictions"> | boolean | null
    monthly_price?: IntFilter<"service_plan_restrictions"> | number
    created_at?: DateTimeFilter<"service_plan_restrictions"> | Date | string
    updated_at?: DateTimeFilter<"service_plan_restrictions"> | Date | string
  }

  export type service_plan_restrictionsOrderByWithRelationInput = {
    id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    plan_category?: SortOrder
    max_users?: SortOrder
    max_devices?: SortOrder
    max_monthly_orders?: SortOrderInput | SortOrder
    enable_ai_concierge?: SortOrderInput | SortOrder
    enable_multilingual?: SortOrderInput | SortOrder
    max_rooms?: SortOrderInput | SortOrder
    enable_revenue_management?: SortOrderInput | SortOrder
    max_monthly_ai_requests?: SortOrderInput | SortOrder
    enable_ai_crm?: SortOrderInput | SortOrder
    monthly_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type service_plan_restrictionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    service_type_plan_type_plan_category?: service_plan_restrictionsService_typePlan_typePlan_categoryCompoundUniqueInput
    AND?: service_plan_restrictionsWhereInput | service_plan_restrictionsWhereInput[]
    OR?: service_plan_restrictionsWhereInput[]
    NOT?: service_plan_restrictionsWhereInput | service_plan_restrictionsWhereInput[]
    service_type?: StringFilter<"service_plan_restrictions"> | string
    plan_type?: StringFilter<"service_plan_restrictions"> | string
    plan_category?: StringFilter<"service_plan_restrictions"> | string
    max_users?: IntFilter<"service_plan_restrictions"> | number
    max_devices?: IntFilter<"service_plan_restrictions"> | number
    max_monthly_orders?: IntNullableFilter<"service_plan_restrictions"> | number | null
    enable_ai_concierge?: BoolNullableFilter<"service_plan_restrictions"> | boolean | null
    enable_multilingual?: BoolNullableFilter<"service_plan_restrictions"> | boolean | null
    max_rooms?: IntNullableFilter<"service_plan_restrictions"> | number | null
    enable_revenue_management?: BoolNullableFilter<"service_plan_restrictions"> | boolean | null
    max_monthly_ai_requests?: IntNullableFilter<"service_plan_restrictions"> | number | null
    enable_ai_crm?: BoolNullableFilter<"service_plan_restrictions"> | boolean | null
    monthly_price?: IntFilter<"service_plan_restrictions"> | number
    created_at?: DateTimeFilter<"service_plan_restrictions"> | Date | string
    updated_at?: DateTimeFilter<"service_plan_restrictions"> | Date | string
  }, "id" | "service_type_plan_type_plan_category">

  export type service_plan_restrictionsOrderByWithAggregationInput = {
    id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    plan_category?: SortOrder
    max_users?: SortOrder
    max_devices?: SortOrder
    max_monthly_orders?: SortOrderInput | SortOrder
    enable_ai_concierge?: SortOrderInput | SortOrder
    enable_multilingual?: SortOrderInput | SortOrder
    max_rooms?: SortOrderInput | SortOrder
    enable_revenue_management?: SortOrderInput | SortOrder
    max_monthly_ai_requests?: SortOrderInput | SortOrder
    enable_ai_crm?: SortOrderInput | SortOrder
    monthly_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: service_plan_restrictionsCountOrderByAggregateInput
    _avg?: service_plan_restrictionsAvgOrderByAggregateInput
    _max?: service_plan_restrictionsMaxOrderByAggregateInput
    _min?: service_plan_restrictionsMinOrderByAggregateInput
    _sum?: service_plan_restrictionsSumOrderByAggregateInput
  }

  export type service_plan_restrictionsScalarWhereWithAggregatesInput = {
    AND?: service_plan_restrictionsScalarWhereWithAggregatesInput | service_plan_restrictionsScalarWhereWithAggregatesInput[]
    OR?: service_plan_restrictionsScalarWhereWithAggregatesInput[]
    NOT?: service_plan_restrictionsScalarWhereWithAggregatesInput | service_plan_restrictionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"service_plan_restrictions"> | string
    service_type?: StringWithAggregatesFilter<"service_plan_restrictions"> | string
    plan_type?: StringWithAggregatesFilter<"service_plan_restrictions"> | string
    plan_category?: StringWithAggregatesFilter<"service_plan_restrictions"> | string
    max_users?: IntWithAggregatesFilter<"service_plan_restrictions"> | number
    max_devices?: IntWithAggregatesFilter<"service_plan_restrictions"> | number
    max_monthly_orders?: IntNullableWithAggregatesFilter<"service_plan_restrictions"> | number | null
    enable_ai_concierge?: BoolNullableWithAggregatesFilter<"service_plan_restrictions"> | boolean | null
    enable_multilingual?: BoolNullableWithAggregatesFilter<"service_plan_restrictions"> | boolean | null
    max_rooms?: IntNullableWithAggregatesFilter<"service_plan_restrictions"> | number | null
    enable_revenue_management?: BoolNullableWithAggregatesFilter<"service_plan_restrictions"> | boolean | null
    max_monthly_ai_requests?: IntNullableWithAggregatesFilter<"service_plan_restrictions"> | number | null
    enable_ai_crm?: BoolNullableWithAggregatesFilter<"service_plan_restrictions"> | boolean | null
    monthly_price?: IntWithAggregatesFilter<"service_plan_restrictions"> | number
    created_at?: DateTimeWithAggregatesFilter<"service_plan_restrictions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"service_plan_restrictions"> | Date | string
  }

  export type service_usage_statisticsWhereInput = {
    AND?: service_usage_statisticsWhereInput | service_usage_statisticsWhereInput[]
    OR?: service_usage_statisticsWhereInput[]
    NOT?: service_usage_statisticsWhereInput | service_usage_statisticsWhereInput[]
    id?: StringFilter<"service_usage_statistics"> | string
    tenant_id?: StringFilter<"service_usage_statistics"> | string
    service_type?: StringFilter<"service_usage_statistics"> | string
    month?: StringFilter<"service_usage_statistics"> | string
    active_users_count?: IntFilter<"service_usage_statistics"> | number
    active_devices_count?: IntFilter<"service_usage_statistics"> | number
    usage_data?: JsonFilter<"service_usage_statistics">
    created_at?: DateTimeFilter<"service_usage_statistics"> | Date | string
    updated_at?: DateTimeFilter<"service_usage_statistics"> | Date | string
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type service_usage_statisticsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    month?: SortOrder
    active_users_count?: SortOrder
    active_devices_count?: SortOrder
    usage_data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    Tenant?: TenantOrderByWithRelationInput
  }

  export type service_usage_statisticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_service_type_month?: service_usage_statisticsTenant_idService_typeMonthCompoundUniqueInput
    AND?: service_usage_statisticsWhereInput | service_usage_statisticsWhereInput[]
    OR?: service_usage_statisticsWhereInput[]
    NOT?: service_usage_statisticsWhereInput | service_usage_statisticsWhereInput[]
    tenant_id?: StringFilter<"service_usage_statistics"> | string
    service_type?: StringFilter<"service_usage_statistics"> | string
    month?: StringFilter<"service_usage_statistics"> | string
    active_users_count?: IntFilter<"service_usage_statistics"> | number
    active_devices_count?: IntFilter<"service_usage_statistics"> | number
    usage_data?: JsonFilter<"service_usage_statistics">
    created_at?: DateTimeFilter<"service_usage_statistics"> | Date | string
    updated_at?: DateTimeFilter<"service_usage_statistics"> | Date | string
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenant_id_service_type_month">

  export type service_usage_statisticsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    month?: SortOrder
    active_users_count?: SortOrder
    active_devices_count?: SortOrder
    usage_data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: service_usage_statisticsCountOrderByAggregateInput
    _avg?: service_usage_statisticsAvgOrderByAggregateInput
    _max?: service_usage_statisticsMaxOrderByAggregateInput
    _min?: service_usage_statisticsMinOrderByAggregateInput
    _sum?: service_usage_statisticsSumOrderByAggregateInput
  }

  export type service_usage_statisticsScalarWhereWithAggregatesInput = {
    AND?: service_usage_statisticsScalarWhereWithAggregatesInput | service_usage_statisticsScalarWhereWithAggregatesInput[]
    OR?: service_usage_statisticsScalarWhereWithAggregatesInput[]
    NOT?: service_usage_statisticsScalarWhereWithAggregatesInput | service_usage_statisticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"service_usage_statistics"> | string
    tenant_id?: StringWithAggregatesFilter<"service_usage_statistics"> | string
    service_type?: StringWithAggregatesFilter<"service_usage_statistics"> | string
    month?: StringWithAggregatesFilter<"service_usage_statistics"> | string
    active_users_count?: IntWithAggregatesFilter<"service_usage_statistics"> | number
    active_devices_count?: IntWithAggregatesFilter<"service_usage_statistics"> | number
    usage_data?: JsonWithAggregatesFilter<"service_usage_statistics">
    created_at?: DateTimeWithAggregatesFilter<"service_usage_statistics"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"service_usage_statistics"> | Date | string
  }

  export type staffWhereInput = {
    AND?: staffWhereInput | staffWhereInput[]
    OR?: staffWhereInput[]
    NOT?: staffWhereInput | staffWhereInput[]
    id?: StringFilter<"staff"> | string
    tenant_id?: StringFilter<"staff"> | string
    email?: StringFilter<"staff"> | string
    name?: StringFilter<"staff"> | string
    role?: StringFilter<"staff"> | string
    department?: StringNullableFilter<"staff"> | string | null
    is_active?: BoolFilter<"staff"> | boolean
    created_at?: DateTimeFilter<"staff"> | Date | string
    updated_at?: DateTimeFilter<"staff"> | Date | string
    failed_login_count?: IntFilter<"staff"> | number
    last_login_at?: DateTimeNullableFilter<"staff"> | Date | string | null
    locked_until?: DateTimeNullableFilter<"staff"> | Date | string | null
    password_hash?: StringNullableFilter<"staff"> | string | null
    deleted_at?: DateTimeNullableFilter<"staff"> | Date | string | null
    deleted_by?: StringNullableFilter<"staff"> | string | null
    is_deleted?: BoolFilter<"staff"> | boolean
  }

  export type staffOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    failed_login_count?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
  }

  export type staffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_email?: staffTenant_idEmailCompoundUniqueInput
    AND?: staffWhereInput | staffWhereInput[]
    OR?: staffWhereInput[]
    NOT?: staffWhereInput | staffWhereInput[]
    tenant_id?: StringFilter<"staff"> | string
    email?: StringFilter<"staff"> | string
    name?: StringFilter<"staff"> | string
    role?: StringFilter<"staff"> | string
    department?: StringNullableFilter<"staff"> | string | null
    is_active?: BoolFilter<"staff"> | boolean
    created_at?: DateTimeFilter<"staff"> | Date | string
    updated_at?: DateTimeFilter<"staff"> | Date | string
    failed_login_count?: IntFilter<"staff"> | number
    last_login_at?: DateTimeNullableFilter<"staff"> | Date | string | null
    locked_until?: DateTimeNullableFilter<"staff"> | Date | string | null
    password_hash?: StringNullableFilter<"staff"> | string | null
    deleted_at?: DateTimeNullableFilter<"staff"> | Date | string | null
    deleted_by?: StringNullableFilter<"staff"> | string | null
    is_deleted?: BoolFilter<"staff"> | boolean
  }, "id" | "tenant_id_email">

  export type staffOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    failed_login_count?: SortOrder
    last_login_at?: SortOrderInput | SortOrder
    locked_until?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    deleted_by?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: staffCountOrderByAggregateInput
    _avg?: staffAvgOrderByAggregateInput
    _max?: staffMaxOrderByAggregateInput
    _min?: staffMinOrderByAggregateInput
    _sum?: staffSumOrderByAggregateInput
  }

  export type staffScalarWhereWithAggregatesInput = {
    AND?: staffScalarWhereWithAggregatesInput | staffScalarWhereWithAggregatesInput[]
    OR?: staffScalarWhereWithAggregatesInput[]
    NOT?: staffScalarWhereWithAggregatesInput | staffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"staff"> | string
    tenant_id?: StringWithAggregatesFilter<"staff"> | string
    email?: StringWithAggregatesFilter<"staff"> | string
    name?: StringWithAggregatesFilter<"staff"> | string
    role?: StringWithAggregatesFilter<"staff"> | string
    department?: StringNullableWithAggregatesFilter<"staff"> | string | null
    is_active?: BoolWithAggregatesFilter<"staff"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"staff"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"staff"> | Date | string
    failed_login_count?: IntWithAggregatesFilter<"staff"> | number
    last_login_at?: DateTimeNullableWithAggregatesFilter<"staff"> | Date | string | null
    locked_until?: DateTimeNullableWithAggregatesFilter<"staff"> | Date | string | null
    password_hash?: StringNullableWithAggregatesFilter<"staff"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"staff"> | Date | string | null
    deleted_by?: StringNullableWithAggregatesFilter<"staff"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"staff"> | boolean
  }

  export type system_eventWhereInput = {
    AND?: system_eventWhereInput | system_eventWhereInput[]
    OR?: system_eventWhereInput[]
    NOT?: system_eventWhereInput | system_eventWhereInput[]
    id?: StringFilter<"system_event"> | string
    tenant_id?: StringFilter<"system_event"> | string
    user_id?: StringNullableFilter<"system_event"> | string | null
    event_type?: StringFilter<"system_event"> | string
    source_system?: StringFilter<"system_event"> | string
    target_system?: StringFilter<"system_event"> | string
    entity_type?: StringFilter<"system_event"> | string
    entity_id?: StringFilter<"system_event"> | string
    action?: StringFilter<"system_event"> | string
    event_data?: JsonNullableFilter<"system_event">
    created_at?: DateTimeFilter<"system_event"> | Date | string
    processed_at?: DateTimeNullableFilter<"system_event"> | Date | string | null
    status?: StringFilter<"system_event"> | string
  }

  export type system_eventOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    event_type?: SortOrder
    source_system?: SortOrder
    target_system?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    event_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    status?: SortOrder
  }

  export type system_eventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: system_eventWhereInput | system_eventWhereInput[]
    OR?: system_eventWhereInput[]
    NOT?: system_eventWhereInput | system_eventWhereInput[]
    tenant_id?: StringFilter<"system_event"> | string
    user_id?: StringNullableFilter<"system_event"> | string | null
    event_type?: StringFilter<"system_event"> | string
    source_system?: StringFilter<"system_event"> | string
    target_system?: StringFilter<"system_event"> | string
    entity_type?: StringFilter<"system_event"> | string
    entity_id?: StringFilter<"system_event"> | string
    action?: StringFilter<"system_event"> | string
    event_data?: JsonNullableFilter<"system_event">
    created_at?: DateTimeFilter<"system_event"> | Date | string
    processed_at?: DateTimeNullableFilter<"system_event"> | Date | string | null
    status?: StringFilter<"system_event"> | string
  }, "id">

  export type system_eventOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    event_type?: SortOrder
    source_system?: SortOrder
    target_system?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    event_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: system_eventCountOrderByAggregateInput
    _max?: system_eventMaxOrderByAggregateInput
    _min?: system_eventMinOrderByAggregateInput
  }

  export type system_eventScalarWhereWithAggregatesInput = {
    AND?: system_eventScalarWhereWithAggregatesInput | system_eventScalarWhereWithAggregatesInput[]
    OR?: system_eventScalarWhereWithAggregatesInput[]
    NOT?: system_eventScalarWhereWithAggregatesInput | system_eventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"system_event"> | string
    tenant_id?: StringWithAggregatesFilter<"system_event"> | string
    user_id?: StringNullableWithAggregatesFilter<"system_event"> | string | null
    event_type?: StringWithAggregatesFilter<"system_event"> | string
    source_system?: StringWithAggregatesFilter<"system_event"> | string
    target_system?: StringWithAggregatesFilter<"system_event"> | string
    entity_type?: StringWithAggregatesFilter<"system_event"> | string
    entity_id?: StringWithAggregatesFilter<"system_event"> | string
    action?: StringWithAggregatesFilter<"system_event"> | string
    event_data?: JsonNullableWithAggregatesFilter<"system_event">
    created_at?: DateTimeWithAggregatesFilter<"system_event"> | Date | string
    processed_at?: DateTimeNullableWithAggregatesFilter<"system_event"> | Date | string | null
    status?: StringWithAggregatesFilter<"system_event"> | string
  }

  export type tenant_access_logsWhereInput = {
    AND?: tenant_access_logsWhereInput | tenant_access_logsWhereInput[]
    OR?: tenant_access_logsWhereInput[]
    NOT?: tenant_access_logsWhereInput | tenant_access_logsWhereInput[]
    id?: StringFilter<"tenant_access_logs"> | string
    tenant_id?: StringFilter<"tenant_access_logs"> | string
    user_id?: StringNullableFilter<"tenant_access_logs"> | string | null
    action?: StringFilter<"tenant_access_logs"> | string
    resource?: StringNullableFilter<"tenant_access_logs"> | string | null
    ip_address?: StringNullableFilter<"tenant_access_logs"> | string | null
    user_agent?: StringNullableFilter<"tenant_access_logs"> | string | null
    created_at?: DateTimeFilter<"tenant_access_logs"> | Date | string
    source_system?: StringNullableFilter<"tenant_access_logs"> | string | null
  }

  export type tenant_access_logsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    source_system?: SortOrderInput | SortOrder
  }

  export type tenant_access_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tenant_access_logsWhereInput | tenant_access_logsWhereInput[]
    OR?: tenant_access_logsWhereInput[]
    NOT?: tenant_access_logsWhereInput | tenant_access_logsWhereInput[]
    tenant_id?: StringFilter<"tenant_access_logs"> | string
    user_id?: StringNullableFilter<"tenant_access_logs"> | string | null
    action?: StringFilter<"tenant_access_logs"> | string
    resource?: StringNullableFilter<"tenant_access_logs"> | string | null
    ip_address?: StringNullableFilter<"tenant_access_logs"> | string | null
    user_agent?: StringNullableFilter<"tenant_access_logs"> | string | null
    created_at?: DateTimeFilter<"tenant_access_logs"> | Date | string
    source_system?: StringNullableFilter<"tenant_access_logs"> | string | null
  }, "id">

  export type tenant_access_logsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    source_system?: SortOrderInput | SortOrder
    _count?: tenant_access_logsCountOrderByAggregateInput
    _max?: tenant_access_logsMaxOrderByAggregateInput
    _min?: tenant_access_logsMinOrderByAggregateInput
  }

  export type tenant_access_logsScalarWhereWithAggregatesInput = {
    AND?: tenant_access_logsScalarWhereWithAggregatesInput | tenant_access_logsScalarWhereWithAggregatesInput[]
    OR?: tenant_access_logsScalarWhereWithAggregatesInput[]
    NOT?: tenant_access_logsScalarWhereWithAggregatesInput | tenant_access_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tenant_access_logs"> | string
    tenant_id?: StringWithAggregatesFilter<"tenant_access_logs"> | string
    user_id?: StringNullableWithAggregatesFilter<"tenant_access_logs"> | string | null
    action?: StringWithAggregatesFilter<"tenant_access_logs"> | string
    resource?: StringNullableWithAggregatesFilter<"tenant_access_logs"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"tenant_access_logs"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"tenant_access_logs"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"tenant_access_logs"> | Date | string
    source_system?: StringNullableWithAggregatesFilter<"tenant_access_logs"> | string | null
  }

  export type tenant_servicesWhereInput = {
    AND?: tenant_servicesWhereInput | tenant_servicesWhereInput[]
    OR?: tenant_servicesWhereInput[]
    NOT?: tenant_servicesWhereInput | tenant_servicesWhereInput[]
    id?: StringFilter<"tenant_services"> | string
    tenant_id?: StringFilter<"tenant_services"> | string
    service_type?: StringFilter<"tenant_services"> | string
    plan_type?: StringFilter<"tenant_services"> | string
    is_active?: BoolFilter<"tenant_services"> | boolean
    activated_at?: DateTimeFilter<"tenant_services"> | Date | string
    expires_at?: DateTimeNullableFilter<"tenant_services"> | Date | string | null
    service_config?: JsonFilter<"tenant_services">
    created_at?: DateTimeFilter<"tenant_services"> | Date | string
    updated_at?: DateTimeFilter<"tenant_services"> | Date | string
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type tenant_servicesOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    is_active?: SortOrder
    activated_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    service_config?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    Tenant?: TenantOrderByWithRelationInput
  }

  export type tenant_servicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_service_type?: tenant_servicesTenant_idService_typeCompoundUniqueInput
    AND?: tenant_servicesWhereInput | tenant_servicesWhereInput[]
    OR?: tenant_servicesWhereInput[]
    NOT?: tenant_servicesWhereInput | tenant_servicesWhereInput[]
    tenant_id?: StringFilter<"tenant_services"> | string
    service_type?: StringFilter<"tenant_services"> | string
    plan_type?: StringFilter<"tenant_services"> | string
    is_active?: BoolFilter<"tenant_services"> | boolean
    activated_at?: DateTimeFilter<"tenant_services"> | Date | string
    expires_at?: DateTimeNullableFilter<"tenant_services"> | Date | string | null
    service_config?: JsonFilter<"tenant_services">
    created_at?: DateTimeFilter<"tenant_services"> | Date | string
    updated_at?: DateTimeFilter<"tenant_services"> | Date | string
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenant_id_service_type">

  export type tenant_servicesOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    is_active?: SortOrder
    activated_at?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    service_config?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tenant_servicesCountOrderByAggregateInput
    _max?: tenant_servicesMaxOrderByAggregateInput
    _min?: tenant_servicesMinOrderByAggregateInput
  }

  export type tenant_servicesScalarWhereWithAggregatesInput = {
    AND?: tenant_servicesScalarWhereWithAggregatesInput | tenant_servicesScalarWhereWithAggregatesInput[]
    OR?: tenant_servicesScalarWhereWithAggregatesInput[]
    NOT?: tenant_servicesScalarWhereWithAggregatesInput | tenant_servicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tenant_services"> | string
    tenant_id?: StringWithAggregatesFilter<"tenant_services"> | string
    service_type?: StringWithAggregatesFilter<"tenant_services"> | string
    plan_type?: StringWithAggregatesFilter<"tenant_services"> | string
    is_active?: BoolWithAggregatesFilter<"tenant_services"> | boolean
    activated_at?: DateTimeWithAggregatesFilter<"tenant_services"> | Date | string
    expires_at?: DateTimeNullableWithAggregatesFilter<"tenant_services"> | Date | string | null
    service_config?: JsonWithAggregatesFilter<"tenant_services">
    created_at?: DateTimeWithAggregatesFilter<"tenant_services"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tenant_services"> | Date | string
  }

  export type checkin_sessionsWhereInput = {
    AND?: checkin_sessionsWhereInput | checkin_sessionsWhereInput[]
    OR?: checkin_sessionsWhereInput[]
    NOT?: checkin_sessionsWhereInput | checkin_sessionsWhereInput[]
    id?: StringFilter<"checkin_sessions"> | string
    tenant_id?: StringFilter<"checkin_sessions"> | string
    session_number?: StringFilter<"checkin_sessions"> | string
    reservation_id?: StringNullableFilter<"checkin_sessions"> | string | null
    room_id?: StringFilter<"checkin_sessions"> | string
    guest_info?: JsonFilter<"checkin_sessions">
    adults?: IntFilter<"checkin_sessions"> | number
    children?: IntFilter<"checkin_sessions"> | number
    check_in_at?: DateTimeFilter<"checkin_sessions"> | Date | string
    check_out_at?: DateTimeNullableFilter<"checkin_sessions"> | Date | string | null
    planned_check_out?: DateTimeFilter<"checkin_sessions"> | Date | string
    status?: StringFilter<"checkin_sessions"> | string
    special_requests?: StringNullableFilter<"checkin_sessions"> | string | null
    notes?: StringNullableFilter<"checkin_sessions"> | string | null
    created_at?: DateTimeFilter<"checkin_sessions"> | Date | string
    updated_at?: DateTimeFilter<"checkin_sessions"> | Date | string
  }

  export type checkin_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_number?: SortOrder
    reservation_id?: SortOrderInput | SortOrder
    room_id?: SortOrder
    guest_info?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    check_in_at?: SortOrder
    check_out_at?: SortOrderInput | SortOrder
    planned_check_out?: SortOrder
    status?: SortOrder
    special_requests?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type checkin_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    session_number?: string
    AND?: checkin_sessionsWhereInput | checkin_sessionsWhereInput[]
    OR?: checkin_sessionsWhereInput[]
    NOT?: checkin_sessionsWhereInput | checkin_sessionsWhereInput[]
    tenant_id?: StringFilter<"checkin_sessions"> | string
    reservation_id?: StringNullableFilter<"checkin_sessions"> | string | null
    room_id?: StringFilter<"checkin_sessions"> | string
    guest_info?: JsonFilter<"checkin_sessions">
    adults?: IntFilter<"checkin_sessions"> | number
    children?: IntFilter<"checkin_sessions"> | number
    check_in_at?: DateTimeFilter<"checkin_sessions"> | Date | string
    check_out_at?: DateTimeNullableFilter<"checkin_sessions"> | Date | string | null
    planned_check_out?: DateTimeFilter<"checkin_sessions"> | Date | string
    status?: StringFilter<"checkin_sessions"> | string
    special_requests?: StringNullableFilter<"checkin_sessions"> | string | null
    notes?: StringNullableFilter<"checkin_sessions"> | string | null
    created_at?: DateTimeFilter<"checkin_sessions"> | Date | string
    updated_at?: DateTimeFilter<"checkin_sessions"> | Date | string
  }, "id" | "session_number">

  export type checkin_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_number?: SortOrder
    reservation_id?: SortOrderInput | SortOrder
    room_id?: SortOrder
    guest_info?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    check_in_at?: SortOrder
    check_out_at?: SortOrderInput | SortOrder
    planned_check_out?: SortOrder
    status?: SortOrder
    special_requests?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: checkin_sessionsCountOrderByAggregateInput
    _avg?: checkin_sessionsAvgOrderByAggregateInput
    _max?: checkin_sessionsMaxOrderByAggregateInput
    _min?: checkin_sessionsMinOrderByAggregateInput
    _sum?: checkin_sessionsSumOrderByAggregateInput
  }

  export type checkin_sessionsScalarWhereWithAggregatesInput = {
    AND?: checkin_sessionsScalarWhereWithAggregatesInput | checkin_sessionsScalarWhereWithAggregatesInput[]
    OR?: checkin_sessionsScalarWhereWithAggregatesInput[]
    NOT?: checkin_sessionsScalarWhereWithAggregatesInput | checkin_sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"checkin_sessions"> | string
    tenant_id?: StringWithAggregatesFilter<"checkin_sessions"> | string
    session_number?: StringWithAggregatesFilter<"checkin_sessions"> | string
    reservation_id?: StringNullableWithAggregatesFilter<"checkin_sessions"> | string | null
    room_id?: StringWithAggregatesFilter<"checkin_sessions"> | string
    guest_info?: JsonWithAggregatesFilter<"checkin_sessions">
    adults?: IntWithAggregatesFilter<"checkin_sessions"> | number
    children?: IntWithAggregatesFilter<"checkin_sessions"> | number
    check_in_at?: DateTimeWithAggregatesFilter<"checkin_sessions"> | Date | string
    check_out_at?: DateTimeNullableWithAggregatesFilter<"checkin_sessions"> | Date | string | null
    planned_check_out?: DateTimeWithAggregatesFilter<"checkin_sessions"> | Date | string
    status?: StringWithAggregatesFilter<"checkin_sessions"> | string
    special_requests?: StringNullableWithAggregatesFilter<"checkin_sessions"> | string | null
    notes?: StringNullableWithAggregatesFilter<"checkin_sessions"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"checkin_sessions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"checkin_sessions"> | Date | string
  }

  export type session_billingsWhereInput = {
    AND?: session_billingsWhereInput | session_billingsWhereInput[]
    OR?: session_billingsWhereInput[]
    NOT?: session_billingsWhereInput | session_billingsWhereInput[]
    id?: StringFilter<"session_billings"> | string
    tenant_id?: StringFilter<"session_billings"> | string
    session_id?: StringFilter<"session_billings"> | string
    billing_number?: StringFilter<"session_billings"> | string
    room_charges?: JsonFilter<"session_billings">
    service_charges?: JsonFilter<"session_billings">
    taxes?: JsonFilter<"session_billings">
    discounts?: JsonFilter<"session_billings">
    subtotal_amount?: IntFilter<"session_billings"> | number
    tax_amount?: IntFilter<"session_billings"> | number
    total_amount?: IntFilter<"session_billings"> | number
    paid_amount?: IntFilter<"session_billings"> | number
    status?: StringFilter<"session_billings"> | string
    payment_method?: StringNullableFilter<"session_billings"> | string | null
    payment_date?: DateTimeNullableFilter<"session_billings"> | Date | string | null
    due_date?: DateTimeFilter<"session_billings"> | Date | string
    notes?: StringNullableFilter<"session_billings"> | string | null
    created_at?: DateTimeFilter<"session_billings"> | Date | string
    updated_at?: DateTimeFilter<"session_billings"> | Date | string
  }

  export type session_billingsOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_id?: SortOrder
    billing_number?: SortOrder
    room_charges?: SortOrder
    service_charges?: SortOrder
    taxes?: SortOrder
    discounts?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    paid_amount?: SortOrder
    status?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_date?: SortOrderInput | SortOrder
    due_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type session_billingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    billing_number?: string
    AND?: session_billingsWhereInput | session_billingsWhereInput[]
    OR?: session_billingsWhereInput[]
    NOT?: session_billingsWhereInput | session_billingsWhereInput[]
    tenant_id?: StringFilter<"session_billings"> | string
    session_id?: StringFilter<"session_billings"> | string
    room_charges?: JsonFilter<"session_billings">
    service_charges?: JsonFilter<"session_billings">
    taxes?: JsonFilter<"session_billings">
    discounts?: JsonFilter<"session_billings">
    subtotal_amount?: IntFilter<"session_billings"> | number
    tax_amount?: IntFilter<"session_billings"> | number
    total_amount?: IntFilter<"session_billings"> | number
    paid_amount?: IntFilter<"session_billings"> | number
    status?: StringFilter<"session_billings"> | string
    payment_method?: StringNullableFilter<"session_billings"> | string | null
    payment_date?: DateTimeNullableFilter<"session_billings"> | Date | string | null
    due_date?: DateTimeFilter<"session_billings"> | Date | string
    notes?: StringNullableFilter<"session_billings"> | string | null
    created_at?: DateTimeFilter<"session_billings"> | Date | string
    updated_at?: DateTimeFilter<"session_billings"> | Date | string
  }, "id" | "billing_number">

  export type session_billingsOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_id?: SortOrder
    billing_number?: SortOrder
    room_charges?: SortOrder
    service_charges?: SortOrder
    taxes?: SortOrder
    discounts?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    paid_amount?: SortOrder
    status?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_date?: SortOrderInput | SortOrder
    due_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: session_billingsCountOrderByAggregateInput
    _avg?: session_billingsAvgOrderByAggregateInput
    _max?: session_billingsMaxOrderByAggregateInput
    _min?: session_billingsMinOrderByAggregateInput
    _sum?: session_billingsSumOrderByAggregateInput
  }

  export type session_billingsScalarWhereWithAggregatesInput = {
    AND?: session_billingsScalarWhereWithAggregatesInput | session_billingsScalarWhereWithAggregatesInput[]
    OR?: session_billingsScalarWhereWithAggregatesInput[]
    NOT?: session_billingsScalarWhereWithAggregatesInput | session_billingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session_billings"> | string
    tenant_id?: StringWithAggregatesFilter<"session_billings"> | string
    session_id?: StringWithAggregatesFilter<"session_billings"> | string
    billing_number?: StringWithAggregatesFilter<"session_billings"> | string
    room_charges?: JsonWithAggregatesFilter<"session_billings">
    service_charges?: JsonWithAggregatesFilter<"session_billings">
    taxes?: JsonWithAggregatesFilter<"session_billings">
    discounts?: JsonWithAggregatesFilter<"session_billings">
    subtotal_amount?: IntWithAggregatesFilter<"session_billings"> | number
    tax_amount?: IntWithAggregatesFilter<"session_billings"> | number
    total_amount?: IntWithAggregatesFilter<"session_billings"> | number
    paid_amount?: IntWithAggregatesFilter<"session_billings"> | number
    status?: StringWithAggregatesFilter<"session_billings"> | string
    payment_method?: StringNullableWithAggregatesFilter<"session_billings"> | string | null
    payment_date?: DateTimeNullableWithAggregatesFilter<"session_billings"> | Date | string | null
    due_date?: DateTimeWithAggregatesFilter<"session_billings"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"session_billings"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"session_billings"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"session_billings"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    tenantId?: StringFilter<"Room"> | string
    roomNumber?: StringFilter<"Room"> | string
    roomType?: StringFilter<"Room"> | string
    floor?: IntNullableFilter<"Room"> | number | null
    status?: StringFilter<"Room"> | string
    capacity?: IntFilter<"Room"> | number
    amenities?: JsonNullableFilter<"Room">
    notes?: StringNullableFilter<"Room"> | string | null
    lastCleaned?: DateTimeNullableFilter<"Room"> | Date | string | null
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    isDeleted?: BoolFilter<"Room"> | boolean
    deletedAt?: DateTimeNullableFilter<"Room"> | Date | string | null
    deletedBy?: StringNullableFilter<"Room"> | string | null
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomNumber?: SortOrder
    roomType?: SortOrder
    floor?: SortOrderInput | SortOrder
    status?: SortOrder
    capacity?: SortOrder
    amenities?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    lastCleaned?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_roomNumber?: RoomTenantIdRoomNumberCompoundUniqueInput
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    tenantId?: StringFilter<"Room"> | string
    roomNumber?: StringFilter<"Room"> | string
    roomType?: StringFilter<"Room"> | string
    floor?: IntNullableFilter<"Room"> | number | null
    status?: StringFilter<"Room"> | string
    capacity?: IntFilter<"Room"> | number
    amenities?: JsonNullableFilter<"Room">
    notes?: StringNullableFilter<"Room"> | string | null
    lastCleaned?: DateTimeNullableFilter<"Room"> | Date | string | null
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    isDeleted?: BoolFilter<"Room"> | boolean
    deletedAt?: DateTimeNullableFilter<"Room"> | Date | string | null
    deletedBy?: StringNullableFilter<"Room"> | string | null
  }, "id" | "tenantId_roomNumber">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomNumber?: SortOrder
    roomType?: SortOrder
    floor?: SortOrderInput | SortOrder
    status?: SortOrder
    capacity?: SortOrder
    amenities?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    lastCleaned?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    tenantId?: StringWithAggregatesFilter<"Room"> | string
    roomNumber?: StringWithAggregatesFilter<"Room"> | string
    roomType?: StringWithAggregatesFilter<"Room"> | string
    floor?: IntNullableWithAggregatesFilter<"Room"> | number | null
    status?: StringWithAggregatesFilter<"Room"> | string
    capacity?: IntWithAggregatesFilter<"Room"> | number
    amenities?: JsonNullableWithAggregatesFilter<"Room">
    notes?: StringNullableWithAggregatesFilter<"Room"> | string | null
    lastCleaned?: DateTimeNullableWithAggregatesFilter<"Room"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Room"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Room"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Room"> | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    type?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    taxAmount?: IntFilter<"Transaction"> | number
    totalAmount?: IntFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    reference?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    createdBy?: StringNullableFilter<"Transaction"> | string | null
    isDeleted?: BoolFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    deletedBy?: StringNullableFilter<"Transaction"> | string | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    tenantId?: StringFilter<"Transaction"> | string
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    type?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    taxAmount?: IntFilter<"Transaction"> | number
    totalAmount?: IntFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    reference?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    createdBy?: StringNullableFilter<"Transaction"> | string | null
    isDeleted?: BoolFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    deletedBy?: StringNullableFilter<"Transaction"> | string | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    tenantId?: StringWithAggregatesFilter<"Transaction"> | string
    invoiceId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    type?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: IntWithAggregatesFilter<"Transaction"> | number
    taxAmount?: IntWithAggregatesFilter<"Transaction"> | number
    totalAmount?: IntWithAggregatesFilter<"Transaction"> | number
    status?: StringWithAggregatesFilter<"Transaction"> | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Transaction">
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    customerId?: StringNullableFilter<"Invoice"> | string | null
    customerName?: StringFilter<"Invoice"> | string
    customerEmail?: StringNullableFilter<"Invoice"> | string | null
    billingAddress?: JsonNullableFilter<"Invoice">
    items?: JsonFilter<"Invoice">
    subtotal?: IntFilter<"Invoice"> | number
    taxAmount?: IntFilter<"Invoice"> | number
    totalAmount?: IntFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    issuedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    metadata?: JsonNullableFilter<"Invoice">
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdBy?: StringNullableFilter<"Invoice"> | string | null
    isDeleted?: BoolFilter<"Invoice"> | boolean
    deletedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    deletedBy?: StringNullableFilter<"Invoice"> | string | null
    transactions?: TransactionListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    issuedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    tenantId?: StringFilter<"Invoice"> | string
    customerId?: StringNullableFilter<"Invoice"> | string | null
    customerName?: StringFilter<"Invoice"> | string
    customerEmail?: StringNullableFilter<"Invoice"> | string | null
    billingAddress?: JsonNullableFilter<"Invoice">
    items?: JsonFilter<"Invoice">
    subtotal?: IntFilter<"Invoice"> | number
    taxAmount?: IntFilter<"Invoice"> | number
    totalAmount?: IntFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    issuedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    notes?: StringNullableFilter<"Invoice"> | string | null
    metadata?: JsonNullableFilter<"Invoice">
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdBy?: StringNullableFilter<"Invoice"> | string | null
    isDeleted?: BoolFilter<"Invoice"> | boolean
    deletedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    deletedBy?: StringNullableFilter<"Invoice"> | string | null
    transactions?: TransactionListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    issuedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    tenantId?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    customerId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    customerName?: StringWithAggregatesFilter<"Invoice"> | string
    customerEmail?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    billingAddress?: JsonNullableWithAggregatesFilter<"Invoice">
    items?: JsonWithAggregatesFilter<"Invoice">
    subtotal?: IntWithAggregatesFilter<"Invoice"> | number
    taxAmount?: IntWithAggregatesFilter<"Invoice"> | number
    totalAmount?: IntWithAggregatesFilter<"Invoice"> | number
    status?: StringWithAggregatesFilter<"Invoice"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    issuedAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Invoice">
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Invoice"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    tenantId?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    paymentMethod?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    createdBy?: StringNullableFilter<"Payment"> | string | null
    isDeleted?: BoolFilter<"Payment"> | boolean
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    deletedBy?: StringNullableFilter<"Payment"> | string | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    tenantId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    paymentMethod?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    createdBy?: StringNullableFilter<"Payment"> | string | null
    isDeleted?: BoolFilter<"Payment"> | boolean
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    deletedBy?: StringNullableFilter<"Payment"> | string | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
  }, "id" | "transactionId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    tenantId?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    amount?: IntWithAggregatesFilter<"Payment"> | number
    status?: StringWithAggregatesFilter<"Payment"> | string
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Payment"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type DatabaseChangeLogCreateInput = {
    changeType: string
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type DatabaseChangeLogUncheckedCreateInput = {
    id?: number
    changeType: string
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type DatabaseChangeLogUpdateInput = {
    changeType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseChangeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseChangeLogCreateManyInput = {
    id?: number
    changeType: string
    description: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type DatabaseChangeLogUpdateManyMutationInput = {
    changeType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseChangeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    tenantId: string
    roomId: string
    placeId?: number | null
    status?: string
    items: JsonNullValueInput | InputJsonValue
    total: number
    createdAt?: Date | string
    updatedAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    uuid?: string | null
    sessionId?: string | null
    OrderItem?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    tenantId: string
    roomId: string
    placeId?: number | null
    status?: string
    items: JsonNullValueInput | InputJsonValue
    total: number
    createdAt?: Date | string
    updatedAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    uuid?: string | null
    sessionId?: string | null
    OrderItem?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    OrderItem?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    OrderItem?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    tenantId: string
    roomId: string
    placeId?: number | null
    status?: string
    items: JsonNullValueInput | InputJsonValue
    total: number
    createdAt?: Date | string
    updatedAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    uuid?: string | null
    sessionId?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    tenantId: string
    menuItemId: number
    name: string
    price: number
    quantity: number
    status?: string
    notes?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    Order: OrderCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    tenantId: string
    orderId: number
    menuItemId: number
    name: string
    price: number
    quantity: number
    status?: string
    notes?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type OrderItemUpdateInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    menuItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    Order?: OrderUpdateOneRequiredWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: IntFieldUpdateOperationsInput | number
    menuItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemCreateManyInput = {
    id?: number
    tenantId: string
    orderId: number
    menuItemId: number
    name: string
    price: number
    quantity: number
    status?: string
    notes?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type OrderItemUpdateManyMutationInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    menuItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: IntFieldUpdateOperationsInput | number
    menuItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemPlanRestrictionsCreateInput = {
    id: string
    systemType: string
    businessType: string
    planType: string
    planCategory: string
    monthlyPrice: number
    maxDevices?: number
    additionalDeviceCost?: number
    roomTerminalCost?: number
    frontDeskCost?: number
    kitchenCost?: number
    barCost?: number
    housekeepingCost?: number
    managerCost?: number
    commonAreaCost?: number
    enableAiConcierge?: boolean
    enableMultilingual?: boolean
    enableLayoutEditor?: boolean
    enableFacilityGuide?: boolean
    enableAiBusinessSupport?: boolean
    maxMonthlyOrders?: number
    maxMonthlyAiRequests?: number
    maxStorageGB?: number
    multilingualUpgradePrice?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    TenantSystemPlan?: TenantSystemPlanCreateNestedManyWithoutSystemPlanRestrictionsInput
  }

  export type SystemPlanRestrictionsUncheckedCreateInput = {
    id: string
    systemType: string
    businessType: string
    planType: string
    planCategory: string
    monthlyPrice: number
    maxDevices?: number
    additionalDeviceCost?: number
    roomTerminalCost?: number
    frontDeskCost?: number
    kitchenCost?: number
    barCost?: number
    housekeepingCost?: number
    managerCost?: number
    commonAreaCost?: number
    enableAiConcierge?: boolean
    enableMultilingual?: boolean
    enableLayoutEditor?: boolean
    enableFacilityGuide?: boolean
    enableAiBusinessSupport?: boolean
    maxMonthlyOrders?: number
    maxMonthlyAiRequests?: number
    maxStorageGB?: number
    multilingualUpgradePrice?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    TenantSystemPlan?: TenantSystemPlanUncheckedCreateNestedManyWithoutSystemPlanRestrictionsInput
  }

  export type SystemPlanRestrictionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    planCategory?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    maxDevices?: IntFieldUpdateOperationsInput | number
    additionalDeviceCost?: IntFieldUpdateOperationsInput | number
    roomTerminalCost?: IntFieldUpdateOperationsInput | number
    frontDeskCost?: IntFieldUpdateOperationsInput | number
    kitchenCost?: IntFieldUpdateOperationsInput | number
    barCost?: IntFieldUpdateOperationsInput | number
    housekeepingCost?: IntFieldUpdateOperationsInput | number
    managerCost?: IntFieldUpdateOperationsInput | number
    commonAreaCost?: IntFieldUpdateOperationsInput | number
    enableAiConcierge?: BoolFieldUpdateOperationsInput | boolean
    enableMultilingual?: BoolFieldUpdateOperationsInput | boolean
    enableLayoutEditor?: BoolFieldUpdateOperationsInput | boolean
    enableFacilityGuide?: BoolFieldUpdateOperationsInput | boolean
    enableAiBusinessSupport?: BoolFieldUpdateOperationsInput | boolean
    maxMonthlyOrders?: IntFieldUpdateOperationsInput | number
    maxMonthlyAiRequests?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    multilingualUpgradePrice?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    TenantSystemPlan?: TenantSystemPlanUpdateManyWithoutSystemPlanRestrictionsNestedInput
  }

  export type SystemPlanRestrictionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    planCategory?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    maxDevices?: IntFieldUpdateOperationsInput | number
    additionalDeviceCost?: IntFieldUpdateOperationsInput | number
    roomTerminalCost?: IntFieldUpdateOperationsInput | number
    frontDeskCost?: IntFieldUpdateOperationsInput | number
    kitchenCost?: IntFieldUpdateOperationsInput | number
    barCost?: IntFieldUpdateOperationsInput | number
    housekeepingCost?: IntFieldUpdateOperationsInput | number
    managerCost?: IntFieldUpdateOperationsInput | number
    commonAreaCost?: IntFieldUpdateOperationsInput | number
    enableAiConcierge?: BoolFieldUpdateOperationsInput | boolean
    enableMultilingual?: BoolFieldUpdateOperationsInput | boolean
    enableLayoutEditor?: BoolFieldUpdateOperationsInput | boolean
    enableFacilityGuide?: BoolFieldUpdateOperationsInput | boolean
    enableAiBusinessSupport?: BoolFieldUpdateOperationsInput | boolean
    maxMonthlyOrders?: IntFieldUpdateOperationsInput | number
    maxMonthlyAiRequests?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    multilingualUpgradePrice?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    TenantSystemPlan?: TenantSystemPlanUncheckedUpdateManyWithoutSystemPlanRestrictionsNestedInput
  }

  export type SystemPlanRestrictionsCreateManyInput = {
    id: string
    systemType: string
    businessType: string
    planType: string
    planCategory: string
    monthlyPrice: number
    maxDevices?: number
    additionalDeviceCost?: number
    roomTerminalCost?: number
    frontDeskCost?: number
    kitchenCost?: number
    barCost?: number
    housekeepingCost?: number
    managerCost?: number
    commonAreaCost?: number
    enableAiConcierge?: boolean
    enableMultilingual?: boolean
    enableLayoutEditor?: boolean
    enableFacilityGuide?: boolean
    enableAiBusinessSupport?: boolean
    maxMonthlyOrders?: number
    maxMonthlyAiRequests?: number
    maxStorageGB?: number
    multilingualUpgradePrice?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type SystemPlanRestrictionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    planCategory?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    maxDevices?: IntFieldUpdateOperationsInput | number
    additionalDeviceCost?: IntFieldUpdateOperationsInput | number
    roomTerminalCost?: IntFieldUpdateOperationsInput | number
    frontDeskCost?: IntFieldUpdateOperationsInput | number
    kitchenCost?: IntFieldUpdateOperationsInput | number
    barCost?: IntFieldUpdateOperationsInput | number
    housekeepingCost?: IntFieldUpdateOperationsInput | number
    managerCost?: IntFieldUpdateOperationsInput | number
    commonAreaCost?: IntFieldUpdateOperationsInput | number
    enableAiConcierge?: BoolFieldUpdateOperationsInput | boolean
    enableMultilingual?: BoolFieldUpdateOperationsInput | boolean
    enableLayoutEditor?: BoolFieldUpdateOperationsInput | boolean
    enableFacilityGuide?: BoolFieldUpdateOperationsInput | boolean
    enableAiBusinessSupport?: BoolFieldUpdateOperationsInput | boolean
    maxMonthlyOrders?: IntFieldUpdateOperationsInput | number
    maxMonthlyAiRequests?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    multilingualUpgradePrice?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemPlanRestrictionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    planCategory?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    maxDevices?: IntFieldUpdateOperationsInput | number
    additionalDeviceCost?: IntFieldUpdateOperationsInput | number
    roomTerminalCost?: IntFieldUpdateOperationsInput | number
    frontDeskCost?: IntFieldUpdateOperationsInput | number
    kitchenCost?: IntFieldUpdateOperationsInput | number
    barCost?: IntFieldUpdateOperationsInput | number
    housekeepingCost?: IntFieldUpdateOperationsInput | number
    managerCost?: IntFieldUpdateOperationsInput | number
    commonAreaCost?: IntFieldUpdateOperationsInput | number
    enableAiConcierge?: BoolFieldUpdateOperationsInput | boolean
    enableMultilingual?: BoolFieldUpdateOperationsInput | boolean
    enableLayoutEditor?: BoolFieldUpdateOperationsInput | boolean
    enableFacilityGuide?: BoolFieldUpdateOperationsInput | boolean
    enableAiBusinessSupport?: BoolFieldUpdateOperationsInput | boolean
    maxMonthlyOrders?: IntFieldUpdateOperationsInput | number
    maxMonthlyAiRequests?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    multilingualUpgradePrice?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantCreateInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanCreateNestedManyWithoutTenantInput
    device_rooms?: device_roomsCreateNestedManyWithoutTenantInput
    pages?: pagesCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanUncheckedCreateNestedManyWithoutTenantInput
    device_rooms?: device_roomsUncheckedCreateNestedManyWithoutTenantInput
    pages?: pagesUncheckedCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsUncheckedCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUpdateManyWithoutTenantNestedInput
    device_rooms?: device_roomsUpdateManyWithoutTenantNestedInput
    pages?: pagesUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUncheckedUpdateManyWithoutTenantNestedInput
    device_rooms?: device_roomsUncheckedUpdateManyWithoutTenantNestedInput
    pages?: pagesUncheckedUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUncheckedUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TenantSystemPlanCreateInput = {
    id: string
    systemType: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    monthlyPrice: number
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    SystemPlanRestrictions: SystemPlanRestrictionsCreateNestedOneWithoutTenantSystemPlanInput
    Tenant: TenantCreateNestedOneWithoutTenantSystemPlanInput
  }

  export type TenantSystemPlanUncheckedCreateInput = {
    id: string
    tenantId: string
    systemType: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    monthlyPrice: number
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type TenantSystemPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    SystemPlanRestrictions?: SystemPlanRestrictionsUpdateOneRequiredWithoutTenantSystemPlanNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutTenantSystemPlanNestedInput
  }

  export type TenantSystemPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantSystemPlanCreateManyInput = {
    id: string
    tenantId: string
    systemType: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    monthlyPrice: number
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type TenantSystemPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantSystemPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type adminCreateInput = {
    id: string
    email: string
    username: string
    display_name: string
    password_hash: string
    admin_level: $Enums.AdminLevel
    accessible_group_ids?: adminCreateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminCreateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminCreateaccessible_tenant_idsInput | string[]
    last_login_at?: Date | string | null
    login_attempts?: number
    locked_until?: Date | string | null
    totp_secret?: string | null
    totp_enabled?: boolean
    created_at?: Date | string
    updated_at: Date | string
    created_by?: string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    admin_log?: admin_logCreateNestedManyWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    id: string
    email: string
    username: string
    display_name: string
    password_hash: string
    admin_level: $Enums.AdminLevel
    accessible_group_ids?: adminCreateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminCreateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminCreateaccessible_tenant_idsInput | string[]
    last_login_at?: Date | string | null
    login_attempts?: number
    locked_until?: Date | string | null
    totp_secret?: string | null
    totp_enabled?: boolean
    created_at?: Date | string
    updated_at: Date | string
    created_by?: string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    admin_log?: admin_logUncheckedCreateNestedManyWithoutAdminInput
  }

  export type adminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_level?: EnumAdminLevelFieldUpdateOperationsInput | $Enums.AdminLevel
    accessible_group_ids?: adminUpdateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminUpdateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminUpdateaccessible_tenant_idsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    totp_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    admin_log?: admin_logUpdateManyWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_level?: EnumAdminLevelFieldUpdateOperationsInput | $Enums.AdminLevel
    accessible_group_ids?: adminUpdateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminUpdateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminUpdateaccessible_tenant_idsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    totp_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    admin_log?: admin_logUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type adminCreateManyInput = {
    id: string
    email: string
    username: string
    display_name: string
    password_hash: string
    admin_level: $Enums.AdminLevel
    accessible_group_ids?: adminCreateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminCreateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminCreateaccessible_tenant_idsInput | string[]
    last_login_at?: Date | string | null
    login_attempts?: number
    locked_until?: Date | string | null
    totp_secret?: string | null
    totp_enabled?: boolean
    created_at?: Date | string
    updated_at: Date | string
    created_by?: string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type adminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_level?: EnumAdminLevelFieldUpdateOperationsInput | $Enums.AdminLevel
    accessible_group_ids?: adminUpdateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminUpdateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminUpdateaccessible_tenant_idsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    totp_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type adminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_level?: EnumAdminLevelFieldUpdateOperationsInput | $Enums.AdminLevel
    accessible_group_ids?: adminUpdateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminUpdateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminUpdateaccessible_tenant_idsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    totp_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_logCreateInput = {
    id: string
    action: string
    target_type?: string | null
    target_id?: string | null
    ip_address?: string | null
    user_agent?: string | null
    success?: boolean
    error_message?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    admin: adminCreateNestedOneWithoutAdmin_logInput
  }

  export type admin_logUncheckedCreateInput = {
    id: string
    admin_id: string
    action: string
    target_type?: string | null
    target_id?: string | null
    ip_address?: string | null
    user_agent?: string | null
    success?: boolean
    error_message?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type admin_logUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    admin?: adminUpdateOneRequiredWithoutAdmin_logNestedInput
  }

  export type admin_logUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admin_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_logCreateManyInput = {
    id: string
    admin_id: string
    action: string
    target_type?: string | null
    target_id?: string | null
    ip_address?: string | null
    user_agent?: string | null
    success?: boolean
    error_message?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type admin_logUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_logUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    admin_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_categoriesCreateInput = {
    id: string
    tenantId: string
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsCreateNestedManyWithoutCampaign_categoriesInput
  }

  export type campaign_categoriesUncheckedCreateInput = {
    id: string
    tenantId: string
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsUncheckedCreateNestedManyWithoutCampaign_categoriesInput
  }

  export type campaign_categoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUpdateManyWithoutCampaign_categoriesNestedInput
  }

  export type campaign_categoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUncheckedUpdateManyWithoutCampaign_categoriesNestedInput
  }

  export type campaign_categoriesCreateManyInput = {
    id: string
    tenantId: string
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_categoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_categoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_category_relationsCreateInput = {
    id: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaigns: campaignsCreateNestedOneWithoutCampaign_category_relationsInput
    campaign_categories: campaign_categoriesCreateNestedOneWithoutCampaign_category_relationsInput
  }

  export type campaign_category_relationsUncheckedCreateInput = {
    id: string
    campaignId: string
    categoryId: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_category_relationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: campaignsUpdateOneRequiredWithoutCampaign_category_relationsNestedInput
    campaign_categories?: campaign_categoriesUpdateOneRequiredWithoutCampaign_category_relationsNestedInput
  }

  export type campaign_category_relationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_category_relationsCreateManyInput = {
    id: string
    campaignId: string
    categoryId: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_category_relationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_category_relationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_itemsCreateInput = {
    id: string
    itemId: string
    itemType: string
    priority?: number
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaigns: campaignsCreateNestedOneWithoutCampaign_itemsInput
  }

  export type campaign_itemsUncheckedCreateInput = {
    id: string
    campaignId: string
    itemId: string
    itemType: string
    priority?: number
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_itemsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: campaignsUpdateOneRequiredWithoutCampaign_itemsNestedInput
  }

  export type campaign_itemsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_itemsCreateManyInput = {
    id: string
    campaignId: string
    itemId: string
    itemType: string
    priority?: number
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_itemsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_itemsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_translationsCreateInput = {
    id: string
    locale: string
    title: string
    description?: string | null
    imageUrl?: string | null
    languageCode?: string | null
    name?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaigns: campaignsCreateNestedOneWithoutCampaign_translationsInput
  }

  export type campaign_translationsUncheckedCreateInput = {
    id: string
    campaignId: string
    locale: string
    title: string
    description?: string | null
    imageUrl?: string | null
    languageCode?: string | null
    name?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_translationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: campaignsUpdateOneRequiredWithoutCampaign_translationsNestedInput
  }

  export type campaign_translationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_translationsCreateManyInput = {
    id: string
    campaignId: string
    locale: string
    title: string
    description?: string | null
    imageUrl?: string | null
    languageCode?: string | null
    name?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_translationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_translationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_usage_logsCreateInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    action: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaigns: campaignsCreateNestedOneWithoutCampaign_usage_logsInput
  }

  export type campaign_usage_logsUncheckedCreateInput = {
    id: string
    campaignId: string
    userId?: string | null
    deviceId?: string | null
    action: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_usage_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: campaignsUpdateOneRequiredWithoutCampaign_usage_logsNestedInput
  }

  export type campaign_usage_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_usage_logsCreateManyInput = {
    id: string
    campaignId: string
    userId?: string | null
    deviceId?: string | null
    action: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_usage_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_usage_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaignsCreateInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsCreateNestedManyWithoutCampaignsInput
    campaign_items?: campaign_itemsCreateNestedManyWithoutCampaignsInput
    campaign_translations?: campaign_translationsCreateNestedManyWithoutCampaignsInput
    campaign_usage_logs?: campaign_usage_logsCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsUncheckedCreateInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_items?: campaign_itemsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_translations?: campaign_translationsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_usage_logs?: campaign_usage_logsUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUpdateManyWithoutCampaignsNestedInput
    campaign_items?: campaign_itemsUpdateManyWithoutCampaignsNestedInput
    campaign_translations?: campaign_translationsUpdateManyWithoutCampaignsNestedInput
    campaign_usage_logs?: campaign_usage_logsUpdateManyWithoutCampaignsNestedInput
  }

  export type campaignsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_items?: campaign_itemsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_translations?: campaign_translationsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_usage_logs?: campaign_usage_logsUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type campaignsCreateManyInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaignsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaignsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type customersCreateInput = {
    id: string
    tenant_id: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birth_date?: Date | string | null
    member_id?: string | null
    rank_id?: string | null
    total_points?: number
    total_stays?: number
    pms_updatable_fields?: customersCreatepms_updatable_fieldsInput | string[]
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
    reservations?: reservationsCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateInput = {
    id: string
    tenant_id: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birth_date?: Date | string | null
    member_id?: string | null
    rank_id?: string | null
    total_points?: number
    total_stays?: number
    pms_updatable_fields?: customersCreatepms_updatable_fieldsInput | string[]
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
    reservations?: reservationsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member_id?: NullableStringFieldUpdateOperationsInput | string | null
    rank_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    total_stays?: IntFieldUpdateOperationsInput | number
    pms_updatable_fields?: customersUpdatepms_updatable_fieldsInput | string[]
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    reservations?: reservationsUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member_id?: NullableStringFieldUpdateOperationsInput | string | null
    rank_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    total_stays?: IntFieldUpdateOperationsInput | number
    pms_updatable_fields?: customersUpdatepms_updatable_fieldsInput | string[]
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    reservations?: reservationsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type customersCreateManyInput = {
    id: string
    tenant_id: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birth_date?: Date | string | null
    member_id?: string | null
    rank_id?: string | null
    total_points?: number
    total_stays?: number
    pms_updatable_fields?: customersCreatepms_updatable_fieldsInput | string[]
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
  }

  export type customersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member_id?: NullableStringFieldUpdateOperationsInput | string | null
    rank_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    total_stays?: IntFieldUpdateOperationsInput | number
    pms_updatable_fields?: customersUpdatepms_updatable_fieldsInput | string[]
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member_id?: NullableStringFieldUpdateOperationsInput | string | null
    rank_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    total_stays?: IntFieldUpdateOperationsInput | number
    pms_updatable_fields?: customersUpdatepms_updatable_fieldsInput | string[]
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type device_roomsCreateInput = {
    roomId: string
    roomName?: string | null
    deviceId?: string | null
    deviceType?: string | null
    placeId?: string | null
    status?: string | null
    ipAddress?: string | null
    macAddress?: string | null
    lastUsedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    is_deleted?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    Tenant: TenantCreateNestedOneWithoutDevice_roomsInput
  }

  export type device_roomsUncheckedCreateInput = {
    id?: number
    tenantId: string
    roomId: string
    roomName?: string | null
    deviceId?: string | null
    deviceType?: string | null
    placeId?: string | null
    status?: string | null
    ipAddress?: string | null
    macAddress?: string | null
    lastUsedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    is_deleted?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
  }

  export type device_roomsUpdateInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    Tenant?: TenantUpdateOneRequiredWithoutDevice_roomsNestedInput
  }

  export type device_roomsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type device_roomsCreateManyInput = {
    id?: number
    tenantId: string
    roomId: string
    roomName?: string | null
    deviceId?: string | null
    deviceType?: string | null
    placeId?: string | null
    status?: string | null
    ipAddress?: string | null
    macAddress?: string | null
    lastUsedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    is_deleted?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
  }

  export type device_roomsUpdateManyMutationInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type device_roomsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type device_video_cachesCreateInput = {
    id: string
    deviceId: string
    videoIds?: device_video_cachesCreatevideoIdsInput | string[]
    lastShownAt?: Date | string
    updatedAt: Date | string
    lastViewedAt?: Date | string | null
    userId?: string | null
    viewed?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type device_video_cachesUncheckedCreateInput = {
    id: string
    deviceId: string
    videoIds?: device_video_cachesCreatevideoIdsInput | string[]
    lastShownAt?: Date | string
    updatedAt: Date | string
    lastViewedAt?: Date | string | null
    userId?: string | null
    viewed?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type device_video_cachesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    videoIds?: device_video_cachesUpdatevideoIdsInput | string[]
    lastShownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type device_video_cachesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    videoIds?: device_video_cachesUpdatevideoIdsInput | string[]
    lastShownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type device_video_cachesCreateManyInput = {
    id: string
    deviceId: string
    videoIds?: device_video_cachesCreatevideoIdsInput | string[]
    lastShownAt?: Date | string
    updatedAt: Date | string
    lastViewedAt?: Date | string | null
    userId?: string | null
    viewed?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type device_video_cachesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    videoIds?: device_video_cachesUpdatevideoIdsInput | string[]
    lastShownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type device_video_cachesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    videoIds?: device_video_cachesUpdatevideoIdsInput | string[]
    lastShownAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    viewed?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notification_templatesCreateInput = {
    id: string
    tenant_id: string
    type: string
    code: string
    subject?: string | null
    content: string
    variables?: notification_templatesCreatevariablesInput | string[]
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    body: string
    html?: boolean
    locale: string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type notification_templatesUncheckedCreateInput = {
    id: string
    tenant_id: string
    type: string
    code: string
    subject?: string | null
    content: string
    variables?: notification_templatesCreatevariablesInput | string[]
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    body: string
    html?: boolean
    locale: string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type notification_templatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: notification_templatesUpdatevariablesInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    html?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notification_templatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: notification_templatesUpdatevariablesInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    html?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notification_templatesCreateManyInput = {
    id: string
    tenant_id: string
    type: string
    code: string
    subject?: string | null
    content: string
    variables?: notification_templatesCreatevariablesInput | string[]
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    body: string
    html?: boolean
    locale: string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type notification_templatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: notification_templatesUpdatevariablesInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    html?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type notification_templatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: notification_templatesUpdatevariablesInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    body?: StringFieldUpdateOperationsInput | string
    html?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type page_historiesCreateInput = {
    Id: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    Version: number
    CreatedAt?: Date | string
    CreatedBy?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    pages: pagesCreateNestedOneWithoutPage_historiesInput
  }

  export type page_historiesUncheckedCreateInput = {
    Id: string
    PageId: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    Version: number
    CreatedAt?: Date | string
    CreatedBy?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type page_historiesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    pages?: pagesUpdateOneRequiredWithoutPage_historiesNestedInput
  }

  export type page_historiesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    PageId?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type page_historiesCreateManyInput = {
    Id: string
    PageId: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    Version: number
    CreatedAt?: Date | string
    CreatedBy?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type page_historiesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type page_historiesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    PageId?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type pagesCreateInput = {
    Id: string
    Slug: string
    Title: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    IsPublished?: boolean
    PublishedAt?: Date | string | null
    Version?: number
    CreatedAt?: Date | string
    UpdatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    page_histories?: page_historiesCreateNestedManyWithoutPagesInput
    Tenant: TenantCreateNestedOneWithoutPagesInput
  }

  export type pagesUncheckedCreateInput = {
    Id: string
    TenantId: string
    Slug: string
    Title: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    IsPublished?: boolean
    PublishedAt?: Date | string | null
    Version?: number
    CreatedAt?: Date | string
    UpdatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    page_histories?: page_historiesUncheckedCreateNestedManyWithoutPagesInput
  }

  export type pagesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    IsPublished?: BoolFieldUpdateOperationsInput | boolean
    PublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    page_histories?: page_historiesUpdateManyWithoutPagesNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutPagesNestedInput
  }

  export type pagesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    TenantId?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    IsPublished?: BoolFieldUpdateOperationsInput | boolean
    PublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    page_histories?: page_historiesUncheckedUpdateManyWithoutPagesNestedInput
  }

  export type pagesCreateManyInput = {
    Id: string
    TenantId: string
    Slug: string
    Title: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    IsPublished?: boolean
    PublishedAt?: Date | string | null
    Version?: number
    CreatedAt?: Date | string
    UpdatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type pagesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    IsPublished?: BoolFieldUpdateOperationsInput | boolean
    PublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type pagesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    TenantId?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    IsPublished?: BoolFieldUpdateOperationsInput | boolean
    PublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reservationsCreateInput = {
    id: string
    tenant_id: string
    guest_name: string
    guest_phone?: string | null
    guest_email?: string | null
    checkin_date: Date | string
    checkout_date: Date | string
    adult_count?: number
    child_count?: number
    room_type: string
    room_number?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    deposit_amount?: Decimal | DecimalJsLike | number | string
    status?: string
    origin: string
    ota_id?: string | null
    confirmation_number: string
    special_requests?: string | null
    internal_notes?: string | null
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
    customers?: customersCreateNestedOneWithoutReservationsInput
  }

  export type reservationsUncheckedCreateInput = {
    id: string
    tenant_id: string
    customer_id?: string | null
    guest_name: string
    guest_phone?: string | null
    guest_email?: string | null
    checkin_date: Date | string
    checkout_date: Date | string
    adult_count?: number
    child_count?: number
    room_type: string
    room_number?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    deposit_amount?: Decimal | DecimalJsLike | number | string
    status?: string
    origin: string
    ota_id?: string | null
    confirmation_number: string
    special_requests?: string | null
    internal_notes?: string | null
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
  }

  export type reservationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    guest_name?: StringFieldUpdateOperationsInput | string
    guest_phone?: NullableStringFieldUpdateOperationsInput | string | null
    guest_email?: NullableStringFieldUpdateOperationsInput | string | null
    checkin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adult_count?: IntFieldUpdateOperationsInput | number
    child_count?: IntFieldUpdateOperationsInput | number
    room_type?: StringFieldUpdateOperationsInput | string
    room_number?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    ota_id?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_number?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: customersUpdateOneWithoutReservationsNestedInput
  }

  export type reservationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    guest_name?: StringFieldUpdateOperationsInput | string
    guest_phone?: NullableStringFieldUpdateOperationsInput | string | null
    guest_email?: NullableStringFieldUpdateOperationsInput | string | null
    checkin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adult_count?: IntFieldUpdateOperationsInput | number
    child_count?: IntFieldUpdateOperationsInput | number
    room_type?: StringFieldUpdateOperationsInput | string
    room_number?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    ota_id?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_number?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationsCreateManyInput = {
    id: string
    tenant_id: string
    customer_id?: string | null
    guest_name: string
    guest_phone?: string | null
    guest_email?: string | null
    checkin_date: Date | string
    checkout_date: Date | string
    adult_count?: number
    child_count?: number
    room_type: string
    room_number?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    deposit_amount?: Decimal | DecimalJsLike | number | string
    status?: string
    origin: string
    ota_id?: string | null
    confirmation_number: string
    special_requests?: string | null
    internal_notes?: string | null
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
  }

  export type reservationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    guest_name?: StringFieldUpdateOperationsInput | string
    guest_phone?: NullableStringFieldUpdateOperationsInput | string | null
    guest_email?: NullableStringFieldUpdateOperationsInput | string | null
    checkin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adult_count?: IntFieldUpdateOperationsInput | number
    child_count?: IntFieldUpdateOperationsInput | number
    room_type?: StringFieldUpdateOperationsInput | string
    room_number?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    ota_id?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_number?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    guest_name?: StringFieldUpdateOperationsInput | string
    guest_phone?: NullableStringFieldUpdateOperationsInput | string | null
    guest_email?: NullableStringFieldUpdateOperationsInput | string | null
    checkin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adult_count?: IntFieldUpdateOperationsInput | number
    child_count?: IntFieldUpdateOperationsInput | number
    room_type?: StringFieldUpdateOperationsInput | string
    room_number?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    ota_id?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_number?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type response_node_translationsCreateInput = {
    id: string
    locale: string
    content?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    title?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    response_nodes: response_nodesCreateNestedOneWithoutResponse_node_translationsInput
  }

  export type response_node_translationsUncheckedCreateInput = {
    id: string
    nodeId: string
    locale: string
    content?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    title?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type response_node_translationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    response_nodes?: response_nodesUpdateOneRequiredWithoutResponse_node_translationsNestedInput
  }

  export type response_node_translationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type response_node_translationsCreateManyInput = {
    id: string
    nodeId: string
    locale: string
    content?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    title?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type response_node_translationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type response_node_translationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type response_nodesCreateInput = {
    id: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsCreateNestedManyWithoutResponse_nodesInput
    response_nodes?: response_nodesCreateNestedOneWithoutOther_response_nodesInput
    other_response_nodes?: response_nodesCreateNestedManyWithoutResponse_nodesInput
    response_trees: response_treesCreateNestedOneWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesUncheckedCreateInput = {
    id: string
    treeId: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    parentId?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsUncheckedCreateNestedManyWithoutResponse_nodesInput
    other_response_nodes?: response_nodesUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUpdateManyWithoutResponse_nodesNestedInput
    response_nodes?: response_nodesUpdateOneWithoutOther_response_nodesNestedInput
    other_response_nodes?: response_nodesUpdateManyWithoutResponse_nodesNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUncheckedUpdateManyWithoutResponse_nodesNestedInput
    other_response_nodes?: response_nodesUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUncheckedUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesCreateManyInput = {
    id: string
    treeId: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    parentId?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
  }

  export type response_nodesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type response_nodesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type response_tree_historyCreateInput = {
    id: string
    response?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    action?: string | null
    timestamp?: Date | string
    response_nodes: response_nodesCreateNestedOneWithoutResponse_tree_historyInput
    response_tree_sessions: response_tree_sessionsCreateNestedOneWithoutResponse_tree_historyInput
  }

  export type response_tree_historyUncheckedCreateInput = {
    id: string
    sessionId: string
    nodeId: string
    response?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    action?: string | null
    timestamp?: Date | string
  }

  export type response_tree_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    response_nodes?: response_nodesUpdateOneRequiredWithoutResponse_tree_historyNestedInput
    response_tree_sessions?: response_tree_sessionsUpdateOneRequiredWithoutResponse_tree_historyNestedInput
  }

  export type response_tree_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type response_tree_historyCreateManyInput = {
    id: string
    sessionId: string
    nodeId: string
    response?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    action?: string | null
    timestamp?: Date | string
  }

  export type response_tree_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type response_tree_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type response_tree_mobile_linksCreateInput = {
    id: string
    code: string
    qrCodeData?: string | null
    isActive?: boolean
    connectionId?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    connectedAt?: Date | string | null
    deviceId?: number | null
    response_tree_sessions: response_tree_sessionsCreateNestedOneWithoutResponse_tree_mobile_linksInput
  }

  export type response_tree_mobile_linksUncheckedCreateInput = {
    id: string
    sessionId: string
    code: string
    qrCodeData?: string | null
    isActive?: boolean
    connectionId?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    connectedAt?: Date | string | null
    deviceId?: number | null
  }

  export type response_tree_mobile_linksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
    response_tree_sessions?: response_tree_sessionsUpdateOneRequiredWithoutResponse_tree_mobile_linksNestedInput
  }

  export type response_tree_mobile_linksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type response_tree_mobile_linksCreateManyInput = {
    id: string
    sessionId: string
    code: string
    qrCodeData?: string | null
    isActive?: boolean
    connectionId?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    connectedAt?: Date | string | null
    deviceId?: number | null
  }

  export type response_tree_mobile_linksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type response_tree_mobile_linksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type response_tree_sessionsCreateInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_tree_sessionsInput
    response_tree_mobile_links?: response_tree_mobile_linksCreateNestedManyWithoutResponse_tree_sessionsInput
    response_nodes?: response_nodesCreateNestedOneWithoutResponse_tree_sessionsInput
    response_trees: response_treesCreateNestedOneWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsUncheckedCreateInput = {
    id: string
    treeId: string
    userId?: string | null
    deviceId?: string | null
    currentNodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput
    response_tree_mobile_links?: response_tree_mobile_linksUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_tree_mobile_links?: response_tree_mobile_linksUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_nodes?: response_nodesUpdateOneWithoutResponse_tree_sessionsNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_tree_mobile_links?: response_tree_mobile_linksUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_sessionsCreateManyInput = {
    id: string
    treeId: string
    userId?: string | null
    deviceId?: string | null
    currentNodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
  }

  export type response_tree_sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type response_tree_sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type response_tree_versionsCreateInput = {
    id: string
    version: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    response_trees: response_treesCreateNestedOneWithoutResponse_tree_versionsInput
  }

  export type response_tree_versionsUncheckedCreateInput = {
    id: string
    treeId: string
    version: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_tree_versionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_tree_versionsNestedInput
  }

  export type response_tree_versionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_tree_versionsCreateManyInput = {
    id: string
    treeId: string
    version: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_tree_versionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_tree_versionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_treesCreateInput = {
    id: string
    tenantId: string
    name: string
    description?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt: Date | string
    isActive?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    response_nodes?: response_nodesCreateNestedManyWithoutResponse_treesInput
    response_tree_sessions?: response_tree_sessionsCreateNestedManyWithoutResponse_treesInput
    response_tree_versions?: response_tree_versionsCreateNestedManyWithoutResponse_treesInput
  }

  export type response_treesUncheckedCreateInput = {
    id: string
    tenantId: string
    name: string
    description?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt: Date | string
    isActive?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    response_nodes?: response_nodesUncheckedCreateNestedManyWithoutResponse_treesInput
    response_tree_sessions?: response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_treesInput
    response_tree_versions?: response_tree_versionsUncheckedCreateNestedManyWithoutResponse_treesInput
  }

  export type response_treesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    response_nodes?: response_nodesUpdateManyWithoutResponse_treesNestedInput
    response_tree_sessions?: response_tree_sessionsUpdateManyWithoutResponse_treesNestedInput
    response_tree_versions?: response_tree_versionsUpdateManyWithoutResponse_treesNestedInput
  }

  export type response_treesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    response_nodes?: response_nodesUncheckedUpdateManyWithoutResponse_treesNestedInput
    response_tree_sessions?: response_tree_sessionsUncheckedUpdateManyWithoutResponse_treesNestedInput
    response_tree_versions?: response_tree_versionsUncheckedUpdateManyWithoutResponse_treesNestedInput
  }

  export type response_treesCreateManyInput = {
    id: string
    tenantId: string
    name: string
    description?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt: Date | string
    isActive?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type response_treesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type response_treesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type room_gradesCreateInput = {
    id: string
    tenant_id: string
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type room_gradesUncheckedCreateInput = {
    id: string
    tenant_id: string
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type room_gradesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_gradesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_gradesCreateManyInput = {
    id: string
    tenant_id: string
    code: string
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type room_gradesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type room_gradesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schema_versionCreateInput = {
    version: string
    description: string
    rollback_sql?: string | null
    applied_at?: Date | string
    applied_by?: string | null
  }

  export type schema_versionUncheckedCreateInput = {
    version: string
    description: string
    rollback_sql?: string | null
    applied_at?: Date | string
    applied_by?: string | null
  }

  export type schema_versionUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rollback_sql?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applied_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type schema_versionUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rollback_sql?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applied_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type schema_versionCreateManyInput = {
    version: string
    description: string
    rollback_sql?: string | null
    applied_at?: Date | string
    applied_by?: string | null
  }

  export type schema_versionUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rollback_sql?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applied_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type schema_versionUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rollback_sql?: NullableStringFieldUpdateOperationsInput | string | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applied_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type service_plan_restrictionsCreateInput = {
    id: string
    service_type: string
    plan_type: string
    plan_category: string
    max_users?: number
    max_devices?: number
    max_monthly_orders?: number | null
    enable_ai_concierge?: boolean | null
    enable_multilingual?: boolean | null
    max_rooms?: number | null
    enable_revenue_management?: boolean | null
    max_monthly_ai_requests?: number | null
    enable_ai_crm?: boolean | null
    monthly_price?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_plan_restrictionsUncheckedCreateInput = {
    id: string
    service_type: string
    plan_type: string
    plan_category: string
    max_users?: number
    max_devices?: number
    max_monthly_orders?: number | null
    enable_ai_concierge?: boolean | null
    enable_multilingual?: boolean | null
    max_rooms?: number | null
    enable_revenue_management?: boolean | null
    max_monthly_ai_requests?: number | null
    enable_ai_crm?: boolean | null
    monthly_price?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_plan_restrictionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    plan_category?: StringFieldUpdateOperationsInput | string
    max_users?: IntFieldUpdateOperationsInput | number
    max_devices?: IntFieldUpdateOperationsInput | number
    max_monthly_orders?: NullableIntFieldUpdateOperationsInput | number | null
    enable_ai_concierge?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable_multilingual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    max_rooms?: NullableIntFieldUpdateOperationsInput | number | null
    enable_revenue_management?: NullableBoolFieldUpdateOperationsInput | boolean | null
    max_monthly_ai_requests?: NullableIntFieldUpdateOperationsInput | number | null
    enable_ai_crm?: NullableBoolFieldUpdateOperationsInput | boolean | null
    monthly_price?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_plan_restrictionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    plan_category?: StringFieldUpdateOperationsInput | string
    max_users?: IntFieldUpdateOperationsInput | number
    max_devices?: IntFieldUpdateOperationsInput | number
    max_monthly_orders?: NullableIntFieldUpdateOperationsInput | number | null
    enable_ai_concierge?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable_multilingual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    max_rooms?: NullableIntFieldUpdateOperationsInput | number | null
    enable_revenue_management?: NullableBoolFieldUpdateOperationsInput | boolean | null
    max_monthly_ai_requests?: NullableIntFieldUpdateOperationsInput | number | null
    enable_ai_crm?: NullableBoolFieldUpdateOperationsInput | boolean | null
    monthly_price?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_plan_restrictionsCreateManyInput = {
    id: string
    service_type: string
    plan_type: string
    plan_category: string
    max_users?: number
    max_devices?: number
    max_monthly_orders?: number | null
    enable_ai_concierge?: boolean | null
    enable_multilingual?: boolean | null
    max_rooms?: number | null
    enable_revenue_management?: boolean | null
    max_monthly_ai_requests?: number | null
    enable_ai_crm?: boolean | null
    monthly_price?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_plan_restrictionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    plan_category?: StringFieldUpdateOperationsInput | string
    max_users?: IntFieldUpdateOperationsInput | number
    max_devices?: IntFieldUpdateOperationsInput | number
    max_monthly_orders?: NullableIntFieldUpdateOperationsInput | number | null
    enable_ai_concierge?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable_multilingual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    max_rooms?: NullableIntFieldUpdateOperationsInput | number | null
    enable_revenue_management?: NullableBoolFieldUpdateOperationsInput | boolean | null
    max_monthly_ai_requests?: NullableIntFieldUpdateOperationsInput | number | null
    enable_ai_crm?: NullableBoolFieldUpdateOperationsInput | boolean | null
    monthly_price?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_plan_restrictionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    plan_category?: StringFieldUpdateOperationsInput | string
    max_users?: IntFieldUpdateOperationsInput | number
    max_devices?: IntFieldUpdateOperationsInput | number
    max_monthly_orders?: NullableIntFieldUpdateOperationsInput | number | null
    enable_ai_concierge?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enable_multilingual?: NullableBoolFieldUpdateOperationsInput | boolean | null
    max_rooms?: NullableIntFieldUpdateOperationsInput | number | null
    enable_revenue_management?: NullableBoolFieldUpdateOperationsInput | boolean | null
    max_monthly_ai_requests?: NullableIntFieldUpdateOperationsInput | number | null
    enable_ai_crm?: NullableBoolFieldUpdateOperationsInput | boolean | null
    monthly_price?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_usage_statisticsCreateInput = {
    id: string
    service_type: string
    month: string
    active_users_count?: number
    active_devices_count?: number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    Tenant: TenantCreateNestedOneWithoutService_usage_statisticsInput
  }

  export type service_usage_statisticsUncheckedCreateInput = {
    id: string
    tenant_id: string
    service_type: string
    month: string
    active_users_count?: number
    active_devices_count?: number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_usage_statisticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    active_users_count?: IntFieldUpdateOperationsInput | number
    active_devices_count?: IntFieldUpdateOperationsInput | number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Tenant?: TenantUpdateOneRequiredWithoutService_usage_statisticsNestedInput
  }

  export type service_usage_statisticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    active_users_count?: IntFieldUpdateOperationsInput | number
    active_devices_count?: IntFieldUpdateOperationsInput | number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_usage_statisticsCreateManyInput = {
    id: string
    tenant_id: string
    service_type: string
    month: string
    active_users_count?: number
    active_devices_count?: number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_usage_statisticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    active_users_count?: IntFieldUpdateOperationsInput | number
    active_devices_count?: IntFieldUpdateOperationsInput | number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_usage_statisticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    active_users_count?: IntFieldUpdateOperationsInput | number
    active_devices_count?: IntFieldUpdateOperationsInput | number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type staffCreateInput = {
    id: string
    tenant_id: string
    email: string
    name: string
    role: string
    department?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    failed_login_count?: number
    last_login_at?: Date | string | null
    locked_until?: Date | string | null
    password_hash?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type staffUncheckedCreateInput = {
    id: string
    tenant_id: string
    email: string
    name: string
    role: string
    department?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    failed_login_count?: number
    last_login_at?: Date | string | null
    locked_until?: Date | string | null
    password_hash?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type staffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    failed_login_count?: IntFieldUpdateOperationsInput | number
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type staffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    failed_login_count?: IntFieldUpdateOperationsInput | number
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type staffCreateManyInput = {
    id: string
    tenant_id: string
    email: string
    name: string
    role: string
    department?: string | null
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    failed_login_count?: number
    last_login_at?: Date | string | null
    locked_until?: Date | string | null
    password_hash?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type staffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    failed_login_count?: IntFieldUpdateOperationsInput | number
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type staffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    failed_login_count?: IntFieldUpdateOperationsInput | number
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type system_eventCreateInput = {
    id: string
    tenant_id: string
    user_id?: string | null
    event_type: string
    source_system: string
    target_system: string
    entity_type: string
    entity_id: string
    action: string
    event_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    processed_at?: Date | string | null
    status?: string
  }

  export type system_eventUncheckedCreateInput = {
    id: string
    tenant_id: string
    user_id?: string | null
    event_type: string
    source_system: string
    target_system: string
    entity_type: string
    entity_id: string
    action: string
    event_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    processed_at?: Date | string | null
    status?: string
  }

  export type system_eventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: StringFieldUpdateOperationsInput | string
    source_system?: StringFieldUpdateOperationsInput | string
    target_system?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    event_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type system_eventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: StringFieldUpdateOperationsInput | string
    source_system?: StringFieldUpdateOperationsInput | string
    target_system?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    event_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type system_eventCreateManyInput = {
    id: string
    tenant_id: string
    user_id?: string | null
    event_type: string
    source_system: string
    target_system: string
    entity_type: string
    entity_id: string
    action: string
    event_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    processed_at?: Date | string | null
    status?: string
  }

  export type system_eventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: StringFieldUpdateOperationsInput | string
    source_system?: StringFieldUpdateOperationsInput | string
    target_system?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    event_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type system_eventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_type?: StringFieldUpdateOperationsInput | string
    source_system?: StringFieldUpdateOperationsInput | string
    target_system?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    event_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type tenant_access_logsCreateInput = {
    id: string
    tenant_id: string
    user_id?: string | null
    action: string
    resource?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    source_system?: string | null
  }

  export type tenant_access_logsUncheckedCreateInput = {
    id: string
    tenant_id: string
    user_id?: string | null
    action: string
    resource?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    source_system?: string | null
  }

  export type tenant_access_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source_system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tenant_access_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source_system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tenant_access_logsCreateManyInput = {
    id: string
    tenant_id: string
    user_id?: string | null
    action: string
    resource?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    source_system?: string | null
  }

  export type tenant_access_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source_system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tenant_access_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source_system?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tenant_servicesCreateInput = {
    id: string
    service_type: string
    plan_type: string
    is_active?: boolean
    activated_at?: Date | string
    expires_at?: Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    Tenant: TenantCreateNestedOneWithoutTenant_servicesInput
  }

  export type tenant_servicesUncheckedCreateInput = {
    id: string
    tenant_id: string
    service_type: string
    plan_type: string
    is_active?: boolean
    activated_at?: Date | string
    expires_at?: Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenant_servicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    activated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Tenant?: TenantUpdateOneRequiredWithoutTenant_servicesNestedInput
  }

  export type tenant_servicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    activated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenant_servicesCreateManyInput = {
    id: string
    tenant_id: string
    service_type: string
    plan_type: string
    is_active?: boolean
    activated_at?: Date | string
    expires_at?: Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenant_servicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    activated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenant_servicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    activated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checkin_sessionsCreateInput = {
    id?: string
    tenant_id: string
    session_number: string
    reservation_id?: string | null
    room_id: string
    guest_info: JsonNullValueInput | InputJsonValue
    adults?: number
    children?: number
    check_in_at: Date | string
    check_out_at?: Date | string | null
    planned_check_out: Date | string
    status?: string
    special_requests?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type checkin_sessionsUncheckedCreateInput = {
    id?: string
    tenant_id: string
    session_number: string
    reservation_id?: string | null
    room_id: string
    guest_info: JsonNullValueInput | InputJsonValue
    adults?: number
    children?: number
    check_in_at: Date | string
    check_out_at?: Date | string | null
    planned_check_out: Date | string
    status?: string
    special_requests?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type checkin_sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    session_number?: StringFieldUpdateOperationsInput | string
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: StringFieldUpdateOperationsInput | string
    guest_info?: JsonNullValueInput | InputJsonValue
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    check_in_at?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planned_check_out?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checkin_sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    session_number?: StringFieldUpdateOperationsInput | string
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: StringFieldUpdateOperationsInput | string
    guest_info?: JsonNullValueInput | InputJsonValue
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    check_in_at?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planned_check_out?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checkin_sessionsCreateManyInput = {
    id?: string
    tenant_id: string
    session_number: string
    reservation_id?: string | null
    room_id: string
    guest_info: JsonNullValueInput | InputJsonValue
    adults?: number
    children?: number
    check_in_at: Date | string
    check_out_at?: Date | string | null
    planned_check_out: Date | string
    status?: string
    special_requests?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type checkin_sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    session_number?: StringFieldUpdateOperationsInput | string
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: StringFieldUpdateOperationsInput | string
    guest_info?: JsonNullValueInput | InputJsonValue
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    check_in_at?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planned_check_out?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checkin_sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    session_number?: StringFieldUpdateOperationsInput | string
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    room_id?: StringFieldUpdateOperationsInput | string
    guest_info?: JsonNullValueInput | InputJsonValue
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    check_in_at?: DateTimeFieldUpdateOperationsInput | Date | string
    check_out_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    planned_check_out?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type session_billingsCreateInput = {
    id?: string
    tenant_id: string
    session_id: string
    billing_number: string
    room_charges: JsonNullValueInput | InputJsonValue
    service_charges: JsonNullValueInput | InputJsonValue
    taxes: JsonNullValueInput | InputJsonValue
    discounts: JsonNullValueInput | InputJsonValue
    subtotal_amount: number
    tax_amount: number
    total_amount: number
    paid_amount?: number
    status?: string
    payment_method?: string | null
    payment_date?: Date | string | null
    due_date: Date | string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type session_billingsUncheckedCreateInput = {
    id?: string
    tenant_id: string
    session_id: string
    billing_number: string
    room_charges: JsonNullValueInput | InputJsonValue
    service_charges: JsonNullValueInput | InputJsonValue
    taxes: JsonNullValueInput | InputJsonValue
    discounts: JsonNullValueInput | InputJsonValue
    subtotal_amount: number
    tax_amount: number
    total_amount: number
    paid_amount?: number
    status?: string
    payment_method?: string | null
    payment_date?: Date | string | null
    due_date: Date | string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type session_billingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    session_id?: StringFieldUpdateOperationsInput | string
    billing_number?: StringFieldUpdateOperationsInput | string
    room_charges?: JsonNullValueInput | InputJsonValue
    service_charges?: JsonNullValueInput | InputJsonValue
    taxes?: JsonNullValueInput | InputJsonValue
    discounts?: JsonNullValueInput | InputJsonValue
    subtotal_amount?: IntFieldUpdateOperationsInput | number
    tax_amount?: IntFieldUpdateOperationsInput | number
    total_amount?: IntFieldUpdateOperationsInput | number
    paid_amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type session_billingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    session_id?: StringFieldUpdateOperationsInput | string
    billing_number?: StringFieldUpdateOperationsInput | string
    room_charges?: JsonNullValueInput | InputJsonValue
    service_charges?: JsonNullValueInput | InputJsonValue
    taxes?: JsonNullValueInput | InputJsonValue
    discounts?: JsonNullValueInput | InputJsonValue
    subtotal_amount?: IntFieldUpdateOperationsInput | number
    tax_amount?: IntFieldUpdateOperationsInput | number
    total_amount?: IntFieldUpdateOperationsInput | number
    paid_amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type session_billingsCreateManyInput = {
    id?: string
    tenant_id: string
    session_id: string
    billing_number: string
    room_charges: JsonNullValueInput | InputJsonValue
    service_charges: JsonNullValueInput | InputJsonValue
    taxes: JsonNullValueInput | InputJsonValue
    discounts: JsonNullValueInput | InputJsonValue
    subtotal_amount: number
    tax_amount: number
    total_amount: number
    paid_amount?: number
    status?: string
    payment_method?: string | null
    payment_date?: Date | string | null
    due_date: Date | string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type session_billingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    session_id?: StringFieldUpdateOperationsInput | string
    billing_number?: StringFieldUpdateOperationsInput | string
    room_charges?: JsonNullValueInput | InputJsonValue
    service_charges?: JsonNullValueInput | InputJsonValue
    taxes?: JsonNullValueInput | InputJsonValue
    discounts?: JsonNullValueInput | InputJsonValue
    subtotal_amount?: IntFieldUpdateOperationsInput | number
    tax_amount?: IntFieldUpdateOperationsInput | number
    total_amount?: IntFieldUpdateOperationsInput | number
    paid_amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type session_billingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    session_id?: StringFieldUpdateOperationsInput | string
    billing_number?: StringFieldUpdateOperationsInput | string
    room_charges?: JsonNullValueInput | InputJsonValue
    service_charges?: JsonNullValueInput | InputJsonValue
    taxes?: JsonNullValueInput | InputJsonValue
    discounts?: JsonNullValueInput | InputJsonValue
    subtotal_amount?: IntFieldUpdateOperationsInput | number
    tax_amount?: IntFieldUpdateOperationsInput | number
    total_amount?: IntFieldUpdateOperationsInput | number
    paid_amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    tenantId: string
    roomNumber: string
    roomType: string
    floor?: number | null
    status?: string
    capacity?: number
    amenities?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    lastCleaned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    tenantId: string
    roomNumber: string
    roomType: string
    floor?: number | null
    status?: string
    capacity?: number
    amenities?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    lastCleaned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomCreateManyInput = {
    id?: string
    tenantId: string
    roomNumber: string
    roomType: string
    floor?: number | null
    status?: string
    capacity?: number
    amenities?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    lastCleaned?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    roomType?: StringFieldUpdateOperationsInput | string
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    amenities?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateInput = {
    id?: string
    tenantId: string
    paymentId?: string | null
    type: string
    amount: number
    taxAmount?: number
    totalAmount: number
    status?: string
    description?: string | null
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    payment?: PaymentCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    paymentId?: string | null
    type: string
    amount: number
    taxAmount?: number
    totalAmount: number
    status?: string
    description?: string | null
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    paymentId?: string | null
    type: string
    amount: number
    taxAmount?: number
    totalAmount: number
    status?: string
    description?: string | null
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    taxAmount: number
    totalAmount: number
    status?: string
    dueDate?: Date | string | null
    issuedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    taxAmount: number
    totalAmount: number
    status?: string
    dueDate?: Date | string | null
    issuedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    taxAmount: number
    totalAmount: number
    status?: string
    dueDate?: Date | string | null
    issuedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    tenantId: string
    paymentMethod: string
    amount: number
    status?: string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
    transaction?: TransactionCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    tenantId: string
    transactionId?: string | null
    invoiceId?: string | null
    paymentMethod: string
    amount: number
    status?: string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
    transaction?: TransactionUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    tenantId: string
    transactionId?: string | null
    invoiceId?: string | null
    paymentMethod: string
    amount: number
    status?: string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DatabaseChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    changeType?: SortOrder
    description?: SortOrder
    details?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DatabaseChangeLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DatabaseChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    changeType?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DatabaseChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    changeType?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type DatabaseChangeLogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    placeId?: SortOrder
    status?: SortOrder
    items?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    uuid?: SortOrder
    sessionId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    total?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    placeId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    uuid?: SortOrder
    sessionId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    placeId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    uuid?: SortOrder
    sessionId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    placeId?: SortOrder
    total?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    deliveredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TenantSystemPlanListRelationFilter = {
    every?: TenantSystemPlanWhereInput
    some?: TenantSystemPlanWhereInput
    none?: TenantSystemPlanWhereInput
  }

  export type TenantSystemPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemPlanRestrictionsSystemTypeBusinessTypePlanTypePlanCategoryCompoundUniqueInput = {
    systemType: string
    businessType: string
    planType: string
    planCategory: string
  }

  export type SystemPlanRestrictionsCountOrderByAggregateInput = {
    id?: SortOrder
    systemType?: SortOrder
    businessType?: SortOrder
    planType?: SortOrder
    planCategory?: SortOrder
    monthlyPrice?: SortOrder
    maxDevices?: SortOrder
    additionalDeviceCost?: SortOrder
    roomTerminalCost?: SortOrder
    frontDeskCost?: SortOrder
    kitchenCost?: SortOrder
    barCost?: SortOrder
    housekeepingCost?: SortOrder
    managerCost?: SortOrder
    commonAreaCost?: SortOrder
    enableAiConcierge?: SortOrder
    enableMultilingual?: SortOrder
    enableLayoutEditor?: SortOrder
    enableFacilityGuide?: SortOrder
    enableAiBusinessSupport?: SortOrder
    maxMonthlyOrders?: SortOrder
    maxMonthlyAiRequests?: SortOrder
    maxStorageGB?: SortOrder
    multilingualUpgradePrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type SystemPlanRestrictionsAvgOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    maxDevices?: SortOrder
    additionalDeviceCost?: SortOrder
    roomTerminalCost?: SortOrder
    frontDeskCost?: SortOrder
    kitchenCost?: SortOrder
    barCost?: SortOrder
    housekeepingCost?: SortOrder
    managerCost?: SortOrder
    commonAreaCost?: SortOrder
    maxMonthlyOrders?: SortOrder
    maxMonthlyAiRequests?: SortOrder
    maxStorageGB?: SortOrder
    multilingualUpgradePrice?: SortOrder
  }

  export type SystemPlanRestrictionsMaxOrderByAggregateInput = {
    id?: SortOrder
    systemType?: SortOrder
    businessType?: SortOrder
    planType?: SortOrder
    planCategory?: SortOrder
    monthlyPrice?: SortOrder
    maxDevices?: SortOrder
    additionalDeviceCost?: SortOrder
    roomTerminalCost?: SortOrder
    frontDeskCost?: SortOrder
    kitchenCost?: SortOrder
    barCost?: SortOrder
    housekeepingCost?: SortOrder
    managerCost?: SortOrder
    commonAreaCost?: SortOrder
    enableAiConcierge?: SortOrder
    enableMultilingual?: SortOrder
    enableLayoutEditor?: SortOrder
    enableFacilityGuide?: SortOrder
    enableAiBusinessSupport?: SortOrder
    maxMonthlyOrders?: SortOrder
    maxMonthlyAiRequests?: SortOrder
    maxStorageGB?: SortOrder
    multilingualUpgradePrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type SystemPlanRestrictionsMinOrderByAggregateInput = {
    id?: SortOrder
    systemType?: SortOrder
    businessType?: SortOrder
    planType?: SortOrder
    planCategory?: SortOrder
    monthlyPrice?: SortOrder
    maxDevices?: SortOrder
    additionalDeviceCost?: SortOrder
    roomTerminalCost?: SortOrder
    frontDeskCost?: SortOrder
    kitchenCost?: SortOrder
    barCost?: SortOrder
    housekeepingCost?: SortOrder
    managerCost?: SortOrder
    commonAreaCost?: SortOrder
    enableAiConcierge?: SortOrder
    enableMultilingual?: SortOrder
    enableLayoutEditor?: SortOrder
    enableFacilityGuide?: SortOrder
    enableAiBusinessSupport?: SortOrder
    maxMonthlyOrders?: SortOrder
    maxMonthlyAiRequests?: SortOrder
    maxStorageGB?: SortOrder
    multilingualUpgradePrice?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type SystemPlanRestrictionsSumOrderByAggregateInput = {
    monthlyPrice?: SortOrder
    maxDevices?: SortOrder
    additionalDeviceCost?: SortOrder
    roomTerminalCost?: SortOrder
    frontDeskCost?: SortOrder
    kitchenCost?: SortOrder
    barCost?: SortOrder
    housekeepingCost?: SortOrder
    managerCost?: SortOrder
    commonAreaCost?: SortOrder
    maxMonthlyOrders?: SortOrder
    maxMonthlyAiRequests?: SortOrder
    maxStorageGB?: SortOrder
    multilingualUpgradePrice?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Device_roomsListRelationFilter = {
    every?: device_roomsWhereInput
    some?: device_roomsWhereInput
    none?: device_roomsWhereInput
  }

  export type PagesListRelationFilter = {
    every?: pagesWhereInput
    some?: pagesWhereInput
    none?: pagesWhereInput
  }

  export type Service_usage_statisticsListRelationFilter = {
    every?: service_usage_statisticsWhereInput
    some?: service_usage_statisticsWhereInput
    none?: service_usage_statisticsWhereInput
  }

  export type Tenant_servicesListRelationFilter = {
    every?: tenant_servicesWhereInput
    some?: tenant_servicesWhereInput
    none?: tenant_servicesWhereInput
  }

  export type device_roomsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type service_usage_statisticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tenant_servicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    contactEmail?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    features?: SortOrder
    is_deleted?: SortOrder
    planType?: SortOrder
    settings?: SortOrder
    status?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    contactEmail?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
    planType?: SortOrder
    status?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    contactEmail?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
    planType?: SortOrder
    status?: SortOrder
  }

  export type SystemPlanRestrictionsRelationFilter = {
    is?: SystemPlanRestrictionsWhereInput
    isNot?: SystemPlanRestrictionsWhereInput
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type TenantSystemPlanTenantIdSystemTypeCompoundUniqueInput = {
    tenantId: string
    systemType: string
  }

  export type TenantSystemPlanCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    systemType?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    monthlyPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type TenantSystemPlanAvgOrderByAggregateInput = {
    monthlyPrice?: SortOrder
  }

  export type TenantSystemPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    systemType?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    monthlyPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type TenantSystemPlanMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    systemType?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    monthlyPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type TenantSystemPlanSumOrderByAggregateInput = {
    monthlyPrice?: SortOrder
  }

  export type EnumAdminLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminLevel | EnumAdminLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AdminLevel[] | ListEnumAdminLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminLevel[] | ListEnumAdminLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminLevelFilter<$PrismaModel> | $Enums.AdminLevel
  }

  export type Admin_logListRelationFilter = {
    every?: admin_logWhereInput
    some?: admin_logWhereInput
    none?: admin_logWhereInput
  }

  export type admin_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type adminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    password_hash?: SortOrder
    admin_level?: SortOrder
    accessible_group_ids?: SortOrder
    accessible_chain_ids?: SortOrder
    accessible_tenant_ids?: SortOrder
    last_login_at?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    totp_secret?: SortOrder
    totp_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    login_attempts?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    password_hash?: SortOrder
    admin_level?: SortOrder
    last_login_at?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    totp_secret?: SortOrder
    totp_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    display_name?: SortOrder
    password_hash?: SortOrder
    admin_level?: SortOrder
    last_login_at?: SortOrder
    login_attempts?: SortOrder
    locked_until?: SortOrder
    totp_secret?: SortOrder
    totp_enabled?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    login_attempts?: SortOrder
  }

  export type EnumAdminLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminLevel | EnumAdminLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AdminLevel[] | ListEnumAdminLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminLevel[] | ListEnumAdminLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminLevelWithAggregatesFilter<$PrismaModel> | $Enums.AdminLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminLevelFilter<$PrismaModel>
    _max?: NestedEnumAdminLevelFilter<$PrismaModel>
  }

  export type AdminRelationFilter = {
    is?: adminWhereInput
    isNot?: adminWhereInput
  }

  export type admin_logCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    action?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    success?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type admin_logMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    action?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    success?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type admin_logMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    action?: SortOrder
    target_type?: SortOrder
    target_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    success?: SortOrder
    error_message?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type Campaign_category_relationsListRelationFilter = {
    every?: campaign_category_relationsWhereInput
    some?: campaign_category_relationsWhereInput
    none?: campaign_category_relationsWhereInput
  }

  export type campaign_category_relationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type campaign_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type CampaignsRelationFilter = {
    is?: campaignsWhereInput
    isNot?: campaignsWhereInput
  }

  export type Campaign_categoriesRelationFilter = {
    is?: campaign_categoriesWhereInput
    isNot?: campaign_categoriesWhereInput
  }

  export type campaign_category_relationsCampaignIdCategoryIdCompoundUniqueInput = {
    campaignId: string
    categoryId: string
  }

  export type campaign_category_relationsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_category_relationsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_category_relationsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_itemsCampaignIdItemIdItemTypeCompoundUniqueInput = {
    campaignId: string
    itemId: string
    itemType: string
  }

  export type campaign_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_itemsAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type campaign_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_itemsSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type campaign_translationsCampaignIdLocaleCompoundUniqueInput = {
    campaignId: string
    locale: string
  }

  export type campaign_translationsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    languageCode?: SortOrder
    name?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_translationsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    languageCode?: SortOrder
    name?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_translationsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    locale?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    languageCode?: SortOrder
    name?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_usage_logsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_usage_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaign_usage_logsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type EnumCampaignDisplayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignDisplayType | EnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignDisplayType[] | ListEnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignDisplayType[] | ListEnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignDisplayTypeFilter<$PrismaModel> | $Enums.CampaignDisplayType
  }

  export type EnumCampaignCtaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignCtaType | EnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignCtaType[] | ListEnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignCtaType[] | ListEnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignCtaTypeFilter<$PrismaModel> | $Enums.CampaignCtaType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type Campaign_itemsListRelationFilter = {
    every?: campaign_itemsWhereInput
    some?: campaign_itemsWhereInput
    none?: campaign_itemsWhereInput
  }

  export type Campaign_translationsListRelationFilter = {
    every?: campaign_translationsWhereInput
    some?: campaign_translationsWhereInput
    none?: campaign_translationsWhereInput
  }

  export type Campaign_usage_logsListRelationFilter = {
    every?: campaign_usage_logsWhereInput
    some?: campaign_usage_logsWhereInput
    none?: campaign_usage_logsWhereInput
  }

  export type campaign_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type campaign_translationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type campaign_usage_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type campaignsCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    displayType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    priority?: SortOrder
    ctaType?: SortOrder
    ctaAction?: SortOrder
    ctaLabel?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dayRestrictions?: SortOrder
    description?: SortOrder
    displayPriority?: SortOrder
    maxUsageCount?: SortOrder
    name?: SortOrder
    timeRestrictions?: SortOrder
    welcomeSettings?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaignsAvgOrderByAggregateInput = {
    priority?: SortOrder
    discountValue?: SortOrder
    displayPriority?: SortOrder
    maxUsageCount?: SortOrder
  }

  export type campaignsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    displayType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    priority?: SortOrder
    ctaType?: SortOrder
    ctaAction?: SortOrder
    ctaLabel?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    displayPriority?: SortOrder
    maxUsageCount?: SortOrder
    name?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaignsMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    displayType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    priority?: SortOrder
    ctaType?: SortOrder
    ctaAction?: SortOrder
    ctaLabel?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    displayPriority?: SortOrder
    maxUsageCount?: SortOrder
    name?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type campaignsSumOrderByAggregateInput = {
    priority?: SortOrder
    discountValue?: SortOrder
    displayPriority?: SortOrder
    maxUsageCount?: SortOrder
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type EnumCampaignDisplayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignDisplayType | EnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignDisplayType[] | ListEnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignDisplayType[] | ListEnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignDisplayTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignDisplayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignDisplayTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignDisplayTypeFilter<$PrismaModel>
  }

  export type EnumCampaignCtaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignCtaType | EnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignCtaType[] | ListEnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignCtaType[] | ListEnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignCtaTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignCtaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignCtaTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignCtaTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ReservationsListRelationFilter = {
    every?: reservationsWhereInput
    some?: reservationsWhereInput
    none?: reservationsWhereInput
  }

  export type reservationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customersCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    birth_date?: SortOrder
    member_id?: SortOrder
    rank_id?: SortOrder
    total_points?: SortOrder
    total_stays?: SortOrder
    pms_updatable_fields?: SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    preferences?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrder
  }

  export type customersAvgOrderByAggregateInput = {
    total_points?: SortOrder
    total_stays?: SortOrder
  }

  export type customersMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    birth_date?: SortOrder
    member_id?: SortOrder
    rank_id?: SortOrder
    total_points?: SortOrder
    total_stays?: SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrder
  }

  export type customersMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    birth_date?: SortOrder
    member_id?: SortOrder
    rank_id?: SortOrder
    total_points?: SortOrder
    total_stays?: SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrder
  }

  export type customersSumOrderByAggregateInput = {
    total_points?: SortOrder
    total_stays?: SortOrder
  }

  export type device_roomsCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    deviceId?: SortOrder
    deviceType?: SortOrder
    placeId?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    macAddress?: SortOrder
    lastUsedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
  }

  export type device_roomsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type device_roomsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    deviceId?: SortOrder
    deviceType?: SortOrder
    placeId?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    macAddress?: SortOrder
    lastUsedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
  }

  export type device_roomsMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    deviceId?: SortOrder
    deviceType?: SortOrder
    placeId?: SortOrder
    status?: SortOrder
    ipAddress?: SortOrder
    macAddress?: SortOrder
    lastUsedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
  }

  export type device_roomsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type device_video_cachesDeviceIdUserIdCompoundUniqueInput = {
    deviceId: string
    userId: string
  }

  export type device_video_cachesCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    videoIds?: SortOrder
    lastShownAt?: SortOrder
    updatedAt?: SortOrder
    lastViewedAt?: SortOrder
    userId?: SortOrder
    viewed?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type device_video_cachesMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    lastShownAt?: SortOrder
    updatedAt?: SortOrder
    lastViewedAt?: SortOrder
    userId?: SortOrder
    viewed?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type device_video_cachesMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    lastShownAt?: SortOrder
    updatedAt?: SortOrder
    lastViewedAt?: SortOrder
    userId?: SortOrder
    viewed?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type notification_templatesTenant_idTypeCodeLocaleCompoundUniqueInput = {
    tenant_id: string
    type: string
    code: string
    locale: string
  }

  export type notification_templatesCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    body?: SortOrder
    html?: SortOrder
    locale?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type notification_templatesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    body?: SortOrder
    html?: SortOrder
    locale?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type notification_templatesMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    body?: SortOrder
    html?: SortOrder
    locale?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type PagesRelationFilter = {
    is?: pagesWhereInput
    isNot?: pagesWhereInput
  }

  export type page_historiesCountOrderByAggregateInput = {
    Id?: SortOrder
    PageId?: SortOrder
    Html?: SortOrder
    Css?: SortOrder
    Content?: SortOrder
    Template?: SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    CreatedBy?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type page_historiesAvgOrderByAggregateInput = {
    Version?: SortOrder
  }

  export type page_historiesMaxOrderByAggregateInput = {
    Id?: SortOrder
    PageId?: SortOrder
    Html?: SortOrder
    Css?: SortOrder
    Content?: SortOrder
    Template?: SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    CreatedBy?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type page_historiesMinOrderByAggregateInput = {
    Id?: SortOrder
    PageId?: SortOrder
    Html?: SortOrder
    Css?: SortOrder
    Content?: SortOrder
    Template?: SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    CreatedBy?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type page_historiesSumOrderByAggregateInput = {
    Version?: SortOrder
  }

  export type Page_historiesListRelationFilter = {
    every?: page_historiesWhereInput
    some?: page_historiesWhereInput
    none?: page_historiesWhereInput
  }

  export type page_historiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pagesTenantIdSlugCompoundUniqueInput = {
    TenantId: string
    Slug: string
  }

  export type pagesCountOrderByAggregateInput = {
    Id?: SortOrder
    TenantId?: SortOrder
    Slug?: SortOrder
    Title?: SortOrder
    Html?: SortOrder
    Css?: SortOrder
    Content?: SortOrder
    Template?: SortOrder
    IsPublished?: SortOrder
    PublishedAt?: SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type pagesAvgOrderByAggregateInput = {
    Version?: SortOrder
  }

  export type pagesMaxOrderByAggregateInput = {
    Id?: SortOrder
    TenantId?: SortOrder
    Slug?: SortOrder
    Title?: SortOrder
    Html?: SortOrder
    Css?: SortOrder
    Content?: SortOrder
    Template?: SortOrder
    IsPublished?: SortOrder
    PublishedAt?: SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type pagesMinOrderByAggregateInput = {
    Id?: SortOrder
    TenantId?: SortOrder
    Slug?: SortOrder
    Title?: SortOrder
    Html?: SortOrder
    Css?: SortOrder
    Content?: SortOrder
    Template?: SortOrder
    IsPublished?: SortOrder
    PublishedAt?: SortOrder
    Version?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type pagesSumOrderByAggregateInput = {
    Version?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CustomersNullableRelationFilter = {
    is?: customersWhereInput | null
    isNot?: customersWhereInput | null
  }

  export type reservationsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    customer_id?: SortOrder
    guest_name?: SortOrder
    guest_phone?: SortOrder
    guest_email?: SortOrder
    checkin_date?: SortOrder
    checkout_date?: SortOrder
    adult_count?: SortOrder
    child_count?: SortOrder
    room_type?: SortOrder
    room_number?: SortOrder
    total_amount?: SortOrder
    deposit_amount?: SortOrder
    status?: SortOrder
    origin?: SortOrder
    ota_id?: SortOrder
    confirmation_number?: SortOrder
    special_requests?: SortOrder
    internal_notes?: SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrder
  }

  export type reservationsAvgOrderByAggregateInput = {
    adult_count?: SortOrder
    child_count?: SortOrder
    total_amount?: SortOrder
    deposit_amount?: SortOrder
  }

  export type reservationsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    customer_id?: SortOrder
    guest_name?: SortOrder
    guest_phone?: SortOrder
    guest_email?: SortOrder
    checkin_date?: SortOrder
    checkout_date?: SortOrder
    adult_count?: SortOrder
    child_count?: SortOrder
    room_type?: SortOrder
    room_number?: SortOrder
    total_amount?: SortOrder
    deposit_amount?: SortOrder
    status?: SortOrder
    origin?: SortOrder
    ota_id?: SortOrder
    confirmation_number?: SortOrder
    special_requests?: SortOrder
    internal_notes?: SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrder
  }

  export type reservationsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    customer_id?: SortOrder
    guest_name?: SortOrder
    guest_phone?: SortOrder
    guest_email?: SortOrder
    checkin_date?: SortOrder
    checkout_date?: SortOrder
    adult_count?: SortOrder
    child_count?: SortOrder
    room_type?: SortOrder
    room_number?: SortOrder
    total_amount?: SortOrder
    deposit_amount?: SortOrder
    status?: SortOrder
    origin?: SortOrder
    ota_id?: SortOrder
    confirmation_number?: SortOrder
    special_requests?: SortOrder
    internal_notes?: SortOrder
    origin_system?: SortOrder
    synced_at?: SortOrder
    updated_by_system?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    is_deleted?: SortOrder
    deleted_by?: SortOrder
  }

  export type reservationsSumOrderByAggregateInput = {
    adult_count?: SortOrder
    child_count?: SortOrder
    total_amount?: SortOrder
    deposit_amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Response_nodesRelationFilter = {
    is?: response_nodesWhereInput
    isNot?: response_nodesWhereInput
  }

  export type response_node_translationsNodeIdLanguageCompoundUniqueInput = {
    nodeId: string
    language: string
  }

  export type response_node_translationsNodeIdLocaleCompoundUniqueInput = {
    nodeId: string
    locale: string
  }

  export type response_node_translationsCountOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    locale?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answer?: SortOrder
    language?: SortOrder
    title?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type response_node_translationsMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    locale?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: SortOrder
    title?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type response_node_translationsMinOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    locale?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    language?: SortOrder
    title?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type Response_node_translationsListRelationFilter = {
    every?: response_node_translationsWhereInput
    some?: response_node_translationsWhereInput
    none?: response_node_translationsWhereInput
  }

  export type Response_nodesNullableRelationFilter = {
    is?: response_nodesWhereInput | null
    isNot?: response_nodesWhereInput | null
  }

  export type Response_nodesListRelationFilter = {
    every?: response_nodesWhereInput
    some?: response_nodesWhereInput
    none?: response_nodesWhereInput
  }

  export type Response_treesRelationFilter = {
    is?: response_treesWhereInput
    isNot?: response_treesWhereInput
  }

  export type Response_tree_historyListRelationFilter = {
    every?: response_tree_historyWhereInput
    some?: response_tree_historyWhereInput
    none?: response_tree_historyWhereInput
  }

  export type Response_tree_sessionsListRelationFilter = {
    every?: response_tree_sessionsWhereInput
    some?: response_tree_sessionsWhereInput
    none?: response_tree_sessionsWhereInput
  }

  export type response_node_translationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type response_nodesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type response_tree_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type response_tree_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type response_nodesCountOrderByAggregateInput = {
    id?: SortOrder
    treeId?: SortOrder
    nodeType?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    isRoot?: SortOrder
    parentId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answer?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    title?: SortOrder
    type?: SortOrder
  }

  export type response_nodesAvgOrderByAggregateInput = {
    position?: SortOrder
    order?: SortOrder
  }

  export type response_nodesMaxOrderByAggregateInput = {
    id?: SortOrder
    treeId?: SortOrder
    nodeType?: SortOrder
    content?: SortOrder
    isRoot?: SortOrder
    parentId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    title?: SortOrder
    type?: SortOrder
  }

  export type response_nodesMinOrderByAggregateInput = {
    id?: SortOrder
    treeId?: SortOrder
    nodeType?: SortOrder
    content?: SortOrder
    isRoot?: SortOrder
    parentId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    title?: SortOrder
    type?: SortOrder
  }

  export type response_nodesSumOrderByAggregateInput = {
    position?: SortOrder
    order?: SortOrder
  }

  export type Response_tree_sessionsRelationFilter = {
    is?: response_tree_sessionsWhereInput
    isNot?: response_tree_sessionsWhereInput
  }

  export type response_tree_historyCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    nodeId?: SortOrder
    response?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }

  export type response_tree_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    nodeId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }

  export type response_tree_historyMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    nodeId?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
  }

  export type response_tree_mobile_linksCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    code?: SortOrder
    qrCodeData?: SortOrder
    isActive?: SortOrder
    connectionId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    connectedAt?: SortOrder
    deviceId?: SortOrder
  }

  export type response_tree_mobile_linksAvgOrderByAggregateInput = {
    deviceId?: SortOrder
  }

  export type response_tree_mobile_linksMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    code?: SortOrder
    qrCodeData?: SortOrder
    isActive?: SortOrder
    connectionId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    connectedAt?: SortOrder
    deviceId?: SortOrder
  }

  export type response_tree_mobile_linksMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    code?: SortOrder
    qrCodeData?: SortOrder
    isActive?: SortOrder
    connectionId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    connectedAt?: SortOrder
    deviceId?: SortOrder
  }

  export type response_tree_mobile_linksSumOrderByAggregateInput = {
    deviceId?: SortOrder
  }

  export type Response_tree_mobile_linksListRelationFilter = {
    every?: response_tree_mobile_linksWhereInput
    some?: response_tree_mobile_linksWhereInput
    none?: response_tree_mobile_linksWhereInput
  }

  export type response_tree_mobile_linksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type response_tree_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    treeId?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    currentNodeId?: SortOrder
    metadata?: SortOrder
    isComplete?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    endedAt?: SortOrder
    interfaceType?: SortOrder
    language?: SortOrder
    lastActivityAt?: SortOrder
    roomId?: SortOrder
    sessionId?: SortOrder
  }

  export type response_tree_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    treeId?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    currentNodeId?: SortOrder
    isComplete?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    endedAt?: SortOrder
    interfaceType?: SortOrder
    language?: SortOrder
    lastActivityAt?: SortOrder
    roomId?: SortOrder
    sessionId?: SortOrder
  }

  export type response_tree_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    treeId?: SortOrder
    userId?: SortOrder
    deviceId?: SortOrder
    currentNodeId?: SortOrder
    isComplete?: SortOrder
    startedAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    endedAt?: SortOrder
    interfaceType?: SortOrder
    language?: SortOrder
    lastActivityAt?: SortOrder
    roomId?: SortOrder
    sessionId?: SortOrder
  }

  export type response_tree_versionsTreeIdVersionCompoundUniqueInput = {
    treeId: string
    version: number
  }

  export type response_tree_versionsCountOrderByAggregateInput = {
    id?: SortOrder
    treeId?: SortOrder
    version?: SortOrder
    snapshot?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    data?: SortOrder
  }

  export type response_tree_versionsAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type response_tree_versionsMaxOrderByAggregateInput = {
    id?: SortOrder
    treeId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type response_tree_versionsMinOrderByAggregateInput = {
    id?: SortOrder
    treeId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type response_tree_versionsSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type Response_tree_versionsListRelationFilter = {
    every?: response_tree_versionsWhereInput
    some?: response_tree_versionsWhereInput
    none?: response_tree_versionsWhereInput
  }

  export type response_tree_versionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type response_treesCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type response_treesAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type response_treesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type response_treesMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type response_treesSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type room_gradesTenant_idCodeCompoundUniqueInput = {
    tenant_id: string
    code: string
  }

  export type room_gradesCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type room_gradesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type room_gradesMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type schema_versionCountOrderByAggregateInput = {
    version?: SortOrder
    description?: SortOrder
    rollback_sql?: SortOrder
    applied_at?: SortOrder
    applied_by?: SortOrder
  }

  export type schema_versionMaxOrderByAggregateInput = {
    version?: SortOrder
    description?: SortOrder
    rollback_sql?: SortOrder
    applied_at?: SortOrder
    applied_by?: SortOrder
  }

  export type schema_versionMinOrderByAggregateInput = {
    version?: SortOrder
    description?: SortOrder
    rollback_sql?: SortOrder
    applied_at?: SortOrder
    applied_by?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type service_plan_restrictionsService_typePlan_typePlan_categoryCompoundUniqueInput = {
    service_type: string
    plan_type: string
    plan_category: string
  }

  export type service_plan_restrictionsCountOrderByAggregateInput = {
    id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    plan_category?: SortOrder
    max_users?: SortOrder
    max_devices?: SortOrder
    max_monthly_orders?: SortOrder
    enable_ai_concierge?: SortOrder
    enable_multilingual?: SortOrder
    max_rooms?: SortOrder
    enable_revenue_management?: SortOrder
    max_monthly_ai_requests?: SortOrder
    enable_ai_crm?: SortOrder
    monthly_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type service_plan_restrictionsAvgOrderByAggregateInput = {
    max_users?: SortOrder
    max_devices?: SortOrder
    max_monthly_orders?: SortOrder
    max_rooms?: SortOrder
    max_monthly_ai_requests?: SortOrder
    monthly_price?: SortOrder
  }

  export type service_plan_restrictionsMaxOrderByAggregateInput = {
    id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    plan_category?: SortOrder
    max_users?: SortOrder
    max_devices?: SortOrder
    max_monthly_orders?: SortOrder
    enable_ai_concierge?: SortOrder
    enable_multilingual?: SortOrder
    max_rooms?: SortOrder
    enable_revenue_management?: SortOrder
    max_monthly_ai_requests?: SortOrder
    enable_ai_crm?: SortOrder
    monthly_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type service_plan_restrictionsMinOrderByAggregateInput = {
    id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    plan_category?: SortOrder
    max_users?: SortOrder
    max_devices?: SortOrder
    max_monthly_orders?: SortOrder
    enable_ai_concierge?: SortOrder
    enable_multilingual?: SortOrder
    max_rooms?: SortOrder
    enable_revenue_management?: SortOrder
    max_monthly_ai_requests?: SortOrder
    enable_ai_crm?: SortOrder
    monthly_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type service_plan_restrictionsSumOrderByAggregateInput = {
    max_users?: SortOrder
    max_devices?: SortOrder
    max_monthly_orders?: SortOrder
    max_rooms?: SortOrder
    max_monthly_ai_requests?: SortOrder
    monthly_price?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type service_usage_statisticsTenant_idService_typeMonthCompoundUniqueInput = {
    tenant_id: string
    service_type: string
    month: string
  }

  export type service_usage_statisticsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    month?: SortOrder
    active_users_count?: SortOrder
    active_devices_count?: SortOrder
    usage_data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type service_usage_statisticsAvgOrderByAggregateInput = {
    active_users_count?: SortOrder
    active_devices_count?: SortOrder
  }

  export type service_usage_statisticsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    month?: SortOrder
    active_users_count?: SortOrder
    active_devices_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type service_usage_statisticsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    month?: SortOrder
    active_users_count?: SortOrder
    active_devices_count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type service_usage_statisticsSumOrderByAggregateInput = {
    active_users_count?: SortOrder
    active_devices_count?: SortOrder
  }

  export type staffTenant_idEmailCompoundUniqueInput = {
    tenant_id: string
    email: string
  }

  export type staffCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    failed_login_count?: SortOrder
    last_login_at?: SortOrder
    locked_until?: SortOrder
    password_hash?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type staffAvgOrderByAggregateInput = {
    failed_login_count?: SortOrder
  }

  export type staffMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    failed_login_count?: SortOrder
    last_login_at?: SortOrder
    locked_until?: SortOrder
    password_hash?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type staffMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    department?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    failed_login_count?: SortOrder
    last_login_at?: SortOrder
    locked_until?: SortOrder
    password_hash?: SortOrder
    deleted_at?: SortOrder
    deleted_by?: SortOrder
    is_deleted?: SortOrder
  }

  export type staffSumOrderByAggregateInput = {
    failed_login_count?: SortOrder
  }

  export type system_eventCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    event_type?: SortOrder
    source_system?: SortOrder
    target_system?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    event_data?: SortOrder
    created_at?: SortOrder
    processed_at?: SortOrder
    status?: SortOrder
  }

  export type system_eventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    event_type?: SortOrder
    source_system?: SortOrder
    target_system?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    created_at?: SortOrder
    processed_at?: SortOrder
    status?: SortOrder
  }

  export type system_eventMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    event_type?: SortOrder
    source_system?: SortOrder
    target_system?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    action?: SortOrder
    created_at?: SortOrder
    processed_at?: SortOrder
    status?: SortOrder
  }

  export type tenant_access_logsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
    source_system?: SortOrder
  }

  export type tenant_access_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
    source_system?: SortOrder
  }

  export type tenant_access_logsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
    source_system?: SortOrder
  }

  export type tenant_servicesTenant_idService_typeCompoundUniqueInput = {
    tenant_id: string
    service_type: string
  }

  export type tenant_servicesCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    is_active?: SortOrder
    activated_at?: SortOrder
    expires_at?: SortOrder
    service_config?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenant_servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    is_active?: SortOrder
    activated_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tenant_servicesMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    service_type?: SortOrder
    plan_type?: SortOrder
    is_active?: SortOrder
    activated_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type checkin_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_number?: SortOrder
    reservation_id?: SortOrder
    room_id?: SortOrder
    guest_info?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    check_in_at?: SortOrder
    check_out_at?: SortOrder
    planned_check_out?: SortOrder
    status?: SortOrder
    special_requests?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type checkin_sessionsAvgOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
  }

  export type checkin_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_number?: SortOrder
    reservation_id?: SortOrder
    room_id?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    check_in_at?: SortOrder
    check_out_at?: SortOrder
    planned_check_out?: SortOrder
    status?: SortOrder
    special_requests?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type checkin_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_number?: SortOrder
    reservation_id?: SortOrder
    room_id?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    check_in_at?: SortOrder
    check_out_at?: SortOrder
    planned_check_out?: SortOrder
    status?: SortOrder
    special_requests?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type checkin_sessionsSumOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
  }

  export type session_billingsCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_id?: SortOrder
    billing_number?: SortOrder
    room_charges?: SortOrder
    service_charges?: SortOrder
    taxes?: SortOrder
    discounts?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    paid_amount?: SortOrder
    status?: SortOrder
    payment_method?: SortOrder
    payment_date?: SortOrder
    due_date?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type session_billingsAvgOrderByAggregateInput = {
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    paid_amount?: SortOrder
  }

  export type session_billingsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_id?: SortOrder
    billing_number?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    paid_amount?: SortOrder
    status?: SortOrder
    payment_method?: SortOrder
    payment_date?: SortOrder
    due_date?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type session_billingsMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    session_id?: SortOrder
    billing_number?: SortOrder
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    paid_amount?: SortOrder
    status?: SortOrder
    payment_method?: SortOrder
    payment_date?: SortOrder
    due_date?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type session_billingsSumOrderByAggregateInput = {
    subtotal_amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    paid_amount?: SortOrder
  }

  export type RoomTenantIdRoomNumberCompoundUniqueInput = {
    tenantId: string
    roomNumber: string
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomNumber?: SortOrder
    roomType?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    amenities?: SortOrder
    notes?: SortOrder
    lastCleaned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    floor?: SortOrder
    capacity?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomNumber?: SortOrder
    roomType?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    notes?: SortOrder
    lastCleaned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomNumber?: SortOrder
    roomType?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    notes?: SortOrder
    lastCleaned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    floor?: SortOrder
    capacity?: SortOrder
  }

  export type InvoiceNullableRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PaymentNullableRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    billingAddress?: SortOrder
    items?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    issuedAt?: SortOrder
    paidAt?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    issuedAt?: SortOrder
    paidAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    issuedAt?: SortOrder
    paidAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type TransactionNullableRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrder
    invoiceId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    metadata?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrder
    invoiceId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transactionId?: SortOrder
    invoiceId?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    reference?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<OrderCreateWithoutOrderItemInput, OrderUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderItemNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemInput, OrderUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemInput
    upsert?: OrderUpsertWithoutOrderItemInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemInput, OrderUpdateWithoutOrderItemInput>, OrderUncheckedUpdateWithoutOrderItemInput>
  }

  export type TenantSystemPlanCreateNestedManyWithoutSystemPlanRestrictionsInput = {
    create?: XOR<TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput, TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput> | TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput[] | TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput[]
    connectOrCreate?: TenantSystemPlanCreateOrConnectWithoutSystemPlanRestrictionsInput | TenantSystemPlanCreateOrConnectWithoutSystemPlanRestrictionsInput[]
    createMany?: TenantSystemPlanCreateManySystemPlanRestrictionsInputEnvelope
    connect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
  }

  export type TenantSystemPlanUncheckedCreateNestedManyWithoutSystemPlanRestrictionsInput = {
    create?: XOR<TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput, TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput> | TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput[] | TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput[]
    connectOrCreate?: TenantSystemPlanCreateOrConnectWithoutSystemPlanRestrictionsInput | TenantSystemPlanCreateOrConnectWithoutSystemPlanRestrictionsInput[]
    createMany?: TenantSystemPlanCreateManySystemPlanRestrictionsInputEnvelope
    connect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantSystemPlanUpdateManyWithoutSystemPlanRestrictionsNestedInput = {
    create?: XOR<TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput, TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput> | TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput[] | TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput[]
    connectOrCreate?: TenantSystemPlanCreateOrConnectWithoutSystemPlanRestrictionsInput | TenantSystemPlanCreateOrConnectWithoutSystemPlanRestrictionsInput[]
    upsert?: TenantSystemPlanUpsertWithWhereUniqueWithoutSystemPlanRestrictionsInput | TenantSystemPlanUpsertWithWhereUniqueWithoutSystemPlanRestrictionsInput[]
    createMany?: TenantSystemPlanCreateManySystemPlanRestrictionsInputEnvelope
    set?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    disconnect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    delete?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    connect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    update?: TenantSystemPlanUpdateWithWhereUniqueWithoutSystemPlanRestrictionsInput | TenantSystemPlanUpdateWithWhereUniqueWithoutSystemPlanRestrictionsInput[]
    updateMany?: TenantSystemPlanUpdateManyWithWhereWithoutSystemPlanRestrictionsInput | TenantSystemPlanUpdateManyWithWhereWithoutSystemPlanRestrictionsInput[]
    deleteMany?: TenantSystemPlanScalarWhereInput | TenantSystemPlanScalarWhereInput[]
  }

  export type TenantSystemPlanUncheckedUpdateManyWithoutSystemPlanRestrictionsNestedInput = {
    create?: XOR<TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput, TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput> | TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput[] | TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput[]
    connectOrCreate?: TenantSystemPlanCreateOrConnectWithoutSystemPlanRestrictionsInput | TenantSystemPlanCreateOrConnectWithoutSystemPlanRestrictionsInput[]
    upsert?: TenantSystemPlanUpsertWithWhereUniqueWithoutSystemPlanRestrictionsInput | TenantSystemPlanUpsertWithWhereUniqueWithoutSystemPlanRestrictionsInput[]
    createMany?: TenantSystemPlanCreateManySystemPlanRestrictionsInputEnvelope
    set?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    disconnect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    delete?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    connect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    update?: TenantSystemPlanUpdateWithWhereUniqueWithoutSystemPlanRestrictionsInput | TenantSystemPlanUpdateWithWhereUniqueWithoutSystemPlanRestrictionsInput[]
    updateMany?: TenantSystemPlanUpdateManyWithWhereWithoutSystemPlanRestrictionsInput | TenantSystemPlanUpdateManyWithWhereWithoutSystemPlanRestrictionsInput[]
    deleteMany?: TenantSystemPlanScalarWhereInput | TenantSystemPlanScalarWhereInput[]
  }

  export type TenantCreatefeaturesInput = {
    set: string[]
  }

  export type TenantSystemPlanCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantSystemPlanCreateWithoutTenantInput, TenantSystemPlanUncheckedCreateWithoutTenantInput> | TenantSystemPlanCreateWithoutTenantInput[] | TenantSystemPlanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantSystemPlanCreateOrConnectWithoutTenantInput | TenantSystemPlanCreateOrConnectWithoutTenantInput[]
    createMany?: TenantSystemPlanCreateManyTenantInputEnvelope
    connect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
  }

  export type device_roomsCreateNestedManyWithoutTenantInput = {
    create?: XOR<device_roomsCreateWithoutTenantInput, device_roomsUncheckedCreateWithoutTenantInput> | device_roomsCreateWithoutTenantInput[] | device_roomsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: device_roomsCreateOrConnectWithoutTenantInput | device_roomsCreateOrConnectWithoutTenantInput[]
    createMany?: device_roomsCreateManyTenantInputEnvelope
    connect?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
  }

  export type pagesCreateNestedManyWithoutTenantInput = {
    create?: XOR<pagesCreateWithoutTenantInput, pagesUncheckedCreateWithoutTenantInput> | pagesCreateWithoutTenantInput[] | pagesUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: pagesCreateOrConnectWithoutTenantInput | pagesCreateOrConnectWithoutTenantInput[]
    createMany?: pagesCreateManyTenantInputEnvelope
    connect?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
  }

  export type service_usage_statisticsCreateNestedManyWithoutTenantInput = {
    create?: XOR<service_usage_statisticsCreateWithoutTenantInput, service_usage_statisticsUncheckedCreateWithoutTenantInput> | service_usage_statisticsCreateWithoutTenantInput[] | service_usage_statisticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: service_usage_statisticsCreateOrConnectWithoutTenantInput | service_usage_statisticsCreateOrConnectWithoutTenantInput[]
    createMany?: service_usage_statisticsCreateManyTenantInputEnvelope
    connect?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
  }

  export type tenant_servicesCreateNestedManyWithoutTenantInput = {
    create?: XOR<tenant_servicesCreateWithoutTenantInput, tenant_servicesUncheckedCreateWithoutTenantInput> | tenant_servicesCreateWithoutTenantInput[] | tenant_servicesUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: tenant_servicesCreateOrConnectWithoutTenantInput | tenant_servicesCreateOrConnectWithoutTenantInput[]
    createMany?: tenant_servicesCreateManyTenantInputEnvelope
    connect?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
  }

  export type TenantSystemPlanUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantSystemPlanCreateWithoutTenantInput, TenantSystemPlanUncheckedCreateWithoutTenantInput> | TenantSystemPlanCreateWithoutTenantInput[] | TenantSystemPlanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantSystemPlanCreateOrConnectWithoutTenantInput | TenantSystemPlanCreateOrConnectWithoutTenantInput[]
    createMany?: TenantSystemPlanCreateManyTenantInputEnvelope
    connect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
  }

  export type device_roomsUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<device_roomsCreateWithoutTenantInput, device_roomsUncheckedCreateWithoutTenantInput> | device_roomsCreateWithoutTenantInput[] | device_roomsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: device_roomsCreateOrConnectWithoutTenantInput | device_roomsCreateOrConnectWithoutTenantInput[]
    createMany?: device_roomsCreateManyTenantInputEnvelope
    connect?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
  }

  export type pagesUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<pagesCreateWithoutTenantInput, pagesUncheckedCreateWithoutTenantInput> | pagesCreateWithoutTenantInput[] | pagesUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: pagesCreateOrConnectWithoutTenantInput | pagesCreateOrConnectWithoutTenantInput[]
    createMany?: pagesCreateManyTenantInputEnvelope
    connect?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
  }

  export type service_usage_statisticsUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<service_usage_statisticsCreateWithoutTenantInput, service_usage_statisticsUncheckedCreateWithoutTenantInput> | service_usage_statisticsCreateWithoutTenantInput[] | service_usage_statisticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: service_usage_statisticsCreateOrConnectWithoutTenantInput | service_usage_statisticsCreateOrConnectWithoutTenantInput[]
    createMany?: service_usage_statisticsCreateManyTenantInputEnvelope
    connect?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
  }

  export type tenant_servicesUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<tenant_servicesCreateWithoutTenantInput, tenant_servicesUncheckedCreateWithoutTenantInput> | tenant_servicesCreateWithoutTenantInput[] | tenant_servicesUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: tenant_servicesCreateOrConnectWithoutTenantInput | tenant_servicesCreateOrConnectWithoutTenantInput[]
    createMany?: tenant_servicesCreateManyTenantInputEnvelope
    connect?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
  }

  export type TenantUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TenantSystemPlanUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantSystemPlanCreateWithoutTenantInput, TenantSystemPlanUncheckedCreateWithoutTenantInput> | TenantSystemPlanCreateWithoutTenantInput[] | TenantSystemPlanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantSystemPlanCreateOrConnectWithoutTenantInput | TenantSystemPlanCreateOrConnectWithoutTenantInput[]
    upsert?: TenantSystemPlanUpsertWithWhereUniqueWithoutTenantInput | TenantSystemPlanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantSystemPlanCreateManyTenantInputEnvelope
    set?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    disconnect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    delete?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    connect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    update?: TenantSystemPlanUpdateWithWhereUniqueWithoutTenantInput | TenantSystemPlanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantSystemPlanUpdateManyWithWhereWithoutTenantInput | TenantSystemPlanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantSystemPlanScalarWhereInput | TenantSystemPlanScalarWhereInput[]
  }

  export type device_roomsUpdateManyWithoutTenantNestedInput = {
    create?: XOR<device_roomsCreateWithoutTenantInput, device_roomsUncheckedCreateWithoutTenantInput> | device_roomsCreateWithoutTenantInput[] | device_roomsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: device_roomsCreateOrConnectWithoutTenantInput | device_roomsCreateOrConnectWithoutTenantInput[]
    upsert?: device_roomsUpsertWithWhereUniqueWithoutTenantInput | device_roomsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: device_roomsCreateManyTenantInputEnvelope
    set?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
    disconnect?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
    delete?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
    connect?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
    update?: device_roomsUpdateWithWhereUniqueWithoutTenantInput | device_roomsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: device_roomsUpdateManyWithWhereWithoutTenantInput | device_roomsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: device_roomsScalarWhereInput | device_roomsScalarWhereInput[]
  }

  export type pagesUpdateManyWithoutTenantNestedInput = {
    create?: XOR<pagesCreateWithoutTenantInput, pagesUncheckedCreateWithoutTenantInput> | pagesCreateWithoutTenantInput[] | pagesUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: pagesCreateOrConnectWithoutTenantInput | pagesCreateOrConnectWithoutTenantInput[]
    upsert?: pagesUpsertWithWhereUniqueWithoutTenantInput | pagesUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: pagesCreateManyTenantInputEnvelope
    set?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
    disconnect?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
    delete?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
    connect?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
    update?: pagesUpdateWithWhereUniqueWithoutTenantInput | pagesUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: pagesUpdateManyWithWhereWithoutTenantInput | pagesUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: pagesScalarWhereInput | pagesScalarWhereInput[]
  }

  export type service_usage_statisticsUpdateManyWithoutTenantNestedInput = {
    create?: XOR<service_usage_statisticsCreateWithoutTenantInput, service_usage_statisticsUncheckedCreateWithoutTenantInput> | service_usage_statisticsCreateWithoutTenantInput[] | service_usage_statisticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: service_usage_statisticsCreateOrConnectWithoutTenantInput | service_usage_statisticsCreateOrConnectWithoutTenantInput[]
    upsert?: service_usage_statisticsUpsertWithWhereUniqueWithoutTenantInput | service_usage_statisticsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: service_usage_statisticsCreateManyTenantInputEnvelope
    set?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
    disconnect?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
    delete?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
    connect?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
    update?: service_usage_statisticsUpdateWithWhereUniqueWithoutTenantInput | service_usage_statisticsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: service_usage_statisticsUpdateManyWithWhereWithoutTenantInput | service_usage_statisticsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: service_usage_statisticsScalarWhereInput | service_usage_statisticsScalarWhereInput[]
  }

  export type tenant_servicesUpdateManyWithoutTenantNestedInput = {
    create?: XOR<tenant_servicesCreateWithoutTenantInput, tenant_servicesUncheckedCreateWithoutTenantInput> | tenant_servicesCreateWithoutTenantInput[] | tenant_servicesUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: tenant_servicesCreateOrConnectWithoutTenantInput | tenant_servicesCreateOrConnectWithoutTenantInput[]
    upsert?: tenant_servicesUpsertWithWhereUniqueWithoutTenantInput | tenant_servicesUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: tenant_servicesCreateManyTenantInputEnvelope
    set?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
    disconnect?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
    delete?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
    connect?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
    update?: tenant_servicesUpdateWithWhereUniqueWithoutTenantInput | tenant_servicesUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: tenant_servicesUpdateManyWithWhereWithoutTenantInput | tenant_servicesUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: tenant_servicesScalarWhereInput | tenant_servicesScalarWhereInput[]
  }

  export type TenantSystemPlanUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantSystemPlanCreateWithoutTenantInput, TenantSystemPlanUncheckedCreateWithoutTenantInput> | TenantSystemPlanCreateWithoutTenantInput[] | TenantSystemPlanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantSystemPlanCreateOrConnectWithoutTenantInput | TenantSystemPlanCreateOrConnectWithoutTenantInput[]
    upsert?: TenantSystemPlanUpsertWithWhereUniqueWithoutTenantInput | TenantSystemPlanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantSystemPlanCreateManyTenantInputEnvelope
    set?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    disconnect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    delete?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    connect?: TenantSystemPlanWhereUniqueInput | TenantSystemPlanWhereUniqueInput[]
    update?: TenantSystemPlanUpdateWithWhereUniqueWithoutTenantInput | TenantSystemPlanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantSystemPlanUpdateManyWithWhereWithoutTenantInput | TenantSystemPlanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantSystemPlanScalarWhereInput | TenantSystemPlanScalarWhereInput[]
  }

  export type device_roomsUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<device_roomsCreateWithoutTenantInput, device_roomsUncheckedCreateWithoutTenantInput> | device_roomsCreateWithoutTenantInput[] | device_roomsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: device_roomsCreateOrConnectWithoutTenantInput | device_roomsCreateOrConnectWithoutTenantInput[]
    upsert?: device_roomsUpsertWithWhereUniqueWithoutTenantInput | device_roomsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: device_roomsCreateManyTenantInputEnvelope
    set?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
    disconnect?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
    delete?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
    connect?: device_roomsWhereUniqueInput | device_roomsWhereUniqueInput[]
    update?: device_roomsUpdateWithWhereUniqueWithoutTenantInput | device_roomsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: device_roomsUpdateManyWithWhereWithoutTenantInput | device_roomsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: device_roomsScalarWhereInput | device_roomsScalarWhereInput[]
  }

  export type pagesUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<pagesCreateWithoutTenantInput, pagesUncheckedCreateWithoutTenantInput> | pagesCreateWithoutTenantInput[] | pagesUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: pagesCreateOrConnectWithoutTenantInput | pagesCreateOrConnectWithoutTenantInput[]
    upsert?: pagesUpsertWithWhereUniqueWithoutTenantInput | pagesUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: pagesCreateManyTenantInputEnvelope
    set?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
    disconnect?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
    delete?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
    connect?: pagesWhereUniqueInput | pagesWhereUniqueInput[]
    update?: pagesUpdateWithWhereUniqueWithoutTenantInput | pagesUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: pagesUpdateManyWithWhereWithoutTenantInput | pagesUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: pagesScalarWhereInput | pagesScalarWhereInput[]
  }

  export type service_usage_statisticsUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<service_usage_statisticsCreateWithoutTenantInput, service_usage_statisticsUncheckedCreateWithoutTenantInput> | service_usage_statisticsCreateWithoutTenantInput[] | service_usage_statisticsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: service_usage_statisticsCreateOrConnectWithoutTenantInput | service_usage_statisticsCreateOrConnectWithoutTenantInput[]
    upsert?: service_usage_statisticsUpsertWithWhereUniqueWithoutTenantInput | service_usage_statisticsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: service_usage_statisticsCreateManyTenantInputEnvelope
    set?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
    disconnect?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
    delete?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
    connect?: service_usage_statisticsWhereUniqueInput | service_usage_statisticsWhereUniqueInput[]
    update?: service_usage_statisticsUpdateWithWhereUniqueWithoutTenantInput | service_usage_statisticsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: service_usage_statisticsUpdateManyWithWhereWithoutTenantInput | service_usage_statisticsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: service_usage_statisticsScalarWhereInput | service_usage_statisticsScalarWhereInput[]
  }

  export type tenant_servicesUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<tenant_servicesCreateWithoutTenantInput, tenant_servicesUncheckedCreateWithoutTenantInput> | tenant_servicesCreateWithoutTenantInput[] | tenant_servicesUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: tenant_servicesCreateOrConnectWithoutTenantInput | tenant_servicesCreateOrConnectWithoutTenantInput[]
    upsert?: tenant_servicesUpsertWithWhereUniqueWithoutTenantInput | tenant_servicesUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: tenant_servicesCreateManyTenantInputEnvelope
    set?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
    disconnect?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
    delete?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
    connect?: tenant_servicesWhereUniqueInput | tenant_servicesWhereUniqueInput[]
    update?: tenant_servicesUpdateWithWhereUniqueWithoutTenantInput | tenant_servicesUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: tenant_servicesUpdateManyWithWhereWithoutTenantInput | tenant_servicesUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: tenant_servicesScalarWhereInput | tenant_servicesScalarWhereInput[]
  }

  export type SystemPlanRestrictionsCreateNestedOneWithoutTenantSystemPlanInput = {
    create?: XOR<SystemPlanRestrictionsCreateWithoutTenantSystemPlanInput, SystemPlanRestrictionsUncheckedCreateWithoutTenantSystemPlanInput>
    connectOrCreate?: SystemPlanRestrictionsCreateOrConnectWithoutTenantSystemPlanInput
    connect?: SystemPlanRestrictionsWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutTenantSystemPlanInput = {
    create?: XOR<TenantCreateWithoutTenantSystemPlanInput, TenantUncheckedCreateWithoutTenantSystemPlanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantSystemPlanInput
    connect?: TenantWhereUniqueInput
  }

  export type SystemPlanRestrictionsUpdateOneRequiredWithoutTenantSystemPlanNestedInput = {
    create?: XOR<SystemPlanRestrictionsCreateWithoutTenantSystemPlanInput, SystemPlanRestrictionsUncheckedCreateWithoutTenantSystemPlanInput>
    connectOrCreate?: SystemPlanRestrictionsCreateOrConnectWithoutTenantSystemPlanInput
    upsert?: SystemPlanRestrictionsUpsertWithoutTenantSystemPlanInput
    connect?: SystemPlanRestrictionsWhereUniqueInput
    update?: XOR<XOR<SystemPlanRestrictionsUpdateToOneWithWhereWithoutTenantSystemPlanInput, SystemPlanRestrictionsUpdateWithoutTenantSystemPlanInput>, SystemPlanRestrictionsUncheckedUpdateWithoutTenantSystemPlanInput>
  }

  export type TenantUpdateOneRequiredWithoutTenantSystemPlanNestedInput = {
    create?: XOR<TenantCreateWithoutTenantSystemPlanInput, TenantUncheckedCreateWithoutTenantSystemPlanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantSystemPlanInput
    upsert?: TenantUpsertWithoutTenantSystemPlanInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTenantSystemPlanInput, TenantUpdateWithoutTenantSystemPlanInput>, TenantUncheckedUpdateWithoutTenantSystemPlanInput>
  }

  export type adminCreateaccessible_group_idsInput = {
    set: string[]
  }

  export type adminCreateaccessible_chain_idsInput = {
    set: string[]
  }

  export type adminCreateaccessible_tenant_idsInput = {
    set: string[]
  }

  export type admin_logCreateNestedManyWithoutAdminInput = {
    create?: XOR<admin_logCreateWithoutAdminInput, admin_logUncheckedCreateWithoutAdminInput> | admin_logCreateWithoutAdminInput[] | admin_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_logCreateOrConnectWithoutAdminInput | admin_logCreateOrConnectWithoutAdminInput[]
    createMany?: admin_logCreateManyAdminInputEnvelope
    connect?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
  }

  export type admin_logUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<admin_logCreateWithoutAdminInput, admin_logUncheckedCreateWithoutAdminInput> | admin_logCreateWithoutAdminInput[] | admin_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_logCreateOrConnectWithoutAdminInput | admin_logCreateOrConnectWithoutAdminInput[]
    createMany?: admin_logCreateManyAdminInputEnvelope
    connect?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
  }

  export type EnumAdminLevelFieldUpdateOperationsInput = {
    set?: $Enums.AdminLevel
  }

  export type adminUpdateaccessible_group_idsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type adminUpdateaccessible_chain_idsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type adminUpdateaccessible_tenant_idsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type admin_logUpdateManyWithoutAdminNestedInput = {
    create?: XOR<admin_logCreateWithoutAdminInput, admin_logUncheckedCreateWithoutAdminInput> | admin_logCreateWithoutAdminInput[] | admin_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_logCreateOrConnectWithoutAdminInput | admin_logCreateOrConnectWithoutAdminInput[]
    upsert?: admin_logUpsertWithWhereUniqueWithoutAdminInput | admin_logUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: admin_logCreateManyAdminInputEnvelope
    set?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
    disconnect?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
    delete?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
    connect?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
    update?: admin_logUpdateWithWhereUniqueWithoutAdminInput | admin_logUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: admin_logUpdateManyWithWhereWithoutAdminInput | admin_logUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: admin_logScalarWhereInput | admin_logScalarWhereInput[]
  }

  export type admin_logUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<admin_logCreateWithoutAdminInput, admin_logUncheckedCreateWithoutAdminInput> | admin_logCreateWithoutAdminInput[] | admin_logUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: admin_logCreateOrConnectWithoutAdminInput | admin_logCreateOrConnectWithoutAdminInput[]
    upsert?: admin_logUpsertWithWhereUniqueWithoutAdminInput | admin_logUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: admin_logCreateManyAdminInputEnvelope
    set?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
    disconnect?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
    delete?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
    connect?: admin_logWhereUniqueInput | admin_logWhereUniqueInput[]
    update?: admin_logUpdateWithWhereUniqueWithoutAdminInput | admin_logUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: admin_logUpdateManyWithWhereWithoutAdminInput | admin_logUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: admin_logScalarWhereInput | admin_logScalarWhereInput[]
  }

  export type adminCreateNestedOneWithoutAdmin_logInput = {
    create?: XOR<adminCreateWithoutAdmin_logInput, adminUncheckedCreateWithoutAdmin_logInput>
    connectOrCreate?: adminCreateOrConnectWithoutAdmin_logInput
    connect?: adminWhereUniqueInput
  }

  export type adminUpdateOneRequiredWithoutAdmin_logNestedInput = {
    create?: XOR<adminCreateWithoutAdmin_logInput, adminUncheckedCreateWithoutAdmin_logInput>
    connectOrCreate?: adminCreateOrConnectWithoutAdmin_logInput
    upsert?: adminUpsertWithoutAdmin_logInput
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutAdmin_logInput, adminUpdateWithoutAdmin_logInput>, adminUncheckedUpdateWithoutAdmin_logInput>
  }

  export type campaign_category_relationsCreateNestedManyWithoutCampaign_categoriesInput = {
    create?: XOR<campaign_category_relationsCreateWithoutCampaign_categoriesInput, campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput> | campaign_category_relationsCreateWithoutCampaign_categoriesInput[] | campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput[]
    connectOrCreate?: campaign_category_relationsCreateOrConnectWithoutCampaign_categoriesInput | campaign_category_relationsCreateOrConnectWithoutCampaign_categoriesInput[]
    createMany?: campaign_category_relationsCreateManyCampaign_categoriesInputEnvelope
    connect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
  }

  export type campaign_category_relationsUncheckedCreateNestedManyWithoutCampaign_categoriesInput = {
    create?: XOR<campaign_category_relationsCreateWithoutCampaign_categoriesInput, campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput> | campaign_category_relationsCreateWithoutCampaign_categoriesInput[] | campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput[]
    connectOrCreate?: campaign_category_relationsCreateOrConnectWithoutCampaign_categoriesInput | campaign_category_relationsCreateOrConnectWithoutCampaign_categoriesInput[]
    createMany?: campaign_category_relationsCreateManyCampaign_categoriesInputEnvelope
    connect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
  }

  export type campaign_category_relationsUpdateManyWithoutCampaign_categoriesNestedInput = {
    create?: XOR<campaign_category_relationsCreateWithoutCampaign_categoriesInput, campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput> | campaign_category_relationsCreateWithoutCampaign_categoriesInput[] | campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput[]
    connectOrCreate?: campaign_category_relationsCreateOrConnectWithoutCampaign_categoriesInput | campaign_category_relationsCreateOrConnectWithoutCampaign_categoriesInput[]
    upsert?: campaign_category_relationsUpsertWithWhereUniqueWithoutCampaign_categoriesInput | campaign_category_relationsUpsertWithWhereUniqueWithoutCampaign_categoriesInput[]
    createMany?: campaign_category_relationsCreateManyCampaign_categoriesInputEnvelope
    set?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    disconnect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    delete?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    connect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    update?: campaign_category_relationsUpdateWithWhereUniqueWithoutCampaign_categoriesInput | campaign_category_relationsUpdateWithWhereUniqueWithoutCampaign_categoriesInput[]
    updateMany?: campaign_category_relationsUpdateManyWithWhereWithoutCampaign_categoriesInput | campaign_category_relationsUpdateManyWithWhereWithoutCampaign_categoriesInput[]
    deleteMany?: campaign_category_relationsScalarWhereInput | campaign_category_relationsScalarWhereInput[]
  }

  export type campaign_category_relationsUncheckedUpdateManyWithoutCampaign_categoriesNestedInput = {
    create?: XOR<campaign_category_relationsCreateWithoutCampaign_categoriesInput, campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput> | campaign_category_relationsCreateWithoutCampaign_categoriesInput[] | campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput[]
    connectOrCreate?: campaign_category_relationsCreateOrConnectWithoutCampaign_categoriesInput | campaign_category_relationsCreateOrConnectWithoutCampaign_categoriesInput[]
    upsert?: campaign_category_relationsUpsertWithWhereUniqueWithoutCampaign_categoriesInput | campaign_category_relationsUpsertWithWhereUniqueWithoutCampaign_categoriesInput[]
    createMany?: campaign_category_relationsCreateManyCampaign_categoriesInputEnvelope
    set?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    disconnect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    delete?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    connect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    update?: campaign_category_relationsUpdateWithWhereUniqueWithoutCampaign_categoriesInput | campaign_category_relationsUpdateWithWhereUniqueWithoutCampaign_categoriesInput[]
    updateMany?: campaign_category_relationsUpdateManyWithWhereWithoutCampaign_categoriesInput | campaign_category_relationsUpdateManyWithWhereWithoutCampaign_categoriesInput[]
    deleteMany?: campaign_category_relationsScalarWhereInput | campaign_category_relationsScalarWhereInput[]
  }

  export type campaignsCreateNestedOneWithoutCampaign_category_relationsInput = {
    create?: XOR<campaignsCreateWithoutCampaign_category_relationsInput, campaignsUncheckedCreateWithoutCampaign_category_relationsInput>
    connectOrCreate?: campaignsCreateOrConnectWithoutCampaign_category_relationsInput
    connect?: campaignsWhereUniqueInput
  }

  export type campaign_categoriesCreateNestedOneWithoutCampaign_category_relationsInput = {
    create?: XOR<campaign_categoriesCreateWithoutCampaign_category_relationsInput, campaign_categoriesUncheckedCreateWithoutCampaign_category_relationsInput>
    connectOrCreate?: campaign_categoriesCreateOrConnectWithoutCampaign_category_relationsInput
    connect?: campaign_categoriesWhereUniqueInput
  }

  export type campaignsUpdateOneRequiredWithoutCampaign_category_relationsNestedInput = {
    create?: XOR<campaignsCreateWithoutCampaign_category_relationsInput, campaignsUncheckedCreateWithoutCampaign_category_relationsInput>
    connectOrCreate?: campaignsCreateOrConnectWithoutCampaign_category_relationsInput
    upsert?: campaignsUpsertWithoutCampaign_category_relationsInput
    connect?: campaignsWhereUniqueInput
    update?: XOR<XOR<campaignsUpdateToOneWithWhereWithoutCampaign_category_relationsInput, campaignsUpdateWithoutCampaign_category_relationsInput>, campaignsUncheckedUpdateWithoutCampaign_category_relationsInput>
  }

  export type campaign_categoriesUpdateOneRequiredWithoutCampaign_category_relationsNestedInput = {
    create?: XOR<campaign_categoriesCreateWithoutCampaign_category_relationsInput, campaign_categoriesUncheckedCreateWithoutCampaign_category_relationsInput>
    connectOrCreate?: campaign_categoriesCreateOrConnectWithoutCampaign_category_relationsInput
    upsert?: campaign_categoriesUpsertWithoutCampaign_category_relationsInput
    connect?: campaign_categoriesWhereUniqueInput
    update?: XOR<XOR<campaign_categoriesUpdateToOneWithWhereWithoutCampaign_category_relationsInput, campaign_categoriesUpdateWithoutCampaign_category_relationsInput>, campaign_categoriesUncheckedUpdateWithoutCampaign_category_relationsInput>
  }

  export type campaignsCreateNestedOneWithoutCampaign_itemsInput = {
    create?: XOR<campaignsCreateWithoutCampaign_itemsInput, campaignsUncheckedCreateWithoutCampaign_itemsInput>
    connectOrCreate?: campaignsCreateOrConnectWithoutCampaign_itemsInput
    connect?: campaignsWhereUniqueInput
  }

  export type campaignsUpdateOneRequiredWithoutCampaign_itemsNestedInput = {
    create?: XOR<campaignsCreateWithoutCampaign_itemsInput, campaignsUncheckedCreateWithoutCampaign_itemsInput>
    connectOrCreate?: campaignsCreateOrConnectWithoutCampaign_itemsInput
    upsert?: campaignsUpsertWithoutCampaign_itemsInput
    connect?: campaignsWhereUniqueInput
    update?: XOR<XOR<campaignsUpdateToOneWithWhereWithoutCampaign_itemsInput, campaignsUpdateWithoutCampaign_itemsInput>, campaignsUncheckedUpdateWithoutCampaign_itemsInput>
  }

  export type campaignsCreateNestedOneWithoutCampaign_translationsInput = {
    create?: XOR<campaignsCreateWithoutCampaign_translationsInput, campaignsUncheckedCreateWithoutCampaign_translationsInput>
    connectOrCreate?: campaignsCreateOrConnectWithoutCampaign_translationsInput
    connect?: campaignsWhereUniqueInput
  }

  export type campaignsUpdateOneRequiredWithoutCampaign_translationsNestedInput = {
    create?: XOR<campaignsCreateWithoutCampaign_translationsInput, campaignsUncheckedCreateWithoutCampaign_translationsInput>
    connectOrCreate?: campaignsCreateOrConnectWithoutCampaign_translationsInput
    upsert?: campaignsUpsertWithoutCampaign_translationsInput
    connect?: campaignsWhereUniqueInput
    update?: XOR<XOR<campaignsUpdateToOneWithWhereWithoutCampaign_translationsInput, campaignsUpdateWithoutCampaign_translationsInput>, campaignsUncheckedUpdateWithoutCampaign_translationsInput>
  }

  export type campaignsCreateNestedOneWithoutCampaign_usage_logsInput = {
    create?: XOR<campaignsCreateWithoutCampaign_usage_logsInput, campaignsUncheckedCreateWithoutCampaign_usage_logsInput>
    connectOrCreate?: campaignsCreateOrConnectWithoutCampaign_usage_logsInput
    connect?: campaignsWhereUniqueInput
  }

  export type campaignsUpdateOneRequiredWithoutCampaign_usage_logsNestedInput = {
    create?: XOR<campaignsCreateWithoutCampaign_usage_logsInput, campaignsUncheckedCreateWithoutCampaign_usage_logsInput>
    connectOrCreate?: campaignsCreateOrConnectWithoutCampaign_usage_logsInput
    upsert?: campaignsUpsertWithoutCampaign_usage_logsInput
    connect?: campaignsWhereUniqueInput
    update?: XOR<XOR<campaignsUpdateToOneWithWhereWithoutCampaign_usage_logsInput, campaignsUpdateWithoutCampaign_usage_logsInput>, campaignsUncheckedUpdateWithoutCampaign_usage_logsInput>
  }

  export type campaign_category_relationsCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<campaign_category_relationsCreateWithoutCampaignsInput, campaign_category_relationsUncheckedCreateWithoutCampaignsInput> | campaign_category_relationsCreateWithoutCampaignsInput[] | campaign_category_relationsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_category_relationsCreateOrConnectWithoutCampaignsInput | campaign_category_relationsCreateOrConnectWithoutCampaignsInput[]
    createMany?: campaign_category_relationsCreateManyCampaignsInputEnvelope
    connect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
  }

  export type campaign_itemsCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<campaign_itemsCreateWithoutCampaignsInput, campaign_itemsUncheckedCreateWithoutCampaignsInput> | campaign_itemsCreateWithoutCampaignsInput[] | campaign_itemsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_itemsCreateOrConnectWithoutCampaignsInput | campaign_itemsCreateOrConnectWithoutCampaignsInput[]
    createMany?: campaign_itemsCreateManyCampaignsInputEnvelope
    connect?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
  }

  export type campaign_translationsCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<campaign_translationsCreateWithoutCampaignsInput, campaign_translationsUncheckedCreateWithoutCampaignsInput> | campaign_translationsCreateWithoutCampaignsInput[] | campaign_translationsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_translationsCreateOrConnectWithoutCampaignsInput | campaign_translationsCreateOrConnectWithoutCampaignsInput[]
    createMany?: campaign_translationsCreateManyCampaignsInputEnvelope
    connect?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
  }

  export type campaign_usage_logsCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<campaign_usage_logsCreateWithoutCampaignsInput, campaign_usage_logsUncheckedCreateWithoutCampaignsInput> | campaign_usage_logsCreateWithoutCampaignsInput[] | campaign_usage_logsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_usage_logsCreateOrConnectWithoutCampaignsInput | campaign_usage_logsCreateOrConnectWithoutCampaignsInput[]
    createMany?: campaign_usage_logsCreateManyCampaignsInputEnvelope
    connect?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
  }

  export type campaign_category_relationsUncheckedCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<campaign_category_relationsCreateWithoutCampaignsInput, campaign_category_relationsUncheckedCreateWithoutCampaignsInput> | campaign_category_relationsCreateWithoutCampaignsInput[] | campaign_category_relationsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_category_relationsCreateOrConnectWithoutCampaignsInput | campaign_category_relationsCreateOrConnectWithoutCampaignsInput[]
    createMany?: campaign_category_relationsCreateManyCampaignsInputEnvelope
    connect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
  }

  export type campaign_itemsUncheckedCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<campaign_itemsCreateWithoutCampaignsInput, campaign_itemsUncheckedCreateWithoutCampaignsInput> | campaign_itemsCreateWithoutCampaignsInput[] | campaign_itemsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_itemsCreateOrConnectWithoutCampaignsInput | campaign_itemsCreateOrConnectWithoutCampaignsInput[]
    createMany?: campaign_itemsCreateManyCampaignsInputEnvelope
    connect?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
  }

  export type campaign_translationsUncheckedCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<campaign_translationsCreateWithoutCampaignsInput, campaign_translationsUncheckedCreateWithoutCampaignsInput> | campaign_translationsCreateWithoutCampaignsInput[] | campaign_translationsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_translationsCreateOrConnectWithoutCampaignsInput | campaign_translationsCreateOrConnectWithoutCampaignsInput[]
    createMany?: campaign_translationsCreateManyCampaignsInputEnvelope
    connect?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
  }

  export type campaign_usage_logsUncheckedCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<campaign_usage_logsCreateWithoutCampaignsInput, campaign_usage_logsUncheckedCreateWithoutCampaignsInput> | campaign_usage_logsCreateWithoutCampaignsInput[] | campaign_usage_logsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_usage_logsCreateOrConnectWithoutCampaignsInput | campaign_usage_logsCreateOrConnectWithoutCampaignsInput[]
    createMany?: campaign_usage_logsCreateManyCampaignsInputEnvelope
    connect?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type EnumCampaignDisplayTypeFieldUpdateOperationsInput = {
    set?: $Enums.CampaignDisplayType
  }

  export type EnumCampaignCtaTypeFieldUpdateOperationsInput = {
    set?: $Enums.CampaignCtaType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type campaign_category_relationsUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<campaign_category_relationsCreateWithoutCampaignsInput, campaign_category_relationsUncheckedCreateWithoutCampaignsInput> | campaign_category_relationsCreateWithoutCampaignsInput[] | campaign_category_relationsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_category_relationsCreateOrConnectWithoutCampaignsInput | campaign_category_relationsCreateOrConnectWithoutCampaignsInput[]
    upsert?: campaign_category_relationsUpsertWithWhereUniqueWithoutCampaignsInput | campaign_category_relationsUpsertWithWhereUniqueWithoutCampaignsInput[]
    createMany?: campaign_category_relationsCreateManyCampaignsInputEnvelope
    set?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    disconnect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    delete?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    connect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    update?: campaign_category_relationsUpdateWithWhereUniqueWithoutCampaignsInput | campaign_category_relationsUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: campaign_category_relationsUpdateManyWithWhereWithoutCampaignsInput | campaign_category_relationsUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: campaign_category_relationsScalarWhereInput | campaign_category_relationsScalarWhereInput[]
  }

  export type campaign_itemsUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<campaign_itemsCreateWithoutCampaignsInput, campaign_itemsUncheckedCreateWithoutCampaignsInput> | campaign_itemsCreateWithoutCampaignsInput[] | campaign_itemsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_itemsCreateOrConnectWithoutCampaignsInput | campaign_itemsCreateOrConnectWithoutCampaignsInput[]
    upsert?: campaign_itemsUpsertWithWhereUniqueWithoutCampaignsInput | campaign_itemsUpsertWithWhereUniqueWithoutCampaignsInput[]
    createMany?: campaign_itemsCreateManyCampaignsInputEnvelope
    set?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
    disconnect?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
    delete?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
    connect?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
    update?: campaign_itemsUpdateWithWhereUniqueWithoutCampaignsInput | campaign_itemsUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: campaign_itemsUpdateManyWithWhereWithoutCampaignsInput | campaign_itemsUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: campaign_itemsScalarWhereInput | campaign_itemsScalarWhereInput[]
  }

  export type campaign_translationsUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<campaign_translationsCreateWithoutCampaignsInput, campaign_translationsUncheckedCreateWithoutCampaignsInput> | campaign_translationsCreateWithoutCampaignsInput[] | campaign_translationsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_translationsCreateOrConnectWithoutCampaignsInput | campaign_translationsCreateOrConnectWithoutCampaignsInput[]
    upsert?: campaign_translationsUpsertWithWhereUniqueWithoutCampaignsInput | campaign_translationsUpsertWithWhereUniqueWithoutCampaignsInput[]
    createMany?: campaign_translationsCreateManyCampaignsInputEnvelope
    set?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
    disconnect?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
    delete?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
    connect?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
    update?: campaign_translationsUpdateWithWhereUniqueWithoutCampaignsInput | campaign_translationsUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: campaign_translationsUpdateManyWithWhereWithoutCampaignsInput | campaign_translationsUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: campaign_translationsScalarWhereInput | campaign_translationsScalarWhereInput[]
  }

  export type campaign_usage_logsUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<campaign_usage_logsCreateWithoutCampaignsInput, campaign_usage_logsUncheckedCreateWithoutCampaignsInput> | campaign_usage_logsCreateWithoutCampaignsInput[] | campaign_usage_logsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_usage_logsCreateOrConnectWithoutCampaignsInput | campaign_usage_logsCreateOrConnectWithoutCampaignsInput[]
    upsert?: campaign_usage_logsUpsertWithWhereUniqueWithoutCampaignsInput | campaign_usage_logsUpsertWithWhereUniqueWithoutCampaignsInput[]
    createMany?: campaign_usage_logsCreateManyCampaignsInputEnvelope
    set?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
    disconnect?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
    delete?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
    connect?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
    update?: campaign_usage_logsUpdateWithWhereUniqueWithoutCampaignsInput | campaign_usage_logsUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: campaign_usage_logsUpdateManyWithWhereWithoutCampaignsInput | campaign_usage_logsUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: campaign_usage_logsScalarWhereInput | campaign_usage_logsScalarWhereInput[]
  }

  export type campaign_category_relationsUncheckedUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<campaign_category_relationsCreateWithoutCampaignsInput, campaign_category_relationsUncheckedCreateWithoutCampaignsInput> | campaign_category_relationsCreateWithoutCampaignsInput[] | campaign_category_relationsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_category_relationsCreateOrConnectWithoutCampaignsInput | campaign_category_relationsCreateOrConnectWithoutCampaignsInput[]
    upsert?: campaign_category_relationsUpsertWithWhereUniqueWithoutCampaignsInput | campaign_category_relationsUpsertWithWhereUniqueWithoutCampaignsInput[]
    createMany?: campaign_category_relationsCreateManyCampaignsInputEnvelope
    set?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    disconnect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    delete?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    connect?: campaign_category_relationsWhereUniqueInput | campaign_category_relationsWhereUniqueInput[]
    update?: campaign_category_relationsUpdateWithWhereUniqueWithoutCampaignsInput | campaign_category_relationsUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: campaign_category_relationsUpdateManyWithWhereWithoutCampaignsInput | campaign_category_relationsUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: campaign_category_relationsScalarWhereInput | campaign_category_relationsScalarWhereInput[]
  }

  export type campaign_itemsUncheckedUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<campaign_itemsCreateWithoutCampaignsInput, campaign_itemsUncheckedCreateWithoutCampaignsInput> | campaign_itemsCreateWithoutCampaignsInput[] | campaign_itemsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_itemsCreateOrConnectWithoutCampaignsInput | campaign_itemsCreateOrConnectWithoutCampaignsInput[]
    upsert?: campaign_itemsUpsertWithWhereUniqueWithoutCampaignsInput | campaign_itemsUpsertWithWhereUniqueWithoutCampaignsInput[]
    createMany?: campaign_itemsCreateManyCampaignsInputEnvelope
    set?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
    disconnect?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
    delete?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
    connect?: campaign_itemsWhereUniqueInput | campaign_itemsWhereUniqueInput[]
    update?: campaign_itemsUpdateWithWhereUniqueWithoutCampaignsInput | campaign_itemsUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: campaign_itemsUpdateManyWithWhereWithoutCampaignsInput | campaign_itemsUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: campaign_itemsScalarWhereInput | campaign_itemsScalarWhereInput[]
  }

  export type campaign_translationsUncheckedUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<campaign_translationsCreateWithoutCampaignsInput, campaign_translationsUncheckedCreateWithoutCampaignsInput> | campaign_translationsCreateWithoutCampaignsInput[] | campaign_translationsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_translationsCreateOrConnectWithoutCampaignsInput | campaign_translationsCreateOrConnectWithoutCampaignsInput[]
    upsert?: campaign_translationsUpsertWithWhereUniqueWithoutCampaignsInput | campaign_translationsUpsertWithWhereUniqueWithoutCampaignsInput[]
    createMany?: campaign_translationsCreateManyCampaignsInputEnvelope
    set?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
    disconnect?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
    delete?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
    connect?: campaign_translationsWhereUniqueInput | campaign_translationsWhereUniqueInput[]
    update?: campaign_translationsUpdateWithWhereUniqueWithoutCampaignsInput | campaign_translationsUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: campaign_translationsUpdateManyWithWhereWithoutCampaignsInput | campaign_translationsUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: campaign_translationsScalarWhereInput | campaign_translationsScalarWhereInput[]
  }

  export type campaign_usage_logsUncheckedUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<campaign_usage_logsCreateWithoutCampaignsInput, campaign_usage_logsUncheckedCreateWithoutCampaignsInput> | campaign_usage_logsCreateWithoutCampaignsInput[] | campaign_usage_logsUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: campaign_usage_logsCreateOrConnectWithoutCampaignsInput | campaign_usage_logsCreateOrConnectWithoutCampaignsInput[]
    upsert?: campaign_usage_logsUpsertWithWhereUniqueWithoutCampaignsInput | campaign_usage_logsUpsertWithWhereUniqueWithoutCampaignsInput[]
    createMany?: campaign_usage_logsCreateManyCampaignsInputEnvelope
    set?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
    disconnect?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
    delete?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
    connect?: campaign_usage_logsWhereUniqueInput | campaign_usage_logsWhereUniqueInput[]
    update?: campaign_usage_logsUpdateWithWhereUniqueWithoutCampaignsInput | campaign_usage_logsUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: campaign_usage_logsUpdateManyWithWhereWithoutCampaignsInput | campaign_usage_logsUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: campaign_usage_logsScalarWhereInput | campaign_usage_logsScalarWhereInput[]
  }

  export type customersCreatepms_updatable_fieldsInput = {
    set: string[]
  }

  export type reservationsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<reservationsCreateWithoutCustomersInput, reservationsUncheckedCreateWithoutCustomersInput> | reservationsCreateWithoutCustomersInput[] | reservationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: reservationsCreateOrConnectWithoutCustomersInput | reservationsCreateOrConnectWithoutCustomersInput[]
    createMany?: reservationsCreateManyCustomersInputEnvelope
    connect?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
  }

  export type reservationsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<reservationsCreateWithoutCustomersInput, reservationsUncheckedCreateWithoutCustomersInput> | reservationsCreateWithoutCustomersInput[] | reservationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: reservationsCreateOrConnectWithoutCustomersInput | reservationsCreateOrConnectWithoutCustomersInput[]
    createMany?: reservationsCreateManyCustomersInputEnvelope
    connect?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
  }

  export type customersUpdatepms_updatable_fieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type reservationsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<reservationsCreateWithoutCustomersInput, reservationsUncheckedCreateWithoutCustomersInput> | reservationsCreateWithoutCustomersInput[] | reservationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: reservationsCreateOrConnectWithoutCustomersInput | reservationsCreateOrConnectWithoutCustomersInput[]
    upsert?: reservationsUpsertWithWhereUniqueWithoutCustomersInput | reservationsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: reservationsCreateManyCustomersInputEnvelope
    set?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
    disconnect?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
    delete?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
    connect?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
    update?: reservationsUpdateWithWhereUniqueWithoutCustomersInput | reservationsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: reservationsUpdateManyWithWhereWithoutCustomersInput | reservationsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: reservationsScalarWhereInput | reservationsScalarWhereInput[]
  }

  export type reservationsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<reservationsCreateWithoutCustomersInput, reservationsUncheckedCreateWithoutCustomersInput> | reservationsCreateWithoutCustomersInput[] | reservationsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: reservationsCreateOrConnectWithoutCustomersInput | reservationsCreateOrConnectWithoutCustomersInput[]
    upsert?: reservationsUpsertWithWhereUniqueWithoutCustomersInput | reservationsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: reservationsCreateManyCustomersInputEnvelope
    set?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
    disconnect?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
    delete?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
    connect?: reservationsWhereUniqueInput | reservationsWhereUniqueInput[]
    update?: reservationsUpdateWithWhereUniqueWithoutCustomersInput | reservationsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: reservationsUpdateManyWithWhereWithoutCustomersInput | reservationsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: reservationsScalarWhereInput | reservationsScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutDevice_roomsInput = {
    create?: XOR<TenantCreateWithoutDevice_roomsInput, TenantUncheckedCreateWithoutDevice_roomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDevice_roomsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutDevice_roomsNestedInput = {
    create?: XOR<TenantCreateWithoutDevice_roomsInput, TenantUncheckedCreateWithoutDevice_roomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDevice_roomsInput
    upsert?: TenantUpsertWithoutDevice_roomsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDevice_roomsInput, TenantUpdateWithoutDevice_roomsInput>, TenantUncheckedUpdateWithoutDevice_roomsInput>
  }

  export type device_video_cachesCreatevideoIdsInput = {
    set: string[]
  }

  export type device_video_cachesUpdatevideoIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type notification_templatesCreatevariablesInput = {
    set: string[]
  }

  export type notification_templatesUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type pagesCreateNestedOneWithoutPage_historiesInput = {
    create?: XOR<pagesCreateWithoutPage_historiesInput, pagesUncheckedCreateWithoutPage_historiesInput>
    connectOrCreate?: pagesCreateOrConnectWithoutPage_historiesInput
    connect?: pagesWhereUniqueInput
  }

  export type pagesUpdateOneRequiredWithoutPage_historiesNestedInput = {
    create?: XOR<pagesCreateWithoutPage_historiesInput, pagesUncheckedCreateWithoutPage_historiesInput>
    connectOrCreate?: pagesCreateOrConnectWithoutPage_historiesInput
    upsert?: pagesUpsertWithoutPage_historiesInput
    connect?: pagesWhereUniqueInput
    update?: XOR<XOR<pagesUpdateToOneWithWhereWithoutPage_historiesInput, pagesUpdateWithoutPage_historiesInput>, pagesUncheckedUpdateWithoutPage_historiesInput>
  }

  export type page_historiesCreateNestedManyWithoutPagesInput = {
    create?: XOR<page_historiesCreateWithoutPagesInput, page_historiesUncheckedCreateWithoutPagesInput> | page_historiesCreateWithoutPagesInput[] | page_historiesUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: page_historiesCreateOrConnectWithoutPagesInput | page_historiesCreateOrConnectWithoutPagesInput[]
    createMany?: page_historiesCreateManyPagesInputEnvelope
    connect?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutPagesInput = {
    create?: XOR<TenantCreateWithoutPagesInput, TenantUncheckedCreateWithoutPagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPagesInput
    connect?: TenantWhereUniqueInput
  }

  export type page_historiesUncheckedCreateNestedManyWithoutPagesInput = {
    create?: XOR<page_historiesCreateWithoutPagesInput, page_historiesUncheckedCreateWithoutPagesInput> | page_historiesCreateWithoutPagesInput[] | page_historiesUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: page_historiesCreateOrConnectWithoutPagesInput | page_historiesCreateOrConnectWithoutPagesInput[]
    createMany?: page_historiesCreateManyPagesInputEnvelope
    connect?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
  }

  export type page_historiesUpdateManyWithoutPagesNestedInput = {
    create?: XOR<page_historiesCreateWithoutPagesInput, page_historiesUncheckedCreateWithoutPagesInput> | page_historiesCreateWithoutPagesInput[] | page_historiesUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: page_historiesCreateOrConnectWithoutPagesInput | page_historiesCreateOrConnectWithoutPagesInput[]
    upsert?: page_historiesUpsertWithWhereUniqueWithoutPagesInput | page_historiesUpsertWithWhereUniqueWithoutPagesInput[]
    createMany?: page_historiesCreateManyPagesInputEnvelope
    set?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
    disconnect?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
    delete?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
    connect?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
    update?: page_historiesUpdateWithWhereUniqueWithoutPagesInput | page_historiesUpdateWithWhereUniqueWithoutPagesInput[]
    updateMany?: page_historiesUpdateManyWithWhereWithoutPagesInput | page_historiesUpdateManyWithWhereWithoutPagesInput[]
    deleteMany?: page_historiesScalarWhereInput | page_historiesScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<TenantCreateWithoutPagesInput, TenantUncheckedCreateWithoutPagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPagesInput
    upsert?: TenantUpsertWithoutPagesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPagesInput, TenantUpdateWithoutPagesInput>, TenantUncheckedUpdateWithoutPagesInput>
  }

  export type page_historiesUncheckedUpdateManyWithoutPagesNestedInput = {
    create?: XOR<page_historiesCreateWithoutPagesInput, page_historiesUncheckedCreateWithoutPagesInput> | page_historiesCreateWithoutPagesInput[] | page_historiesUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: page_historiesCreateOrConnectWithoutPagesInput | page_historiesCreateOrConnectWithoutPagesInput[]
    upsert?: page_historiesUpsertWithWhereUniqueWithoutPagesInput | page_historiesUpsertWithWhereUniqueWithoutPagesInput[]
    createMany?: page_historiesCreateManyPagesInputEnvelope
    set?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
    disconnect?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
    delete?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
    connect?: page_historiesWhereUniqueInput | page_historiesWhereUniqueInput[]
    update?: page_historiesUpdateWithWhereUniqueWithoutPagesInput | page_historiesUpdateWithWhereUniqueWithoutPagesInput[]
    updateMany?: page_historiesUpdateManyWithWhereWithoutPagesInput | page_historiesUpdateManyWithWhereWithoutPagesInput[]
    deleteMany?: page_historiesScalarWhereInput | page_historiesScalarWhereInput[]
  }

  export type customersCreateNestedOneWithoutReservationsInput = {
    create?: XOR<customersCreateWithoutReservationsInput, customersUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: customersCreateOrConnectWithoutReservationsInput
    connect?: customersWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type customersUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<customersCreateWithoutReservationsInput, customersUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: customersCreateOrConnectWithoutReservationsInput
    upsert?: customersUpsertWithoutReservationsInput
    disconnect?: customersWhereInput | boolean
    delete?: customersWhereInput | boolean
    connect?: customersWhereUniqueInput
    update?: XOR<XOR<customersUpdateToOneWithWhereWithoutReservationsInput, customersUpdateWithoutReservationsInput>, customersUncheckedUpdateWithoutReservationsInput>
  }

  export type response_nodesCreateNestedOneWithoutResponse_node_translationsInput = {
    create?: XOR<response_nodesCreateWithoutResponse_node_translationsInput, response_nodesUncheckedCreateWithoutResponse_node_translationsInput>
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_node_translationsInput
    connect?: response_nodesWhereUniqueInput
  }

  export type response_nodesUpdateOneRequiredWithoutResponse_node_translationsNestedInput = {
    create?: XOR<response_nodesCreateWithoutResponse_node_translationsInput, response_nodesUncheckedCreateWithoutResponse_node_translationsInput>
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_node_translationsInput
    upsert?: response_nodesUpsertWithoutResponse_node_translationsInput
    connect?: response_nodesWhereUniqueInput
    update?: XOR<XOR<response_nodesUpdateToOneWithWhereWithoutResponse_node_translationsInput, response_nodesUpdateWithoutResponse_node_translationsInput>, response_nodesUncheckedUpdateWithoutResponse_node_translationsInput>
  }

  export type response_node_translationsCreateNestedManyWithoutResponse_nodesInput = {
    create?: XOR<response_node_translationsCreateWithoutResponse_nodesInput, response_node_translationsUncheckedCreateWithoutResponse_nodesInput> | response_node_translationsCreateWithoutResponse_nodesInput[] | response_node_translationsUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_node_translationsCreateOrConnectWithoutResponse_nodesInput | response_node_translationsCreateOrConnectWithoutResponse_nodesInput[]
    createMany?: response_node_translationsCreateManyResponse_nodesInputEnvelope
    connect?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
  }

  export type response_nodesCreateNestedOneWithoutOther_response_nodesInput = {
    create?: XOR<response_nodesCreateWithoutOther_response_nodesInput, response_nodesUncheckedCreateWithoutOther_response_nodesInput>
    connectOrCreate?: response_nodesCreateOrConnectWithoutOther_response_nodesInput
    connect?: response_nodesWhereUniqueInput
  }

  export type response_nodesCreateNestedManyWithoutResponse_nodesInput = {
    create?: XOR<response_nodesCreateWithoutResponse_nodesInput, response_nodesUncheckedCreateWithoutResponse_nodesInput> | response_nodesCreateWithoutResponse_nodesInput[] | response_nodesUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_nodesInput | response_nodesCreateOrConnectWithoutResponse_nodesInput[]
    createMany?: response_nodesCreateManyResponse_nodesInputEnvelope
    connect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
  }

  export type response_treesCreateNestedOneWithoutResponse_nodesInput = {
    create?: XOR<response_treesCreateWithoutResponse_nodesInput, response_treesUncheckedCreateWithoutResponse_nodesInput>
    connectOrCreate?: response_treesCreateOrConnectWithoutResponse_nodesInput
    connect?: response_treesWhereUniqueInput
  }

  export type response_tree_historyCreateNestedManyWithoutResponse_nodesInput = {
    create?: XOR<response_tree_historyCreateWithoutResponse_nodesInput, response_tree_historyUncheckedCreateWithoutResponse_nodesInput> | response_tree_historyCreateWithoutResponse_nodesInput[] | response_tree_historyUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_tree_historyCreateOrConnectWithoutResponse_nodesInput | response_tree_historyCreateOrConnectWithoutResponse_nodesInput[]
    createMany?: response_tree_historyCreateManyResponse_nodesInputEnvelope
    connect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
  }

  export type response_tree_sessionsCreateNestedManyWithoutResponse_nodesInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_nodesInput, response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput> | response_tree_sessionsCreateWithoutResponse_nodesInput[] | response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_nodesInput | response_tree_sessionsCreateOrConnectWithoutResponse_nodesInput[]
    createMany?: response_tree_sessionsCreateManyResponse_nodesInputEnvelope
    connect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
  }

  export type response_node_translationsUncheckedCreateNestedManyWithoutResponse_nodesInput = {
    create?: XOR<response_node_translationsCreateWithoutResponse_nodesInput, response_node_translationsUncheckedCreateWithoutResponse_nodesInput> | response_node_translationsCreateWithoutResponse_nodesInput[] | response_node_translationsUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_node_translationsCreateOrConnectWithoutResponse_nodesInput | response_node_translationsCreateOrConnectWithoutResponse_nodesInput[]
    createMany?: response_node_translationsCreateManyResponse_nodesInputEnvelope
    connect?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
  }

  export type response_nodesUncheckedCreateNestedManyWithoutResponse_nodesInput = {
    create?: XOR<response_nodesCreateWithoutResponse_nodesInput, response_nodesUncheckedCreateWithoutResponse_nodesInput> | response_nodesCreateWithoutResponse_nodesInput[] | response_nodesUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_nodesInput | response_nodesCreateOrConnectWithoutResponse_nodesInput[]
    createMany?: response_nodesCreateManyResponse_nodesInputEnvelope
    connect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
  }

  export type response_tree_historyUncheckedCreateNestedManyWithoutResponse_nodesInput = {
    create?: XOR<response_tree_historyCreateWithoutResponse_nodesInput, response_tree_historyUncheckedCreateWithoutResponse_nodesInput> | response_tree_historyCreateWithoutResponse_nodesInput[] | response_tree_historyUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_tree_historyCreateOrConnectWithoutResponse_nodesInput | response_tree_historyCreateOrConnectWithoutResponse_nodesInput[]
    createMany?: response_tree_historyCreateManyResponse_nodesInputEnvelope
    connect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
  }

  export type response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_nodesInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_nodesInput, response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput> | response_tree_sessionsCreateWithoutResponse_nodesInput[] | response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_nodesInput | response_tree_sessionsCreateOrConnectWithoutResponse_nodesInput[]
    createMany?: response_tree_sessionsCreateManyResponse_nodesInputEnvelope
    connect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
  }

  export type response_node_translationsUpdateManyWithoutResponse_nodesNestedInput = {
    create?: XOR<response_node_translationsCreateWithoutResponse_nodesInput, response_node_translationsUncheckedCreateWithoutResponse_nodesInput> | response_node_translationsCreateWithoutResponse_nodesInput[] | response_node_translationsUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_node_translationsCreateOrConnectWithoutResponse_nodesInput | response_node_translationsCreateOrConnectWithoutResponse_nodesInput[]
    upsert?: response_node_translationsUpsertWithWhereUniqueWithoutResponse_nodesInput | response_node_translationsUpsertWithWhereUniqueWithoutResponse_nodesInput[]
    createMany?: response_node_translationsCreateManyResponse_nodesInputEnvelope
    set?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
    disconnect?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
    delete?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
    connect?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
    update?: response_node_translationsUpdateWithWhereUniqueWithoutResponse_nodesInput | response_node_translationsUpdateWithWhereUniqueWithoutResponse_nodesInput[]
    updateMany?: response_node_translationsUpdateManyWithWhereWithoutResponse_nodesInput | response_node_translationsUpdateManyWithWhereWithoutResponse_nodesInput[]
    deleteMany?: response_node_translationsScalarWhereInput | response_node_translationsScalarWhereInput[]
  }

  export type response_nodesUpdateOneWithoutOther_response_nodesNestedInput = {
    create?: XOR<response_nodesCreateWithoutOther_response_nodesInput, response_nodesUncheckedCreateWithoutOther_response_nodesInput>
    connectOrCreate?: response_nodesCreateOrConnectWithoutOther_response_nodesInput
    upsert?: response_nodesUpsertWithoutOther_response_nodesInput
    disconnect?: response_nodesWhereInput | boolean
    delete?: response_nodesWhereInput | boolean
    connect?: response_nodesWhereUniqueInput
    update?: XOR<XOR<response_nodesUpdateToOneWithWhereWithoutOther_response_nodesInput, response_nodesUpdateWithoutOther_response_nodesInput>, response_nodesUncheckedUpdateWithoutOther_response_nodesInput>
  }

  export type response_nodesUpdateManyWithoutResponse_nodesNestedInput = {
    create?: XOR<response_nodesCreateWithoutResponse_nodesInput, response_nodesUncheckedCreateWithoutResponse_nodesInput> | response_nodesCreateWithoutResponse_nodesInput[] | response_nodesUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_nodesInput | response_nodesCreateOrConnectWithoutResponse_nodesInput[]
    upsert?: response_nodesUpsertWithWhereUniqueWithoutResponse_nodesInput | response_nodesUpsertWithWhereUniqueWithoutResponse_nodesInput[]
    createMany?: response_nodesCreateManyResponse_nodesInputEnvelope
    set?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    disconnect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    delete?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    connect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    update?: response_nodesUpdateWithWhereUniqueWithoutResponse_nodesInput | response_nodesUpdateWithWhereUniqueWithoutResponse_nodesInput[]
    updateMany?: response_nodesUpdateManyWithWhereWithoutResponse_nodesInput | response_nodesUpdateManyWithWhereWithoutResponse_nodesInput[]
    deleteMany?: response_nodesScalarWhereInput | response_nodesScalarWhereInput[]
  }

  export type response_treesUpdateOneRequiredWithoutResponse_nodesNestedInput = {
    create?: XOR<response_treesCreateWithoutResponse_nodesInput, response_treesUncheckedCreateWithoutResponse_nodesInput>
    connectOrCreate?: response_treesCreateOrConnectWithoutResponse_nodesInput
    upsert?: response_treesUpsertWithoutResponse_nodesInput
    connect?: response_treesWhereUniqueInput
    update?: XOR<XOR<response_treesUpdateToOneWithWhereWithoutResponse_nodesInput, response_treesUpdateWithoutResponse_nodesInput>, response_treesUncheckedUpdateWithoutResponse_nodesInput>
  }

  export type response_tree_historyUpdateManyWithoutResponse_nodesNestedInput = {
    create?: XOR<response_tree_historyCreateWithoutResponse_nodesInput, response_tree_historyUncheckedCreateWithoutResponse_nodesInput> | response_tree_historyCreateWithoutResponse_nodesInput[] | response_tree_historyUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_tree_historyCreateOrConnectWithoutResponse_nodesInput | response_tree_historyCreateOrConnectWithoutResponse_nodesInput[]
    upsert?: response_tree_historyUpsertWithWhereUniqueWithoutResponse_nodesInput | response_tree_historyUpsertWithWhereUniqueWithoutResponse_nodesInput[]
    createMany?: response_tree_historyCreateManyResponse_nodesInputEnvelope
    set?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    disconnect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    delete?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    connect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    update?: response_tree_historyUpdateWithWhereUniqueWithoutResponse_nodesInput | response_tree_historyUpdateWithWhereUniqueWithoutResponse_nodesInput[]
    updateMany?: response_tree_historyUpdateManyWithWhereWithoutResponse_nodesInput | response_tree_historyUpdateManyWithWhereWithoutResponse_nodesInput[]
    deleteMany?: response_tree_historyScalarWhereInput | response_tree_historyScalarWhereInput[]
  }

  export type response_tree_sessionsUpdateManyWithoutResponse_nodesNestedInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_nodesInput, response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput> | response_tree_sessionsCreateWithoutResponse_nodesInput[] | response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_nodesInput | response_tree_sessionsCreateOrConnectWithoutResponse_nodesInput[]
    upsert?: response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_nodesInput | response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_nodesInput[]
    createMany?: response_tree_sessionsCreateManyResponse_nodesInputEnvelope
    set?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    disconnect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    delete?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    connect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    update?: response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_nodesInput | response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_nodesInput[]
    updateMany?: response_tree_sessionsUpdateManyWithWhereWithoutResponse_nodesInput | response_tree_sessionsUpdateManyWithWhereWithoutResponse_nodesInput[]
    deleteMany?: response_tree_sessionsScalarWhereInput | response_tree_sessionsScalarWhereInput[]
  }

  export type response_node_translationsUncheckedUpdateManyWithoutResponse_nodesNestedInput = {
    create?: XOR<response_node_translationsCreateWithoutResponse_nodesInput, response_node_translationsUncheckedCreateWithoutResponse_nodesInput> | response_node_translationsCreateWithoutResponse_nodesInput[] | response_node_translationsUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_node_translationsCreateOrConnectWithoutResponse_nodesInput | response_node_translationsCreateOrConnectWithoutResponse_nodesInput[]
    upsert?: response_node_translationsUpsertWithWhereUniqueWithoutResponse_nodesInput | response_node_translationsUpsertWithWhereUniqueWithoutResponse_nodesInput[]
    createMany?: response_node_translationsCreateManyResponse_nodesInputEnvelope
    set?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
    disconnect?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
    delete?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
    connect?: response_node_translationsWhereUniqueInput | response_node_translationsWhereUniqueInput[]
    update?: response_node_translationsUpdateWithWhereUniqueWithoutResponse_nodesInput | response_node_translationsUpdateWithWhereUniqueWithoutResponse_nodesInput[]
    updateMany?: response_node_translationsUpdateManyWithWhereWithoutResponse_nodesInput | response_node_translationsUpdateManyWithWhereWithoutResponse_nodesInput[]
    deleteMany?: response_node_translationsScalarWhereInput | response_node_translationsScalarWhereInput[]
  }

  export type response_nodesUncheckedUpdateManyWithoutResponse_nodesNestedInput = {
    create?: XOR<response_nodesCreateWithoutResponse_nodesInput, response_nodesUncheckedCreateWithoutResponse_nodesInput> | response_nodesCreateWithoutResponse_nodesInput[] | response_nodesUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_nodesInput | response_nodesCreateOrConnectWithoutResponse_nodesInput[]
    upsert?: response_nodesUpsertWithWhereUniqueWithoutResponse_nodesInput | response_nodesUpsertWithWhereUniqueWithoutResponse_nodesInput[]
    createMany?: response_nodesCreateManyResponse_nodesInputEnvelope
    set?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    disconnect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    delete?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    connect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    update?: response_nodesUpdateWithWhereUniqueWithoutResponse_nodesInput | response_nodesUpdateWithWhereUniqueWithoutResponse_nodesInput[]
    updateMany?: response_nodesUpdateManyWithWhereWithoutResponse_nodesInput | response_nodesUpdateManyWithWhereWithoutResponse_nodesInput[]
    deleteMany?: response_nodesScalarWhereInput | response_nodesScalarWhereInput[]
  }

  export type response_tree_historyUncheckedUpdateManyWithoutResponse_nodesNestedInput = {
    create?: XOR<response_tree_historyCreateWithoutResponse_nodesInput, response_tree_historyUncheckedCreateWithoutResponse_nodesInput> | response_tree_historyCreateWithoutResponse_nodesInput[] | response_tree_historyUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_tree_historyCreateOrConnectWithoutResponse_nodesInput | response_tree_historyCreateOrConnectWithoutResponse_nodesInput[]
    upsert?: response_tree_historyUpsertWithWhereUniqueWithoutResponse_nodesInput | response_tree_historyUpsertWithWhereUniqueWithoutResponse_nodesInput[]
    createMany?: response_tree_historyCreateManyResponse_nodesInputEnvelope
    set?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    disconnect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    delete?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    connect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    update?: response_tree_historyUpdateWithWhereUniqueWithoutResponse_nodesInput | response_tree_historyUpdateWithWhereUniqueWithoutResponse_nodesInput[]
    updateMany?: response_tree_historyUpdateManyWithWhereWithoutResponse_nodesInput | response_tree_historyUpdateManyWithWhereWithoutResponse_nodesInput[]
    deleteMany?: response_tree_historyScalarWhereInput | response_tree_historyScalarWhereInput[]
  }

  export type response_tree_sessionsUncheckedUpdateManyWithoutResponse_nodesNestedInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_nodesInput, response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput> | response_tree_sessionsCreateWithoutResponse_nodesInput[] | response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput[]
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_nodesInput | response_tree_sessionsCreateOrConnectWithoutResponse_nodesInput[]
    upsert?: response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_nodesInput | response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_nodesInput[]
    createMany?: response_tree_sessionsCreateManyResponse_nodesInputEnvelope
    set?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    disconnect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    delete?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    connect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    update?: response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_nodesInput | response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_nodesInput[]
    updateMany?: response_tree_sessionsUpdateManyWithWhereWithoutResponse_nodesInput | response_tree_sessionsUpdateManyWithWhereWithoutResponse_nodesInput[]
    deleteMany?: response_tree_sessionsScalarWhereInput | response_tree_sessionsScalarWhereInput[]
  }

  export type response_nodesCreateNestedOneWithoutResponse_tree_historyInput = {
    create?: XOR<response_nodesCreateWithoutResponse_tree_historyInput, response_nodesUncheckedCreateWithoutResponse_tree_historyInput>
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_tree_historyInput
    connect?: response_nodesWhereUniqueInput
  }

  export type response_tree_sessionsCreateNestedOneWithoutResponse_tree_historyInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_tree_historyInput, response_tree_sessionsUncheckedCreateWithoutResponse_tree_historyInput>
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_tree_historyInput
    connect?: response_tree_sessionsWhereUniqueInput
  }

  export type response_nodesUpdateOneRequiredWithoutResponse_tree_historyNestedInput = {
    create?: XOR<response_nodesCreateWithoutResponse_tree_historyInput, response_nodesUncheckedCreateWithoutResponse_tree_historyInput>
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_tree_historyInput
    upsert?: response_nodesUpsertWithoutResponse_tree_historyInput
    connect?: response_nodesWhereUniqueInput
    update?: XOR<XOR<response_nodesUpdateToOneWithWhereWithoutResponse_tree_historyInput, response_nodesUpdateWithoutResponse_tree_historyInput>, response_nodesUncheckedUpdateWithoutResponse_tree_historyInput>
  }

  export type response_tree_sessionsUpdateOneRequiredWithoutResponse_tree_historyNestedInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_tree_historyInput, response_tree_sessionsUncheckedCreateWithoutResponse_tree_historyInput>
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_tree_historyInput
    upsert?: response_tree_sessionsUpsertWithoutResponse_tree_historyInput
    connect?: response_tree_sessionsWhereUniqueInput
    update?: XOR<XOR<response_tree_sessionsUpdateToOneWithWhereWithoutResponse_tree_historyInput, response_tree_sessionsUpdateWithoutResponse_tree_historyInput>, response_tree_sessionsUncheckedUpdateWithoutResponse_tree_historyInput>
  }

  export type response_tree_sessionsCreateNestedOneWithoutResponse_tree_mobile_linksInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_tree_mobile_linksInput, response_tree_sessionsUncheckedCreateWithoutResponse_tree_mobile_linksInput>
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_tree_mobile_linksInput
    connect?: response_tree_sessionsWhereUniqueInput
  }

  export type response_tree_sessionsUpdateOneRequiredWithoutResponse_tree_mobile_linksNestedInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_tree_mobile_linksInput, response_tree_sessionsUncheckedCreateWithoutResponse_tree_mobile_linksInput>
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_tree_mobile_linksInput
    upsert?: response_tree_sessionsUpsertWithoutResponse_tree_mobile_linksInput
    connect?: response_tree_sessionsWhereUniqueInput
    update?: XOR<XOR<response_tree_sessionsUpdateToOneWithWhereWithoutResponse_tree_mobile_linksInput, response_tree_sessionsUpdateWithoutResponse_tree_mobile_linksInput>, response_tree_sessionsUncheckedUpdateWithoutResponse_tree_mobile_linksInput>
  }

  export type response_tree_historyCreateNestedManyWithoutResponse_tree_sessionsInput = {
    create?: XOR<response_tree_historyCreateWithoutResponse_tree_sessionsInput, response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput> | response_tree_historyCreateWithoutResponse_tree_sessionsInput[] | response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput[]
    connectOrCreate?: response_tree_historyCreateOrConnectWithoutResponse_tree_sessionsInput | response_tree_historyCreateOrConnectWithoutResponse_tree_sessionsInput[]
    createMany?: response_tree_historyCreateManyResponse_tree_sessionsInputEnvelope
    connect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
  }

  export type response_tree_mobile_linksCreateNestedManyWithoutResponse_tree_sessionsInput = {
    create?: XOR<response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput, response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput> | response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput[] | response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput[]
    connectOrCreate?: response_tree_mobile_linksCreateOrConnectWithoutResponse_tree_sessionsInput | response_tree_mobile_linksCreateOrConnectWithoutResponse_tree_sessionsInput[]
    createMany?: response_tree_mobile_linksCreateManyResponse_tree_sessionsInputEnvelope
    connect?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
  }

  export type response_nodesCreateNestedOneWithoutResponse_tree_sessionsInput = {
    create?: XOR<response_nodesCreateWithoutResponse_tree_sessionsInput, response_nodesUncheckedCreateWithoutResponse_tree_sessionsInput>
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_tree_sessionsInput
    connect?: response_nodesWhereUniqueInput
  }

  export type response_treesCreateNestedOneWithoutResponse_tree_sessionsInput = {
    create?: XOR<response_treesCreateWithoutResponse_tree_sessionsInput, response_treesUncheckedCreateWithoutResponse_tree_sessionsInput>
    connectOrCreate?: response_treesCreateOrConnectWithoutResponse_tree_sessionsInput
    connect?: response_treesWhereUniqueInput
  }

  export type response_tree_historyUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput = {
    create?: XOR<response_tree_historyCreateWithoutResponse_tree_sessionsInput, response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput> | response_tree_historyCreateWithoutResponse_tree_sessionsInput[] | response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput[]
    connectOrCreate?: response_tree_historyCreateOrConnectWithoutResponse_tree_sessionsInput | response_tree_historyCreateOrConnectWithoutResponse_tree_sessionsInput[]
    createMany?: response_tree_historyCreateManyResponse_tree_sessionsInputEnvelope
    connect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
  }

  export type response_tree_mobile_linksUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput = {
    create?: XOR<response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput, response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput> | response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput[] | response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput[]
    connectOrCreate?: response_tree_mobile_linksCreateOrConnectWithoutResponse_tree_sessionsInput | response_tree_mobile_linksCreateOrConnectWithoutResponse_tree_sessionsInput[]
    createMany?: response_tree_mobile_linksCreateManyResponse_tree_sessionsInputEnvelope
    connect?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
  }

  export type response_tree_historyUpdateManyWithoutResponse_tree_sessionsNestedInput = {
    create?: XOR<response_tree_historyCreateWithoutResponse_tree_sessionsInput, response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput> | response_tree_historyCreateWithoutResponse_tree_sessionsInput[] | response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput[]
    connectOrCreate?: response_tree_historyCreateOrConnectWithoutResponse_tree_sessionsInput | response_tree_historyCreateOrConnectWithoutResponse_tree_sessionsInput[]
    upsert?: response_tree_historyUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput | response_tree_historyUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput[]
    createMany?: response_tree_historyCreateManyResponse_tree_sessionsInputEnvelope
    set?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    disconnect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    delete?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    connect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    update?: response_tree_historyUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput | response_tree_historyUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput[]
    updateMany?: response_tree_historyUpdateManyWithWhereWithoutResponse_tree_sessionsInput | response_tree_historyUpdateManyWithWhereWithoutResponse_tree_sessionsInput[]
    deleteMany?: response_tree_historyScalarWhereInput | response_tree_historyScalarWhereInput[]
  }

  export type response_tree_mobile_linksUpdateManyWithoutResponse_tree_sessionsNestedInput = {
    create?: XOR<response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput, response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput> | response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput[] | response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput[]
    connectOrCreate?: response_tree_mobile_linksCreateOrConnectWithoutResponse_tree_sessionsInput | response_tree_mobile_linksCreateOrConnectWithoutResponse_tree_sessionsInput[]
    upsert?: response_tree_mobile_linksUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput | response_tree_mobile_linksUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput[]
    createMany?: response_tree_mobile_linksCreateManyResponse_tree_sessionsInputEnvelope
    set?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
    disconnect?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
    delete?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
    connect?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
    update?: response_tree_mobile_linksUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput | response_tree_mobile_linksUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput[]
    updateMany?: response_tree_mobile_linksUpdateManyWithWhereWithoutResponse_tree_sessionsInput | response_tree_mobile_linksUpdateManyWithWhereWithoutResponse_tree_sessionsInput[]
    deleteMany?: response_tree_mobile_linksScalarWhereInput | response_tree_mobile_linksScalarWhereInput[]
  }

  export type response_nodesUpdateOneWithoutResponse_tree_sessionsNestedInput = {
    create?: XOR<response_nodesCreateWithoutResponse_tree_sessionsInput, response_nodesUncheckedCreateWithoutResponse_tree_sessionsInput>
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_tree_sessionsInput
    upsert?: response_nodesUpsertWithoutResponse_tree_sessionsInput
    disconnect?: response_nodesWhereInput | boolean
    delete?: response_nodesWhereInput | boolean
    connect?: response_nodesWhereUniqueInput
    update?: XOR<XOR<response_nodesUpdateToOneWithWhereWithoutResponse_tree_sessionsInput, response_nodesUpdateWithoutResponse_tree_sessionsInput>, response_nodesUncheckedUpdateWithoutResponse_tree_sessionsInput>
  }

  export type response_treesUpdateOneRequiredWithoutResponse_tree_sessionsNestedInput = {
    create?: XOR<response_treesCreateWithoutResponse_tree_sessionsInput, response_treesUncheckedCreateWithoutResponse_tree_sessionsInput>
    connectOrCreate?: response_treesCreateOrConnectWithoutResponse_tree_sessionsInput
    upsert?: response_treesUpsertWithoutResponse_tree_sessionsInput
    connect?: response_treesWhereUniqueInput
    update?: XOR<XOR<response_treesUpdateToOneWithWhereWithoutResponse_tree_sessionsInput, response_treesUpdateWithoutResponse_tree_sessionsInput>, response_treesUncheckedUpdateWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_historyUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput = {
    create?: XOR<response_tree_historyCreateWithoutResponse_tree_sessionsInput, response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput> | response_tree_historyCreateWithoutResponse_tree_sessionsInput[] | response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput[]
    connectOrCreate?: response_tree_historyCreateOrConnectWithoutResponse_tree_sessionsInput | response_tree_historyCreateOrConnectWithoutResponse_tree_sessionsInput[]
    upsert?: response_tree_historyUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput | response_tree_historyUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput[]
    createMany?: response_tree_historyCreateManyResponse_tree_sessionsInputEnvelope
    set?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    disconnect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    delete?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    connect?: response_tree_historyWhereUniqueInput | response_tree_historyWhereUniqueInput[]
    update?: response_tree_historyUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput | response_tree_historyUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput[]
    updateMany?: response_tree_historyUpdateManyWithWhereWithoutResponse_tree_sessionsInput | response_tree_historyUpdateManyWithWhereWithoutResponse_tree_sessionsInput[]
    deleteMany?: response_tree_historyScalarWhereInput | response_tree_historyScalarWhereInput[]
  }

  export type response_tree_mobile_linksUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput = {
    create?: XOR<response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput, response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput> | response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput[] | response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput[]
    connectOrCreate?: response_tree_mobile_linksCreateOrConnectWithoutResponse_tree_sessionsInput | response_tree_mobile_linksCreateOrConnectWithoutResponse_tree_sessionsInput[]
    upsert?: response_tree_mobile_linksUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput | response_tree_mobile_linksUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput[]
    createMany?: response_tree_mobile_linksCreateManyResponse_tree_sessionsInputEnvelope
    set?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
    disconnect?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
    delete?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
    connect?: response_tree_mobile_linksWhereUniqueInput | response_tree_mobile_linksWhereUniqueInput[]
    update?: response_tree_mobile_linksUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput | response_tree_mobile_linksUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput[]
    updateMany?: response_tree_mobile_linksUpdateManyWithWhereWithoutResponse_tree_sessionsInput | response_tree_mobile_linksUpdateManyWithWhereWithoutResponse_tree_sessionsInput[]
    deleteMany?: response_tree_mobile_linksScalarWhereInput | response_tree_mobile_linksScalarWhereInput[]
  }

  export type response_treesCreateNestedOneWithoutResponse_tree_versionsInput = {
    create?: XOR<response_treesCreateWithoutResponse_tree_versionsInput, response_treesUncheckedCreateWithoutResponse_tree_versionsInput>
    connectOrCreate?: response_treesCreateOrConnectWithoutResponse_tree_versionsInput
    connect?: response_treesWhereUniqueInput
  }

  export type response_treesUpdateOneRequiredWithoutResponse_tree_versionsNestedInput = {
    create?: XOR<response_treesCreateWithoutResponse_tree_versionsInput, response_treesUncheckedCreateWithoutResponse_tree_versionsInput>
    connectOrCreate?: response_treesCreateOrConnectWithoutResponse_tree_versionsInput
    upsert?: response_treesUpsertWithoutResponse_tree_versionsInput
    connect?: response_treesWhereUniqueInput
    update?: XOR<XOR<response_treesUpdateToOneWithWhereWithoutResponse_tree_versionsInput, response_treesUpdateWithoutResponse_tree_versionsInput>, response_treesUncheckedUpdateWithoutResponse_tree_versionsInput>
  }

  export type response_nodesCreateNestedManyWithoutResponse_treesInput = {
    create?: XOR<response_nodesCreateWithoutResponse_treesInput, response_nodesUncheckedCreateWithoutResponse_treesInput> | response_nodesCreateWithoutResponse_treesInput[] | response_nodesUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_treesInput | response_nodesCreateOrConnectWithoutResponse_treesInput[]
    createMany?: response_nodesCreateManyResponse_treesInputEnvelope
    connect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
  }

  export type response_tree_sessionsCreateNestedManyWithoutResponse_treesInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_treesInput, response_tree_sessionsUncheckedCreateWithoutResponse_treesInput> | response_tree_sessionsCreateWithoutResponse_treesInput[] | response_tree_sessionsUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_treesInput | response_tree_sessionsCreateOrConnectWithoutResponse_treesInput[]
    createMany?: response_tree_sessionsCreateManyResponse_treesInputEnvelope
    connect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
  }

  export type response_tree_versionsCreateNestedManyWithoutResponse_treesInput = {
    create?: XOR<response_tree_versionsCreateWithoutResponse_treesInput, response_tree_versionsUncheckedCreateWithoutResponse_treesInput> | response_tree_versionsCreateWithoutResponse_treesInput[] | response_tree_versionsUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_tree_versionsCreateOrConnectWithoutResponse_treesInput | response_tree_versionsCreateOrConnectWithoutResponse_treesInput[]
    createMany?: response_tree_versionsCreateManyResponse_treesInputEnvelope
    connect?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
  }

  export type response_nodesUncheckedCreateNestedManyWithoutResponse_treesInput = {
    create?: XOR<response_nodesCreateWithoutResponse_treesInput, response_nodesUncheckedCreateWithoutResponse_treesInput> | response_nodesCreateWithoutResponse_treesInput[] | response_nodesUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_treesInput | response_nodesCreateOrConnectWithoutResponse_treesInput[]
    createMany?: response_nodesCreateManyResponse_treesInputEnvelope
    connect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
  }

  export type response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_treesInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_treesInput, response_tree_sessionsUncheckedCreateWithoutResponse_treesInput> | response_tree_sessionsCreateWithoutResponse_treesInput[] | response_tree_sessionsUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_treesInput | response_tree_sessionsCreateOrConnectWithoutResponse_treesInput[]
    createMany?: response_tree_sessionsCreateManyResponse_treesInputEnvelope
    connect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
  }

  export type response_tree_versionsUncheckedCreateNestedManyWithoutResponse_treesInput = {
    create?: XOR<response_tree_versionsCreateWithoutResponse_treesInput, response_tree_versionsUncheckedCreateWithoutResponse_treesInput> | response_tree_versionsCreateWithoutResponse_treesInput[] | response_tree_versionsUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_tree_versionsCreateOrConnectWithoutResponse_treesInput | response_tree_versionsCreateOrConnectWithoutResponse_treesInput[]
    createMany?: response_tree_versionsCreateManyResponse_treesInputEnvelope
    connect?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
  }

  export type response_nodesUpdateManyWithoutResponse_treesNestedInput = {
    create?: XOR<response_nodesCreateWithoutResponse_treesInput, response_nodesUncheckedCreateWithoutResponse_treesInput> | response_nodesCreateWithoutResponse_treesInput[] | response_nodesUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_treesInput | response_nodesCreateOrConnectWithoutResponse_treesInput[]
    upsert?: response_nodesUpsertWithWhereUniqueWithoutResponse_treesInput | response_nodesUpsertWithWhereUniqueWithoutResponse_treesInput[]
    createMany?: response_nodesCreateManyResponse_treesInputEnvelope
    set?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    disconnect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    delete?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    connect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    update?: response_nodesUpdateWithWhereUniqueWithoutResponse_treesInput | response_nodesUpdateWithWhereUniqueWithoutResponse_treesInput[]
    updateMany?: response_nodesUpdateManyWithWhereWithoutResponse_treesInput | response_nodesUpdateManyWithWhereWithoutResponse_treesInput[]
    deleteMany?: response_nodesScalarWhereInput | response_nodesScalarWhereInput[]
  }

  export type response_tree_sessionsUpdateManyWithoutResponse_treesNestedInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_treesInput, response_tree_sessionsUncheckedCreateWithoutResponse_treesInput> | response_tree_sessionsCreateWithoutResponse_treesInput[] | response_tree_sessionsUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_treesInput | response_tree_sessionsCreateOrConnectWithoutResponse_treesInput[]
    upsert?: response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_treesInput | response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_treesInput[]
    createMany?: response_tree_sessionsCreateManyResponse_treesInputEnvelope
    set?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    disconnect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    delete?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    connect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    update?: response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_treesInput | response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_treesInput[]
    updateMany?: response_tree_sessionsUpdateManyWithWhereWithoutResponse_treesInput | response_tree_sessionsUpdateManyWithWhereWithoutResponse_treesInput[]
    deleteMany?: response_tree_sessionsScalarWhereInput | response_tree_sessionsScalarWhereInput[]
  }

  export type response_tree_versionsUpdateManyWithoutResponse_treesNestedInput = {
    create?: XOR<response_tree_versionsCreateWithoutResponse_treesInput, response_tree_versionsUncheckedCreateWithoutResponse_treesInput> | response_tree_versionsCreateWithoutResponse_treesInput[] | response_tree_versionsUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_tree_versionsCreateOrConnectWithoutResponse_treesInput | response_tree_versionsCreateOrConnectWithoutResponse_treesInput[]
    upsert?: response_tree_versionsUpsertWithWhereUniqueWithoutResponse_treesInput | response_tree_versionsUpsertWithWhereUniqueWithoutResponse_treesInput[]
    createMany?: response_tree_versionsCreateManyResponse_treesInputEnvelope
    set?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
    disconnect?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
    delete?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
    connect?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
    update?: response_tree_versionsUpdateWithWhereUniqueWithoutResponse_treesInput | response_tree_versionsUpdateWithWhereUniqueWithoutResponse_treesInput[]
    updateMany?: response_tree_versionsUpdateManyWithWhereWithoutResponse_treesInput | response_tree_versionsUpdateManyWithWhereWithoutResponse_treesInput[]
    deleteMany?: response_tree_versionsScalarWhereInput | response_tree_versionsScalarWhereInput[]
  }

  export type response_nodesUncheckedUpdateManyWithoutResponse_treesNestedInput = {
    create?: XOR<response_nodesCreateWithoutResponse_treesInput, response_nodesUncheckedCreateWithoutResponse_treesInput> | response_nodesCreateWithoutResponse_treesInput[] | response_nodesUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_nodesCreateOrConnectWithoutResponse_treesInput | response_nodesCreateOrConnectWithoutResponse_treesInput[]
    upsert?: response_nodesUpsertWithWhereUniqueWithoutResponse_treesInput | response_nodesUpsertWithWhereUniqueWithoutResponse_treesInput[]
    createMany?: response_nodesCreateManyResponse_treesInputEnvelope
    set?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    disconnect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    delete?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    connect?: response_nodesWhereUniqueInput | response_nodesWhereUniqueInput[]
    update?: response_nodesUpdateWithWhereUniqueWithoutResponse_treesInput | response_nodesUpdateWithWhereUniqueWithoutResponse_treesInput[]
    updateMany?: response_nodesUpdateManyWithWhereWithoutResponse_treesInput | response_nodesUpdateManyWithWhereWithoutResponse_treesInput[]
    deleteMany?: response_nodesScalarWhereInput | response_nodesScalarWhereInput[]
  }

  export type response_tree_sessionsUncheckedUpdateManyWithoutResponse_treesNestedInput = {
    create?: XOR<response_tree_sessionsCreateWithoutResponse_treesInput, response_tree_sessionsUncheckedCreateWithoutResponse_treesInput> | response_tree_sessionsCreateWithoutResponse_treesInput[] | response_tree_sessionsUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_tree_sessionsCreateOrConnectWithoutResponse_treesInput | response_tree_sessionsCreateOrConnectWithoutResponse_treesInput[]
    upsert?: response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_treesInput | response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_treesInput[]
    createMany?: response_tree_sessionsCreateManyResponse_treesInputEnvelope
    set?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    disconnect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    delete?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    connect?: response_tree_sessionsWhereUniqueInput | response_tree_sessionsWhereUniqueInput[]
    update?: response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_treesInput | response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_treesInput[]
    updateMany?: response_tree_sessionsUpdateManyWithWhereWithoutResponse_treesInput | response_tree_sessionsUpdateManyWithWhereWithoutResponse_treesInput[]
    deleteMany?: response_tree_sessionsScalarWhereInput | response_tree_sessionsScalarWhereInput[]
  }

  export type response_tree_versionsUncheckedUpdateManyWithoutResponse_treesNestedInput = {
    create?: XOR<response_tree_versionsCreateWithoutResponse_treesInput, response_tree_versionsUncheckedCreateWithoutResponse_treesInput> | response_tree_versionsCreateWithoutResponse_treesInput[] | response_tree_versionsUncheckedCreateWithoutResponse_treesInput[]
    connectOrCreate?: response_tree_versionsCreateOrConnectWithoutResponse_treesInput | response_tree_versionsCreateOrConnectWithoutResponse_treesInput[]
    upsert?: response_tree_versionsUpsertWithWhereUniqueWithoutResponse_treesInput | response_tree_versionsUpsertWithWhereUniqueWithoutResponse_treesInput[]
    createMany?: response_tree_versionsCreateManyResponse_treesInputEnvelope
    set?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
    disconnect?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
    delete?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
    connect?: response_tree_versionsWhereUniqueInput | response_tree_versionsWhereUniqueInput[]
    update?: response_tree_versionsUpdateWithWhereUniqueWithoutResponse_treesInput | response_tree_versionsUpdateWithWhereUniqueWithoutResponse_treesInput[]
    updateMany?: response_tree_versionsUpdateManyWithWhereWithoutResponse_treesInput | response_tree_versionsUpdateManyWithWhereWithoutResponse_treesInput[]
    deleteMany?: response_tree_versionsScalarWhereInput | response_tree_versionsScalarWhereInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type TenantCreateNestedOneWithoutService_usage_statisticsInput = {
    create?: XOR<TenantCreateWithoutService_usage_statisticsInput, TenantUncheckedCreateWithoutService_usage_statisticsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutService_usage_statisticsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutService_usage_statisticsNestedInput = {
    create?: XOR<TenantCreateWithoutService_usage_statisticsInput, TenantUncheckedCreateWithoutService_usage_statisticsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutService_usage_statisticsInput
    upsert?: TenantUpsertWithoutService_usage_statisticsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutService_usage_statisticsInput, TenantUpdateWithoutService_usage_statisticsInput>, TenantUncheckedUpdateWithoutService_usage_statisticsInput>
  }

  export type TenantCreateNestedOneWithoutTenant_servicesInput = {
    create?: XOR<TenantCreateWithoutTenant_servicesInput, TenantUncheckedCreateWithoutTenant_servicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenant_servicesInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutTenant_servicesNestedInput = {
    create?: XOR<TenantCreateWithoutTenant_servicesInput, TenantUncheckedCreateWithoutTenant_servicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenant_servicesInput
    upsert?: TenantUpsertWithoutTenant_servicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTenant_servicesInput, TenantUpdateWithoutTenant_servicesInput>, TenantUncheckedUpdateWithoutTenant_servicesInput>
  }

  export type InvoiceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
  }

  export type InvoiceUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    upsert?: InvoiceUpsertWithoutTransactionsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTransactionsInput, InvoiceUpdateWithoutTransactionsInput>, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type PaymentUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    upsert?: PaymentUpsertWithoutTransactionInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionInput, PaymentUpdateWithoutTransactionInput>, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    upsert?: PaymentUpsertWithoutTransactionInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionInput, PaymentUpdateWithoutTransactionInput>, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutPaymentInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput
    connect?: TransactionWhereUniqueInput
  }

  export type InvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type TransactionUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput
    upsert?: TransactionUpsertWithoutPaymentInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPaymentInput, TransactionUpdateWithoutPaymentInput>, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAdminLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminLevel | EnumAdminLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AdminLevel[] | ListEnumAdminLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminLevel[] | ListEnumAdminLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminLevelFilter<$PrismaModel> | $Enums.AdminLevel
  }

  export type NestedEnumAdminLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminLevel | EnumAdminLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AdminLevel[] | ListEnumAdminLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminLevel[] | ListEnumAdminLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminLevelWithAggregatesFilter<$PrismaModel> | $Enums.AdminLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminLevelFilter<$PrismaModel>
    _max?: NestedEnumAdminLevelFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignDisplayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignDisplayType | EnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignDisplayType[] | ListEnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignDisplayType[] | ListEnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignDisplayTypeFilter<$PrismaModel> | $Enums.CampaignDisplayType
  }

  export type NestedEnumCampaignCtaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignCtaType | EnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignCtaType[] | ListEnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignCtaType[] | ListEnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignCtaTypeFilter<$PrismaModel> | $Enums.CampaignCtaType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedEnumCampaignDisplayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignDisplayType | EnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignDisplayType[] | ListEnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignDisplayType[] | ListEnumCampaignDisplayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignDisplayTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignDisplayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignDisplayTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignDisplayTypeFilter<$PrismaModel>
  }

  export type NestedEnumCampaignCtaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignCtaType | EnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignCtaType[] | ListEnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignCtaType[] | ListEnumCampaignCtaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignCtaTypeWithAggregatesFilter<$PrismaModel> | $Enums.CampaignCtaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignCtaTypeFilter<$PrismaModel>
    _max?: NestedEnumCampaignCtaTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type OrderItemCreateWithoutOrderInput = {
    tenantId: string
    menuItemId: number
    name: string
    price: number
    quantity: number
    status?: string
    notes?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    tenantId: string
    menuItemId: number
    name: string
    price: number
    quantity: number
    status?: string
    notes?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    tenantId?: StringFilter<"OrderItem"> | string
    orderId?: IntFilter<"OrderItem"> | number
    menuItemId?: IntFilter<"OrderItem"> | number
    name?: StringFilter<"OrderItem"> | string
    price?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    status?: StringFilter<"OrderItem"> | string
    notes?: StringNullableFilter<"OrderItem"> | string | null
    deliveredAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    deleted_at?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deleted_by?: StringNullableFilter<"OrderItem"> | string | null
    is_deleted?: BoolFilter<"OrderItem"> | boolean
  }

  export type OrderCreateWithoutOrderItemInput = {
    tenantId: string
    roomId: string
    placeId?: number | null
    status?: string
    items: JsonNullValueInput | InputJsonValue
    total: number
    createdAt?: Date | string
    updatedAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    uuid?: string | null
    sessionId?: string | null
  }

  export type OrderUncheckedCreateWithoutOrderItemInput = {
    id?: number
    tenantId: string
    roomId: string
    placeId?: number | null
    status?: string
    items: JsonNullValueInput | InputJsonValue
    total: number
    createdAt?: Date | string
    updatedAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    uuid?: string | null
    sessionId?: string | null
  }

  export type OrderCreateOrConnectWithoutOrderItemInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemInput, OrderUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderUpsertWithoutOrderItemInput = {
    update: XOR<OrderUpdateWithoutOrderItemInput, OrderUncheckedUpdateWithoutOrderItemInput>
    create: XOR<OrderCreateWithoutOrderItemInput, OrderUncheckedCreateWithoutOrderItemInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemInput, OrderUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderUpdateWithoutOrderItemInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateWithoutOrderItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    total?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput = {
    id: string
    systemType: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    monthlyPrice: number
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    Tenant: TenantCreateNestedOneWithoutTenantSystemPlanInput
  }

  export type TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput = {
    id: string
    tenantId: string
    systemType: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    monthlyPrice: number
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type TenantSystemPlanCreateOrConnectWithoutSystemPlanRestrictionsInput = {
    where: TenantSystemPlanWhereUniqueInput
    create: XOR<TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput, TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput>
  }

  export type TenantSystemPlanCreateManySystemPlanRestrictionsInputEnvelope = {
    data: TenantSystemPlanCreateManySystemPlanRestrictionsInput | TenantSystemPlanCreateManySystemPlanRestrictionsInput[]
    skipDuplicates?: boolean
  }

  export type TenantSystemPlanUpsertWithWhereUniqueWithoutSystemPlanRestrictionsInput = {
    where: TenantSystemPlanWhereUniqueInput
    update: XOR<TenantSystemPlanUpdateWithoutSystemPlanRestrictionsInput, TenantSystemPlanUncheckedUpdateWithoutSystemPlanRestrictionsInput>
    create: XOR<TenantSystemPlanCreateWithoutSystemPlanRestrictionsInput, TenantSystemPlanUncheckedCreateWithoutSystemPlanRestrictionsInput>
  }

  export type TenantSystemPlanUpdateWithWhereUniqueWithoutSystemPlanRestrictionsInput = {
    where: TenantSystemPlanWhereUniqueInput
    data: XOR<TenantSystemPlanUpdateWithoutSystemPlanRestrictionsInput, TenantSystemPlanUncheckedUpdateWithoutSystemPlanRestrictionsInput>
  }

  export type TenantSystemPlanUpdateManyWithWhereWithoutSystemPlanRestrictionsInput = {
    where: TenantSystemPlanScalarWhereInput
    data: XOR<TenantSystemPlanUpdateManyMutationInput, TenantSystemPlanUncheckedUpdateManyWithoutSystemPlanRestrictionsInput>
  }

  export type TenantSystemPlanScalarWhereInput = {
    AND?: TenantSystemPlanScalarWhereInput | TenantSystemPlanScalarWhereInput[]
    OR?: TenantSystemPlanScalarWhereInput[]
    NOT?: TenantSystemPlanScalarWhereInput | TenantSystemPlanScalarWhereInput[]
    id?: StringFilter<"TenantSystemPlan"> | string
    tenantId?: StringFilter<"TenantSystemPlan"> | string
    systemType?: StringFilter<"TenantSystemPlan"> | string
    planId?: StringFilter<"TenantSystemPlan"> | string
    startDate?: DateTimeFilter<"TenantSystemPlan"> | Date | string
    endDate?: DateTimeNullableFilter<"TenantSystemPlan"> | Date | string | null
    isActive?: BoolFilter<"TenantSystemPlan"> | boolean
    monthlyPrice?: IntFilter<"TenantSystemPlan"> | number
    createdAt?: DateTimeFilter<"TenantSystemPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TenantSystemPlan"> | Date | string
    deleted_at?: DateTimeNullableFilter<"TenantSystemPlan"> | Date | string | null
    deleted_by?: StringNullableFilter<"TenantSystemPlan"> | string | null
    is_deleted?: BoolFilter<"TenantSystemPlan"> | boolean
  }

  export type TenantSystemPlanCreateWithoutTenantInput = {
    id: string
    systemType: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    monthlyPrice: number
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    SystemPlanRestrictions: SystemPlanRestrictionsCreateNestedOneWithoutTenantSystemPlanInput
  }

  export type TenantSystemPlanUncheckedCreateWithoutTenantInput = {
    id: string
    systemType: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    monthlyPrice: number
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type TenantSystemPlanCreateOrConnectWithoutTenantInput = {
    where: TenantSystemPlanWhereUniqueInput
    create: XOR<TenantSystemPlanCreateWithoutTenantInput, TenantSystemPlanUncheckedCreateWithoutTenantInput>
  }

  export type TenantSystemPlanCreateManyTenantInputEnvelope = {
    data: TenantSystemPlanCreateManyTenantInput | TenantSystemPlanCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type device_roomsCreateWithoutTenantInput = {
    roomId: string
    roomName?: string | null
    deviceId?: string | null
    deviceType?: string | null
    placeId?: string | null
    status?: string | null
    ipAddress?: string | null
    macAddress?: string | null
    lastUsedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    is_deleted?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
  }

  export type device_roomsUncheckedCreateWithoutTenantInput = {
    id?: number
    roomId: string
    roomName?: string | null
    deviceId?: string | null
    deviceType?: string | null
    placeId?: string | null
    status?: string | null
    ipAddress?: string | null
    macAddress?: string | null
    lastUsedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    is_deleted?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
  }

  export type device_roomsCreateOrConnectWithoutTenantInput = {
    where: device_roomsWhereUniqueInput
    create: XOR<device_roomsCreateWithoutTenantInput, device_roomsUncheckedCreateWithoutTenantInput>
  }

  export type device_roomsCreateManyTenantInputEnvelope = {
    data: device_roomsCreateManyTenantInput | device_roomsCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type pagesCreateWithoutTenantInput = {
    Id: string
    Slug: string
    Title: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    IsPublished?: boolean
    PublishedAt?: Date | string | null
    Version?: number
    CreatedAt?: Date | string
    UpdatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    page_histories?: page_historiesCreateNestedManyWithoutPagesInput
  }

  export type pagesUncheckedCreateWithoutTenantInput = {
    Id: string
    Slug: string
    Title: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    IsPublished?: boolean
    PublishedAt?: Date | string | null
    Version?: number
    CreatedAt?: Date | string
    UpdatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    page_histories?: page_historiesUncheckedCreateNestedManyWithoutPagesInput
  }

  export type pagesCreateOrConnectWithoutTenantInput = {
    where: pagesWhereUniqueInput
    create: XOR<pagesCreateWithoutTenantInput, pagesUncheckedCreateWithoutTenantInput>
  }

  export type pagesCreateManyTenantInputEnvelope = {
    data: pagesCreateManyTenantInput | pagesCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type service_usage_statisticsCreateWithoutTenantInput = {
    id: string
    service_type: string
    month: string
    active_users_count?: number
    active_devices_count?: number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_usage_statisticsUncheckedCreateWithoutTenantInput = {
    id: string
    service_type: string
    month: string
    active_users_count?: number
    active_devices_count?: number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_usage_statisticsCreateOrConnectWithoutTenantInput = {
    where: service_usage_statisticsWhereUniqueInput
    create: XOR<service_usage_statisticsCreateWithoutTenantInput, service_usage_statisticsUncheckedCreateWithoutTenantInput>
  }

  export type service_usage_statisticsCreateManyTenantInputEnvelope = {
    data: service_usage_statisticsCreateManyTenantInput | service_usage_statisticsCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type tenant_servicesCreateWithoutTenantInput = {
    id: string
    service_type: string
    plan_type: string
    is_active?: boolean
    activated_at?: Date | string
    expires_at?: Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenant_servicesUncheckedCreateWithoutTenantInput = {
    id: string
    service_type: string
    plan_type: string
    is_active?: boolean
    activated_at?: Date | string
    expires_at?: Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenant_servicesCreateOrConnectWithoutTenantInput = {
    where: tenant_servicesWhereUniqueInput
    create: XOR<tenant_servicesCreateWithoutTenantInput, tenant_servicesUncheckedCreateWithoutTenantInput>
  }

  export type tenant_servicesCreateManyTenantInputEnvelope = {
    data: tenant_servicesCreateManyTenantInput | tenant_servicesCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantSystemPlanUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantSystemPlanWhereUniqueInput
    update: XOR<TenantSystemPlanUpdateWithoutTenantInput, TenantSystemPlanUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantSystemPlanCreateWithoutTenantInput, TenantSystemPlanUncheckedCreateWithoutTenantInput>
  }

  export type TenantSystemPlanUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantSystemPlanWhereUniqueInput
    data: XOR<TenantSystemPlanUpdateWithoutTenantInput, TenantSystemPlanUncheckedUpdateWithoutTenantInput>
  }

  export type TenantSystemPlanUpdateManyWithWhereWithoutTenantInput = {
    where: TenantSystemPlanScalarWhereInput
    data: XOR<TenantSystemPlanUpdateManyMutationInput, TenantSystemPlanUncheckedUpdateManyWithoutTenantInput>
  }

  export type device_roomsUpsertWithWhereUniqueWithoutTenantInput = {
    where: device_roomsWhereUniqueInput
    update: XOR<device_roomsUpdateWithoutTenantInput, device_roomsUncheckedUpdateWithoutTenantInput>
    create: XOR<device_roomsCreateWithoutTenantInput, device_roomsUncheckedCreateWithoutTenantInput>
  }

  export type device_roomsUpdateWithWhereUniqueWithoutTenantInput = {
    where: device_roomsWhereUniqueInput
    data: XOR<device_roomsUpdateWithoutTenantInput, device_roomsUncheckedUpdateWithoutTenantInput>
  }

  export type device_roomsUpdateManyWithWhereWithoutTenantInput = {
    where: device_roomsScalarWhereInput
    data: XOR<device_roomsUpdateManyMutationInput, device_roomsUncheckedUpdateManyWithoutTenantInput>
  }

  export type device_roomsScalarWhereInput = {
    AND?: device_roomsScalarWhereInput | device_roomsScalarWhereInput[]
    OR?: device_roomsScalarWhereInput[]
    NOT?: device_roomsScalarWhereInput | device_roomsScalarWhereInput[]
    id?: IntFilter<"device_rooms"> | number
    tenantId?: StringFilter<"device_rooms"> | string
    roomId?: StringFilter<"device_rooms"> | string
    roomName?: StringNullableFilter<"device_rooms"> | string | null
    deviceId?: StringNullableFilter<"device_rooms"> | string | null
    deviceType?: StringNullableFilter<"device_rooms"> | string | null
    placeId?: StringNullableFilter<"device_rooms"> | string | null
    status?: StringNullableFilter<"device_rooms"> | string | null
    ipAddress?: StringNullableFilter<"device_rooms"> | string | null
    macAddress?: StringNullableFilter<"device_rooms"> | string | null
    lastUsedAt?: DateTimeNullableFilter<"device_rooms"> | Date | string | null
    isActive?: BoolFilter<"device_rooms"> | boolean
    createdAt?: DateTimeFilter<"device_rooms"> | Date | string
    updatedAt?: DateTimeFilter<"device_rooms"> | Date | string
    is_deleted?: BoolFilter<"device_rooms"> | boolean
    deleted_at?: DateTimeNullableFilter<"device_rooms"> | Date | string | null
    deleted_by?: StringNullableFilter<"device_rooms"> | string | null
  }

  export type pagesUpsertWithWhereUniqueWithoutTenantInput = {
    where: pagesWhereUniqueInput
    update: XOR<pagesUpdateWithoutTenantInput, pagesUncheckedUpdateWithoutTenantInput>
    create: XOR<pagesCreateWithoutTenantInput, pagesUncheckedCreateWithoutTenantInput>
  }

  export type pagesUpdateWithWhereUniqueWithoutTenantInput = {
    where: pagesWhereUniqueInput
    data: XOR<pagesUpdateWithoutTenantInput, pagesUncheckedUpdateWithoutTenantInput>
  }

  export type pagesUpdateManyWithWhereWithoutTenantInput = {
    where: pagesScalarWhereInput
    data: XOR<pagesUpdateManyMutationInput, pagesUncheckedUpdateManyWithoutTenantInput>
  }

  export type pagesScalarWhereInput = {
    AND?: pagesScalarWhereInput | pagesScalarWhereInput[]
    OR?: pagesScalarWhereInput[]
    NOT?: pagesScalarWhereInput | pagesScalarWhereInput[]
    Id?: StringFilter<"pages"> | string
    TenantId?: StringFilter<"pages"> | string
    Slug?: StringFilter<"pages"> | string
    Title?: StringFilter<"pages"> | string
    Html?: StringNullableFilter<"pages"> | string | null
    Css?: StringNullableFilter<"pages"> | string | null
    Content?: StringNullableFilter<"pages"> | string | null
    Template?: StringNullableFilter<"pages"> | string | null
    IsPublished?: BoolFilter<"pages"> | boolean
    PublishedAt?: DateTimeNullableFilter<"pages"> | Date | string | null
    Version?: IntFilter<"pages"> | number
    CreatedAt?: DateTimeFilter<"pages"> | Date | string
    UpdatedAt?: DateTimeFilter<"pages"> | Date | string
    deleted_at?: DateTimeNullableFilter<"pages"> | Date | string | null
    deleted_by?: StringNullableFilter<"pages"> | string | null
    is_deleted?: BoolFilter<"pages"> | boolean
  }

  export type service_usage_statisticsUpsertWithWhereUniqueWithoutTenantInput = {
    where: service_usage_statisticsWhereUniqueInput
    update: XOR<service_usage_statisticsUpdateWithoutTenantInput, service_usage_statisticsUncheckedUpdateWithoutTenantInput>
    create: XOR<service_usage_statisticsCreateWithoutTenantInput, service_usage_statisticsUncheckedCreateWithoutTenantInput>
  }

  export type service_usage_statisticsUpdateWithWhereUniqueWithoutTenantInput = {
    where: service_usage_statisticsWhereUniqueInput
    data: XOR<service_usage_statisticsUpdateWithoutTenantInput, service_usage_statisticsUncheckedUpdateWithoutTenantInput>
  }

  export type service_usage_statisticsUpdateManyWithWhereWithoutTenantInput = {
    where: service_usage_statisticsScalarWhereInput
    data: XOR<service_usage_statisticsUpdateManyMutationInput, service_usage_statisticsUncheckedUpdateManyWithoutTenantInput>
  }

  export type service_usage_statisticsScalarWhereInput = {
    AND?: service_usage_statisticsScalarWhereInput | service_usage_statisticsScalarWhereInput[]
    OR?: service_usage_statisticsScalarWhereInput[]
    NOT?: service_usage_statisticsScalarWhereInput | service_usage_statisticsScalarWhereInput[]
    id?: StringFilter<"service_usage_statistics"> | string
    tenant_id?: StringFilter<"service_usage_statistics"> | string
    service_type?: StringFilter<"service_usage_statistics"> | string
    month?: StringFilter<"service_usage_statistics"> | string
    active_users_count?: IntFilter<"service_usage_statistics"> | number
    active_devices_count?: IntFilter<"service_usage_statistics"> | number
    usage_data?: JsonFilter<"service_usage_statistics">
    created_at?: DateTimeFilter<"service_usage_statistics"> | Date | string
    updated_at?: DateTimeFilter<"service_usage_statistics"> | Date | string
  }

  export type tenant_servicesUpsertWithWhereUniqueWithoutTenantInput = {
    where: tenant_servicesWhereUniqueInput
    update: XOR<tenant_servicesUpdateWithoutTenantInput, tenant_servicesUncheckedUpdateWithoutTenantInput>
    create: XOR<tenant_servicesCreateWithoutTenantInput, tenant_servicesUncheckedCreateWithoutTenantInput>
  }

  export type tenant_servicesUpdateWithWhereUniqueWithoutTenantInput = {
    where: tenant_servicesWhereUniqueInput
    data: XOR<tenant_servicesUpdateWithoutTenantInput, tenant_servicesUncheckedUpdateWithoutTenantInput>
  }

  export type tenant_servicesUpdateManyWithWhereWithoutTenantInput = {
    where: tenant_servicesScalarWhereInput
    data: XOR<tenant_servicesUpdateManyMutationInput, tenant_servicesUncheckedUpdateManyWithoutTenantInput>
  }

  export type tenant_servicesScalarWhereInput = {
    AND?: tenant_servicesScalarWhereInput | tenant_servicesScalarWhereInput[]
    OR?: tenant_servicesScalarWhereInput[]
    NOT?: tenant_servicesScalarWhereInput | tenant_servicesScalarWhereInput[]
    id?: StringFilter<"tenant_services"> | string
    tenant_id?: StringFilter<"tenant_services"> | string
    service_type?: StringFilter<"tenant_services"> | string
    plan_type?: StringFilter<"tenant_services"> | string
    is_active?: BoolFilter<"tenant_services"> | boolean
    activated_at?: DateTimeFilter<"tenant_services"> | Date | string
    expires_at?: DateTimeNullableFilter<"tenant_services"> | Date | string | null
    service_config?: JsonFilter<"tenant_services">
    created_at?: DateTimeFilter<"tenant_services"> | Date | string
    updated_at?: DateTimeFilter<"tenant_services"> | Date | string
  }

  export type SystemPlanRestrictionsCreateWithoutTenantSystemPlanInput = {
    id: string
    systemType: string
    businessType: string
    planType: string
    planCategory: string
    monthlyPrice: number
    maxDevices?: number
    additionalDeviceCost?: number
    roomTerminalCost?: number
    frontDeskCost?: number
    kitchenCost?: number
    barCost?: number
    housekeepingCost?: number
    managerCost?: number
    commonAreaCost?: number
    enableAiConcierge?: boolean
    enableMultilingual?: boolean
    enableLayoutEditor?: boolean
    enableFacilityGuide?: boolean
    enableAiBusinessSupport?: boolean
    maxMonthlyOrders?: number
    maxMonthlyAiRequests?: number
    maxStorageGB?: number
    multilingualUpgradePrice?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type SystemPlanRestrictionsUncheckedCreateWithoutTenantSystemPlanInput = {
    id: string
    systemType: string
    businessType: string
    planType: string
    planCategory: string
    monthlyPrice: number
    maxDevices?: number
    additionalDeviceCost?: number
    roomTerminalCost?: number
    frontDeskCost?: number
    kitchenCost?: number
    barCost?: number
    housekeepingCost?: number
    managerCost?: number
    commonAreaCost?: number
    enableAiConcierge?: boolean
    enableMultilingual?: boolean
    enableLayoutEditor?: boolean
    enableFacilityGuide?: boolean
    enableAiBusinessSupport?: boolean
    maxMonthlyOrders?: number
    maxMonthlyAiRequests?: number
    maxStorageGB?: number
    multilingualUpgradePrice?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type SystemPlanRestrictionsCreateOrConnectWithoutTenantSystemPlanInput = {
    where: SystemPlanRestrictionsWhereUniqueInput
    create: XOR<SystemPlanRestrictionsCreateWithoutTenantSystemPlanInput, SystemPlanRestrictionsUncheckedCreateWithoutTenantSystemPlanInput>
  }

  export type TenantCreateWithoutTenantSystemPlanInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    device_rooms?: device_roomsCreateNestedManyWithoutTenantInput
    pages?: pagesCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTenantSystemPlanInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    device_rooms?: device_roomsUncheckedCreateNestedManyWithoutTenantInput
    pages?: pagesUncheckedCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsUncheckedCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTenantSystemPlanInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTenantSystemPlanInput, TenantUncheckedCreateWithoutTenantSystemPlanInput>
  }

  export type SystemPlanRestrictionsUpsertWithoutTenantSystemPlanInput = {
    update: XOR<SystemPlanRestrictionsUpdateWithoutTenantSystemPlanInput, SystemPlanRestrictionsUncheckedUpdateWithoutTenantSystemPlanInput>
    create: XOR<SystemPlanRestrictionsCreateWithoutTenantSystemPlanInput, SystemPlanRestrictionsUncheckedCreateWithoutTenantSystemPlanInput>
    where?: SystemPlanRestrictionsWhereInput
  }

  export type SystemPlanRestrictionsUpdateToOneWithWhereWithoutTenantSystemPlanInput = {
    where?: SystemPlanRestrictionsWhereInput
    data: XOR<SystemPlanRestrictionsUpdateWithoutTenantSystemPlanInput, SystemPlanRestrictionsUncheckedUpdateWithoutTenantSystemPlanInput>
  }

  export type SystemPlanRestrictionsUpdateWithoutTenantSystemPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    planCategory?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    maxDevices?: IntFieldUpdateOperationsInput | number
    additionalDeviceCost?: IntFieldUpdateOperationsInput | number
    roomTerminalCost?: IntFieldUpdateOperationsInput | number
    frontDeskCost?: IntFieldUpdateOperationsInput | number
    kitchenCost?: IntFieldUpdateOperationsInput | number
    barCost?: IntFieldUpdateOperationsInput | number
    housekeepingCost?: IntFieldUpdateOperationsInput | number
    managerCost?: IntFieldUpdateOperationsInput | number
    commonAreaCost?: IntFieldUpdateOperationsInput | number
    enableAiConcierge?: BoolFieldUpdateOperationsInput | boolean
    enableMultilingual?: BoolFieldUpdateOperationsInput | boolean
    enableLayoutEditor?: BoolFieldUpdateOperationsInput | boolean
    enableFacilityGuide?: BoolFieldUpdateOperationsInput | boolean
    enableAiBusinessSupport?: BoolFieldUpdateOperationsInput | boolean
    maxMonthlyOrders?: IntFieldUpdateOperationsInput | number
    maxMonthlyAiRequests?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    multilingualUpgradePrice?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemPlanRestrictionsUncheckedUpdateWithoutTenantSystemPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    planType?: StringFieldUpdateOperationsInput | string
    planCategory?: StringFieldUpdateOperationsInput | string
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    maxDevices?: IntFieldUpdateOperationsInput | number
    additionalDeviceCost?: IntFieldUpdateOperationsInput | number
    roomTerminalCost?: IntFieldUpdateOperationsInput | number
    frontDeskCost?: IntFieldUpdateOperationsInput | number
    kitchenCost?: IntFieldUpdateOperationsInput | number
    barCost?: IntFieldUpdateOperationsInput | number
    housekeepingCost?: IntFieldUpdateOperationsInput | number
    managerCost?: IntFieldUpdateOperationsInput | number
    commonAreaCost?: IntFieldUpdateOperationsInput | number
    enableAiConcierge?: BoolFieldUpdateOperationsInput | boolean
    enableMultilingual?: BoolFieldUpdateOperationsInput | boolean
    enableLayoutEditor?: BoolFieldUpdateOperationsInput | boolean
    enableFacilityGuide?: BoolFieldUpdateOperationsInput | boolean
    enableAiBusinessSupport?: BoolFieldUpdateOperationsInput | boolean
    maxMonthlyOrders?: IntFieldUpdateOperationsInput | number
    maxMonthlyAiRequests?: IntFieldUpdateOperationsInput | number
    maxStorageGB?: FloatFieldUpdateOperationsInput | number
    multilingualUpgradePrice?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantUpsertWithoutTenantSystemPlanInput = {
    update: XOR<TenantUpdateWithoutTenantSystemPlanInput, TenantUncheckedUpdateWithoutTenantSystemPlanInput>
    create: XOR<TenantCreateWithoutTenantSystemPlanInput, TenantUncheckedCreateWithoutTenantSystemPlanInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTenantSystemPlanInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTenantSystemPlanInput, TenantUncheckedUpdateWithoutTenantSystemPlanInput>
  }

  export type TenantUpdateWithoutTenantSystemPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    device_rooms?: device_roomsUpdateManyWithoutTenantNestedInput
    pages?: pagesUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTenantSystemPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    device_rooms?: device_roomsUncheckedUpdateManyWithoutTenantNestedInput
    pages?: pagesUncheckedUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUncheckedUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type admin_logCreateWithoutAdminInput = {
    id: string
    action: string
    target_type?: string | null
    target_id?: string | null
    ip_address?: string | null
    user_agent?: string | null
    success?: boolean
    error_message?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type admin_logUncheckedCreateWithoutAdminInput = {
    id: string
    action: string
    target_type?: string | null
    target_id?: string | null
    ip_address?: string | null
    user_agent?: string | null
    success?: boolean
    error_message?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type admin_logCreateOrConnectWithoutAdminInput = {
    where: admin_logWhereUniqueInput
    create: XOR<admin_logCreateWithoutAdminInput, admin_logUncheckedCreateWithoutAdminInput>
  }

  export type admin_logCreateManyAdminInputEnvelope = {
    data: admin_logCreateManyAdminInput | admin_logCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type admin_logUpsertWithWhereUniqueWithoutAdminInput = {
    where: admin_logWhereUniqueInput
    update: XOR<admin_logUpdateWithoutAdminInput, admin_logUncheckedUpdateWithoutAdminInput>
    create: XOR<admin_logCreateWithoutAdminInput, admin_logUncheckedCreateWithoutAdminInput>
  }

  export type admin_logUpdateWithWhereUniqueWithoutAdminInput = {
    where: admin_logWhereUniqueInput
    data: XOR<admin_logUpdateWithoutAdminInput, admin_logUncheckedUpdateWithoutAdminInput>
  }

  export type admin_logUpdateManyWithWhereWithoutAdminInput = {
    where: admin_logScalarWhereInput
    data: XOR<admin_logUpdateManyMutationInput, admin_logUncheckedUpdateManyWithoutAdminInput>
  }

  export type admin_logScalarWhereInput = {
    AND?: admin_logScalarWhereInput | admin_logScalarWhereInput[]
    OR?: admin_logScalarWhereInput[]
    NOT?: admin_logScalarWhereInput | admin_logScalarWhereInput[]
    id?: StringFilter<"admin_log"> | string
    admin_id?: StringFilter<"admin_log"> | string
    action?: StringFilter<"admin_log"> | string
    target_type?: StringNullableFilter<"admin_log"> | string | null
    target_id?: StringNullableFilter<"admin_log"> | string | null
    ip_address?: StringNullableFilter<"admin_log"> | string | null
    user_agent?: StringNullableFilter<"admin_log"> | string | null
    success?: BoolFilter<"admin_log"> | boolean
    error_message?: StringNullableFilter<"admin_log"> | string | null
    created_at?: DateTimeFilter<"admin_log"> | Date | string
    deleted_at?: DateTimeNullableFilter<"admin_log"> | Date | string | null
    deleted_by?: StringNullableFilter<"admin_log"> | string | null
    is_deleted?: BoolFilter<"admin_log"> | boolean
  }

  export type adminCreateWithoutAdmin_logInput = {
    id: string
    email: string
    username: string
    display_name: string
    password_hash: string
    admin_level: $Enums.AdminLevel
    accessible_group_ids?: adminCreateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminCreateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminCreateaccessible_tenant_idsInput | string[]
    last_login_at?: Date | string | null
    login_attempts?: number
    locked_until?: Date | string | null
    totp_secret?: string | null
    totp_enabled?: boolean
    created_at?: Date | string
    updated_at: Date | string
    created_by?: string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type adminUncheckedCreateWithoutAdmin_logInput = {
    id: string
    email: string
    username: string
    display_name: string
    password_hash: string
    admin_level: $Enums.AdminLevel
    accessible_group_ids?: adminCreateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminCreateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminCreateaccessible_tenant_idsInput | string[]
    last_login_at?: Date | string | null
    login_attempts?: number
    locked_until?: Date | string | null
    totp_secret?: string | null
    totp_enabled?: boolean
    created_at?: Date | string
    updated_at: Date | string
    created_by?: string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type adminCreateOrConnectWithoutAdmin_logInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutAdmin_logInput, adminUncheckedCreateWithoutAdmin_logInput>
  }

  export type adminUpsertWithoutAdmin_logInput = {
    update: XOR<adminUpdateWithoutAdmin_logInput, adminUncheckedUpdateWithoutAdmin_logInput>
    create: XOR<adminCreateWithoutAdmin_logInput, adminUncheckedCreateWithoutAdmin_logInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutAdmin_logInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutAdmin_logInput, adminUncheckedUpdateWithoutAdmin_logInput>
  }

  export type adminUpdateWithoutAdmin_logInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_level?: EnumAdminLevelFieldUpdateOperationsInput | $Enums.AdminLevel
    accessible_group_ids?: adminUpdateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminUpdateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminUpdateaccessible_tenant_idsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    totp_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type adminUncheckedUpdateWithoutAdmin_logInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    display_name?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    admin_level?: EnumAdminLevelFieldUpdateOperationsInput | $Enums.AdminLevel
    accessible_group_ids?: adminUpdateaccessible_group_idsInput | string[]
    accessible_chain_ids?: adminUpdateaccessible_chain_idsInput | string[]
    accessible_tenant_ids?: adminUpdateaccessible_tenant_idsInput | string[]
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    login_attempts?: IntFieldUpdateOperationsInput | number
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    totp_enabled?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_category_relationsCreateWithoutCampaign_categoriesInput = {
    id: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaigns: campaignsCreateNestedOneWithoutCampaign_category_relationsInput
  }

  export type campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput = {
    id: string
    campaignId: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_category_relationsCreateOrConnectWithoutCampaign_categoriesInput = {
    where: campaign_category_relationsWhereUniqueInput
    create: XOR<campaign_category_relationsCreateWithoutCampaign_categoriesInput, campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput>
  }

  export type campaign_category_relationsCreateManyCampaign_categoriesInputEnvelope = {
    data: campaign_category_relationsCreateManyCampaign_categoriesInput | campaign_category_relationsCreateManyCampaign_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type campaign_category_relationsUpsertWithWhereUniqueWithoutCampaign_categoriesInput = {
    where: campaign_category_relationsWhereUniqueInput
    update: XOR<campaign_category_relationsUpdateWithoutCampaign_categoriesInput, campaign_category_relationsUncheckedUpdateWithoutCampaign_categoriesInput>
    create: XOR<campaign_category_relationsCreateWithoutCampaign_categoriesInput, campaign_category_relationsUncheckedCreateWithoutCampaign_categoriesInput>
  }

  export type campaign_category_relationsUpdateWithWhereUniqueWithoutCampaign_categoriesInput = {
    where: campaign_category_relationsWhereUniqueInput
    data: XOR<campaign_category_relationsUpdateWithoutCampaign_categoriesInput, campaign_category_relationsUncheckedUpdateWithoutCampaign_categoriesInput>
  }

  export type campaign_category_relationsUpdateManyWithWhereWithoutCampaign_categoriesInput = {
    where: campaign_category_relationsScalarWhereInput
    data: XOR<campaign_category_relationsUpdateManyMutationInput, campaign_category_relationsUncheckedUpdateManyWithoutCampaign_categoriesInput>
  }

  export type campaign_category_relationsScalarWhereInput = {
    AND?: campaign_category_relationsScalarWhereInput | campaign_category_relationsScalarWhereInput[]
    OR?: campaign_category_relationsScalarWhereInput[]
    NOT?: campaign_category_relationsScalarWhereInput | campaign_category_relationsScalarWhereInput[]
    id?: StringFilter<"campaign_category_relations"> | string
    campaignId?: StringFilter<"campaign_category_relations"> | string
    categoryId?: StringFilter<"campaign_category_relations"> | string
    createdAt?: DateTimeFilter<"campaign_category_relations"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_category_relations"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_category_relations"> | string | null
    is_deleted?: BoolFilter<"campaign_category_relations"> | boolean
  }

  export type campaignsCreateWithoutCampaign_category_relationsInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_items?: campaign_itemsCreateNestedManyWithoutCampaignsInput
    campaign_translations?: campaign_translationsCreateNestedManyWithoutCampaignsInput
    campaign_usage_logs?: campaign_usage_logsCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsUncheckedCreateWithoutCampaign_category_relationsInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_items?: campaign_itemsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_translations?: campaign_translationsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_usage_logs?: campaign_usage_logsUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsCreateOrConnectWithoutCampaign_category_relationsInput = {
    where: campaignsWhereUniqueInput
    create: XOR<campaignsCreateWithoutCampaign_category_relationsInput, campaignsUncheckedCreateWithoutCampaign_category_relationsInput>
  }

  export type campaign_categoriesCreateWithoutCampaign_category_relationsInput = {
    id: string
    tenantId: string
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_categoriesUncheckedCreateWithoutCampaign_category_relationsInput = {
    id: string
    tenantId: string
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_categoriesCreateOrConnectWithoutCampaign_category_relationsInput = {
    where: campaign_categoriesWhereUniqueInput
    create: XOR<campaign_categoriesCreateWithoutCampaign_category_relationsInput, campaign_categoriesUncheckedCreateWithoutCampaign_category_relationsInput>
  }

  export type campaignsUpsertWithoutCampaign_category_relationsInput = {
    update: XOR<campaignsUpdateWithoutCampaign_category_relationsInput, campaignsUncheckedUpdateWithoutCampaign_category_relationsInput>
    create: XOR<campaignsCreateWithoutCampaign_category_relationsInput, campaignsUncheckedCreateWithoutCampaign_category_relationsInput>
    where?: campaignsWhereInput
  }

  export type campaignsUpdateToOneWithWhereWithoutCampaign_category_relationsInput = {
    where?: campaignsWhereInput
    data: XOR<campaignsUpdateWithoutCampaign_category_relationsInput, campaignsUncheckedUpdateWithoutCampaign_category_relationsInput>
  }

  export type campaignsUpdateWithoutCampaign_category_relationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_items?: campaign_itemsUpdateManyWithoutCampaignsNestedInput
    campaign_translations?: campaign_translationsUpdateManyWithoutCampaignsNestedInput
    campaign_usage_logs?: campaign_usage_logsUpdateManyWithoutCampaignsNestedInput
  }

  export type campaignsUncheckedUpdateWithoutCampaign_category_relationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_items?: campaign_itemsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_translations?: campaign_translationsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_usage_logs?: campaign_usage_logsUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type campaign_categoriesUpsertWithoutCampaign_category_relationsInput = {
    update: XOR<campaign_categoriesUpdateWithoutCampaign_category_relationsInput, campaign_categoriesUncheckedUpdateWithoutCampaign_category_relationsInput>
    create: XOR<campaign_categoriesCreateWithoutCampaign_category_relationsInput, campaign_categoriesUncheckedCreateWithoutCampaign_category_relationsInput>
    where?: campaign_categoriesWhereInput
  }

  export type campaign_categoriesUpdateToOneWithWhereWithoutCampaign_category_relationsInput = {
    where?: campaign_categoriesWhereInput
    data: XOR<campaign_categoriesUpdateWithoutCampaign_category_relationsInput, campaign_categoriesUncheckedUpdateWithoutCampaign_category_relationsInput>
  }

  export type campaign_categoriesUpdateWithoutCampaign_category_relationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_categoriesUncheckedUpdateWithoutCampaign_category_relationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaignsCreateWithoutCampaign_itemsInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsCreateNestedManyWithoutCampaignsInput
    campaign_translations?: campaign_translationsCreateNestedManyWithoutCampaignsInput
    campaign_usage_logs?: campaign_usage_logsCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsUncheckedCreateWithoutCampaign_itemsInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_translations?: campaign_translationsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_usage_logs?: campaign_usage_logsUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsCreateOrConnectWithoutCampaign_itemsInput = {
    where: campaignsWhereUniqueInput
    create: XOR<campaignsCreateWithoutCampaign_itemsInput, campaignsUncheckedCreateWithoutCampaign_itemsInput>
  }

  export type campaignsUpsertWithoutCampaign_itemsInput = {
    update: XOR<campaignsUpdateWithoutCampaign_itemsInput, campaignsUncheckedUpdateWithoutCampaign_itemsInput>
    create: XOR<campaignsCreateWithoutCampaign_itemsInput, campaignsUncheckedCreateWithoutCampaign_itemsInput>
    where?: campaignsWhereInput
  }

  export type campaignsUpdateToOneWithWhereWithoutCampaign_itemsInput = {
    where?: campaignsWhereInput
    data: XOR<campaignsUpdateWithoutCampaign_itemsInput, campaignsUncheckedUpdateWithoutCampaign_itemsInput>
  }

  export type campaignsUpdateWithoutCampaign_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUpdateManyWithoutCampaignsNestedInput
    campaign_translations?: campaign_translationsUpdateManyWithoutCampaignsNestedInput
    campaign_usage_logs?: campaign_usage_logsUpdateManyWithoutCampaignsNestedInput
  }

  export type campaignsUncheckedUpdateWithoutCampaign_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_translations?: campaign_translationsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_usage_logs?: campaign_usage_logsUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type campaignsCreateWithoutCampaign_translationsInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsCreateNestedManyWithoutCampaignsInput
    campaign_items?: campaign_itemsCreateNestedManyWithoutCampaignsInput
    campaign_usage_logs?: campaign_usage_logsCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsUncheckedCreateWithoutCampaign_translationsInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_items?: campaign_itemsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_usage_logs?: campaign_usage_logsUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsCreateOrConnectWithoutCampaign_translationsInput = {
    where: campaignsWhereUniqueInput
    create: XOR<campaignsCreateWithoutCampaign_translationsInput, campaignsUncheckedCreateWithoutCampaign_translationsInput>
  }

  export type campaignsUpsertWithoutCampaign_translationsInput = {
    update: XOR<campaignsUpdateWithoutCampaign_translationsInput, campaignsUncheckedUpdateWithoutCampaign_translationsInput>
    create: XOR<campaignsCreateWithoutCampaign_translationsInput, campaignsUncheckedCreateWithoutCampaign_translationsInput>
    where?: campaignsWhereInput
  }

  export type campaignsUpdateToOneWithWhereWithoutCampaign_translationsInput = {
    where?: campaignsWhereInput
    data: XOR<campaignsUpdateWithoutCampaign_translationsInput, campaignsUncheckedUpdateWithoutCampaign_translationsInput>
  }

  export type campaignsUpdateWithoutCampaign_translationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUpdateManyWithoutCampaignsNestedInput
    campaign_items?: campaign_itemsUpdateManyWithoutCampaignsNestedInput
    campaign_usage_logs?: campaign_usage_logsUpdateManyWithoutCampaignsNestedInput
  }

  export type campaignsUncheckedUpdateWithoutCampaign_translationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_items?: campaign_itemsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_usage_logs?: campaign_usage_logsUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type campaignsCreateWithoutCampaign_usage_logsInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsCreateNestedManyWithoutCampaignsInput
    campaign_items?: campaign_itemsCreateNestedManyWithoutCampaignsInput
    campaign_translations?: campaign_translationsCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsUncheckedCreateWithoutCampaign_usage_logsInput = {
    id: string
    tenantId: string
    code: string
    status?: $Enums.CampaignStatus
    displayType: $Enums.CampaignDisplayType
    startDate?: Date | string | null
    endDate?: Date | string | null
    priority?: number
    ctaType?: $Enums.CampaignCtaType
    ctaAction?: string | null
    ctaLabel?: string | null
    discountType?: string | null
    discountValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    displayPriority?: number
    maxUsageCount?: number | null
    name: string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_category_relations?: campaign_category_relationsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_items?: campaign_itemsUncheckedCreateNestedManyWithoutCampaignsInput
    campaign_translations?: campaign_translationsUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type campaignsCreateOrConnectWithoutCampaign_usage_logsInput = {
    where: campaignsWhereUniqueInput
    create: XOR<campaignsCreateWithoutCampaign_usage_logsInput, campaignsUncheckedCreateWithoutCampaign_usage_logsInput>
  }

  export type campaignsUpsertWithoutCampaign_usage_logsInput = {
    update: XOR<campaignsUpdateWithoutCampaign_usage_logsInput, campaignsUncheckedUpdateWithoutCampaign_usage_logsInput>
    create: XOR<campaignsCreateWithoutCampaign_usage_logsInput, campaignsUncheckedCreateWithoutCampaign_usage_logsInput>
    where?: campaignsWhereInput
  }

  export type campaignsUpdateToOneWithWhereWithoutCampaign_usage_logsInput = {
    where?: campaignsWhereInput
    data: XOR<campaignsUpdateWithoutCampaign_usage_logsInput, campaignsUncheckedUpdateWithoutCampaign_usage_logsInput>
  }

  export type campaignsUpdateWithoutCampaign_usage_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUpdateManyWithoutCampaignsNestedInput
    campaign_items?: campaign_itemsUpdateManyWithoutCampaignsNestedInput
    campaign_translations?: campaign_translationsUpdateManyWithoutCampaignsNestedInput
  }

  export type campaignsUncheckedUpdateWithoutCampaign_usage_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    displayType?: EnumCampaignDisplayTypeFieldUpdateOperationsInput | $Enums.CampaignDisplayType
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: IntFieldUpdateOperationsInput | number
    ctaType?: EnumCampaignCtaTypeFieldUpdateOperationsInput | $Enums.CampaignCtaType
    ctaAction?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLabel?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayRestrictions?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayPriority?: IntFieldUpdateOperationsInput | number
    maxUsageCount?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    timeRestrictions?: NullableJsonNullValueInput | InputJsonValue
    welcomeSettings?: NullableJsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_category_relations?: campaign_category_relationsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_items?: campaign_itemsUncheckedUpdateManyWithoutCampaignsNestedInput
    campaign_translations?: campaign_translationsUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type campaign_category_relationsCreateWithoutCampaignsInput = {
    id: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    campaign_categories: campaign_categoriesCreateNestedOneWithoutCampaign_category_relationsInput
  }

  export type campaign_category_relationsUncheckedCreateWithoutCampaignsInput = {
    id: string
    categoryId: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_category_relationsCreateOrConnectWithoutCampaignsInput = {
    where: campaign_category_relationsWhereUniqueInput
    create: XOR<campaign_category_relationsCreateWithoutCampaignsInput, campaign_category_relationsUncheckedCreateWithoutCampaignsInput>
  }

  export type campaign_category_relationsCreateManyCampaignsInputEnvelope = {
    data: campaign_category_relationsCreateManyCampaignsInput | campaign_category_relationsCreateManyCampaignsInput[]
    skipDuplicates?: boolean
  }

  export type campaign_itemsCreateWithoutCampaignsInput = {
    id: string
    itemId: string
    itemType: string
    priority?: number
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_itemsUncheckedCreateWithoutCampaignsInput = {
    id: string
    itemId: string
    itemType: string
    priority?: number
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_itemsCreateOrConnectWithoutCampaignsInput = {
    where: campaign_itemsWhereUniqueInput
    create: XOR<campaign_itemsCreateWithoutCampaignsInput, campaign_itemsUncheckedCreateWithoutCampaignsInput>
  }

  export type campaign_itemsCreateManyCampaignsInputEnvelope = {
    data: campaign_itemsCreateManyCampaignsInput | campaign_itemsCreateManyCampaignsInput[]
    skipDuplicates?: boolean
  }

  export type campaign_translationsCreateWithoutCampaignsInput = {
    id: string
    locale: string
    title: string
    description?: string | null
    imageUrl?: string | null
    languageCode?: string | null
    name?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_translationsUncheckedCreateWithoutCampaignsInput = {
    id: string
    locale: string
    title: string
    description?: string | null
    imageUrl?: string | null
    languageCode?: string | null
    name?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_translationsCreateOrConnectWithoutCampaignsInput = {
    where: campaign_translationsWhereUniqueInput
    create: XOR<campaign_translationsCreateWithoutCampaignsInput, campaign_translationsUncheckedCreateWithoutCampaignsInput>
  }

  export type campaign_translationsCreateManyCampaignsInputEnvelope = {
    data: campaign_translationsCreateManyCampaignsInput | campaign_translationsCreateManyCampaignsInput[]
    skipDuplicates?: boolean
  }

  export type campaign_usage_logsCreateWithoutCampaignsInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    action: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_usage_logsUncheckedCreateWithoutCampaignsInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    action: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_usage_logsCreateOrConnectWithoutCampaignsInput = {
    where: campaign_usage_logsWhereUniqueInput
    create: XOR<campaign_usage_logsCreateWithoutCampaignsInput, campaign_usage_logsUncheckedCreateWithoutCampaignsInput>
  }

  export type campaign_usage_logsCreateManyCampaignsInputEnvelope = {
    data: campaign_usage_logsCreateManyCampaignsInput | campaign_usage_logsCreateManyCampaignsInput[]
    skipDuplicates?: boolean
  }

  export type campaign_category_relationsUpsertWithWhereUniqueWithoutCampaignsInput = {
    where: campaign_category_relationsWhereUniqueInput
    update: XOR<campaign_category_relationsUpdateWithoutCampaignsInput, campaign_category_relationsUncheckedUpdateWithoutCampaignsInput>
    create: XOR<campaign_category_relationsCreateWithoutCampaignsInput, campaign_category_relationsUncheckedCreateWithoutCampaignsInput>
  }

  export type campaign_category_relationsUpdateWithWhereUniqueWithoutCampaignsInput = {
    where: campaign_category_relationsWhereUniqueInput
    data: XOR<campaign_category_relationsUpdateWithoutCampaignsInput, campaign_category_relationsUncheckedUpdateWithoutCampaignsInput>
  }

  export type campaign_category_relationsUpdateManyWithWhereWithoutCampaignsInput = {
    where: campaign_category_relationsScalarWhereInput
    data: XOR<campaign_category_relationsUpdateManyMutationInput, campaign_category_relationsUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type campaign_itemsUpsertWithWhereUniqueWithoutCampaignsInput = {
    where: campaign_itemsWhereUniqueInput
    update: XOR<campaign_itemsUpdateWithoutCampaignsInput, campaign_itemsUncheckedUpdateWithoutCampaignsInput>
    create: XOR<campaign_itemsCreateWithoutCampaignsInput, campaign_itemsUncheckedCreateWithoutCampaignsInput>
  }

  export type campaign_itemsUpdateWithWhereUniqueWithoutCampaignsInput = {
    where: campaign_itemsWhereUniqueInput
    data: XOR<campaign_itemsUpdateWithoutCampaignsInput, campaign_itemsUncheckedUpdateWithoutCampaignsInput>
  }

  export type campaign_itemsUpdateManyWithWhereWithoutCampaignsInput = {
    where: campaign_itemsScalarWhereInput
    data: XOR<campaign_itemsUpdateManyMutationInput, campaign_itemsUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type campaign_itemsScalarWhereInput = {
    AND?: campaign_itemsScalarWhereInput | campaign_itemsScalarWhereInput[]
    OR?: campaign_itemsScalarWhereInput[]
    NOT?: campaign_itemsScalarWhereInput | campaign_itemsScalarWhereInput[]
    id?: StringFilter<"campaign_items"> | string
    campaignId?: StringFilter<"campaign_items"> | string
    itemId?: StringFilter<"campaign_items"> | string
    itemType?: StringFilter<"campaign_items"> | string
    priority?: IntFilter<"campaign_items"> | number
    createdAt?: DateTimeFilter<"campaign_items"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_items"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_items"> | string | null
    is_deleted?: BoolFilter<"campaign_items"> | boolean
  }

  export type campaign_translationsUpsertWithWhereUniqueWithoutCampaignsInput = {
    where: campaign_translationsWhereUniqueInput
    update: XOR<campaign_translationsUpdateWithoutCampaignsInput, campaign_translationsUncheckedUpdateWithoutCampaignsInput>
    create: XOR<campaign_translationsCreateWithoutCampaignsInput, campaign_translationsUncheckedCreateWithoutCampaignsInput>
  }

  export type campaign_translationsUpdateWithWhereUniqueWithoutCampaignsInput = {
    where: campaign_translationsWhereUniqueInput
    data: XOR<campaign_translationsUpdateWithoutCampaignsInput, campaign_translationsUncheckedUpdateWithoutCampaignsInput>
  }

  export type campaign_translationsUpdateManyWithWhereWithoutCampaignsInput = {
    where: campaign_translationsScalarWhereInput
    data: XOR<campaign_translationsUpdateManyMutationInput, campaign_translationsUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type campaign_translationsScalarWhereInput = {
    AND?: campaign_translationsScalarWhereInput | campaign_translationsScalarWhereInput[]
    OR?: campaign_translationsScalarWhereInput[]
    NOT?: campaign_translationsScalarWhereInput | campaign_translationsScalarWhereInput[]
    id?: StringFilter<"campaign_translations"> | string
    campaignId?: StringFilter<"campaign_translations"> | string
    locale?: StringFilter<"campaign_translations"> | string
    title?: StringFilter<"campaign_translations"> | string
    description?: StringNullableFilter<"campaign_translations"> | string | null
    imageUrl?: StringNullableFilter<"campaign_translations"> | string | null
    languageCode?: StringNullableFilter<"campaign_translations"> | string | null
    name?: StringNullableFilter<"campaign_translations"> | string | null
    deleted_at?: DateTimeNullableFilter<"campaign_translations"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_translations"> | string | null
    is_deleted?: BoolFilter<"campaign_translations"> | boolean
  }

  export type campaign_usage_logsUpsertWithWhereUniqueWithoutCampaignsInput = {
    where: campaign_usage_logsWhereUniqueInput
    update: XOR<campaign_usage_logsUpdateWithoutCampaignsInput, campaign_usage_logsUncheckedUpdateWithoutCampaignsInput>
    create: XOR<campaign_usage_logsCreateWithoutCampaignsInput, campaign_usage_logsUncheckedCreateWithoutCampaignsInput>
  }

  export type campaign_usage_logsUpdateWithWhereUniqueWithoutCampaignsInput = {
    where: campaign_usage_logsWhereUniqueInput
    data: XOR<campaign_usage_logsUpdateWithoutCampaignsInput, campaign_usage_logsUncheckedUpdateWithoutCampaignsInput>
  }

  export type campaign_usage_logsUpdateManyWithWhereWithoutCampaignsInput = {
    where: campaign_usage_logsScalarWhereInput
    data: XOR<campaign_usage_logsUpdateManyMutationInput, campaign_usage_logsUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type campaign_usage_logsScalarWhereInput = {
    AND?: campaign_usage_logsScalarWhereInput | campaign_usage_logsScalarWhereInput[]
    OR?: campaign_usage_logsScalarWhereInput[]
    NOT?: campaign_usage_logsScalarWhereInput | campaign_usage_logsScalarWhereInput[]
    id?: StringFilter<"campaign_usage_logs"> | string
    campaignId?: StringFilter<"campaign_usage_logs"> | string
    userId?: StringNullableFilter<"campaign_usage_logs"> | string | null
    deviceId?: StringNullableFilter<"campaign_usage_logs"> | string | null
    action?: StringFilter<"campaign_usage_logs"> | string
    createdAt?: DateTimeFilter<"campaign_usage_logs"> | Date | string
    deleted_at?: DateTimeNullableFilter<"campaign_usage_logs"> | Date | string | null
    deleted_by?: StringNullableFilter<"campaign_usage_logs"> | string | null
    is_deleted?: BoolFilter<"campaign_usage_logs"> | boolean
  }

  export type reservationsCreateWithoutCustomersInput = {
    id: string
    tenant_id: string
    guest_name: string
    guest_phone?: string | null
    guest_email?: string | null
    checkin_date: Date | string
    checkout_date: Date | string
    adult_count?: number
    child_count?: number
    room_type: string
    room_number?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    deposit_amount?: Decimal | DecimalJsLike | number | string
    status?: string
    origin: string
    ota_id?: string | null
    confirmation_number: string
    special_requests?: string | null
    internal_notes?: string | null
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
  }

  export type reservationsUncheckedCreateWithoutCustomersInput = {
    id: string
    tenant_id: string
    guest_name: string
    guest_phone?: string | null
    guest_email?: string | null
    checkin_date: Date | string
    checkout_date: Date | string
    adult_count?: number
    child_count?: number
    room_type: string
    room_number?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    deposit_amount?: Decimal | DecimalJsLike | number | string
    status?: string
    origin: string
    ota_id?: string | null
    confirmation_number: string
    special_requests?: string | null
    internal_notes?: string | null
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
  }

  export type reservationsCreateOrConnectWithoutCustomersInput = {
    where: reservationsWhereUniqueInput
    create: XOR<reservationsCreateWithoutCustomersInput, reservationsUncheckedCreateWithoutCustomersInput>
  }

  export type reservationsCreateManyCustomersInputEnvelope = {
    data: reservationsCreateManyCustomersInput | reservationsCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type reservationsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: reservationsWhereUniqueInput
    update: XOR<reservationsUpdateWithoutCustomersInput, reservationsUncheckedUpdateWithoutCustomersInput>
    create: XOR<reservationsCreateWithoutCustomersInput, reservationsUncheckedCreateWithoutCustomersInput>
  }

  export type reservationsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: reservationsWhereUniqueInput
    data: XOR<reservationsUpdateWithoutCustomersInput, reservationsUncheckedUpdateWithoutCustomersInput>
  }

  export type reservationsUpdateManyWithWhereWithoutCustomersInput = {
    where: reservationsScalarWhereInput
    data: XOR<reservationsUpdateManyMutationInput, reservationsUncheckedUpdateManyWithoutCustomersInput>
  }

  export type reservationsScalarWhereInput = {
    AND?: reservationsScalarWhereInput | reservationsScalarWhereInput[]
    OR?: reservationsScalarWhereInput[]
    NOT?: reservationsScalarWhereInput | reservationsScalarWhereInput[]
    id?: StringFilter<"reservations"> | string
    tenant_id?: StringFilter<"reservations"> | string
    customer_id?: StringNullableFilter<"reservations"> | string | null
    guest_name?: StringFilter<"reservations"> | string
    guest_phone?: StringNullableFilter<"reservations"> | string | null
    guest_email?: StringNullableFilter<"reservations"> | string | null
    checkin_date?: DateTimeFilter<"reservations"> | Date | string
    checkout_date?: DateTimeFilter<"reservations"> | Date | string
    adult_count?: IntFilter<"reservations"> | number
    child_count?: IntFilter<"reservations"> | number
    room_type?: StringFilter<"reservations"> | string
    room_number?: StringNullableFilter<"reservations"> | string | null
    total_amount?: DecimalFilter<"reservations"> | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFilter<"reservations"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"reservations"> | string
    origin?: StringFilter<"reservations"> | string
    ota_id?: StringNullableFilter<"reservations"> | string | null
    confirmation_number?: StringFilter<"reservations"> | string
    special_requests?: StringNullableFilter<"reservations"> | string | null
    internal_notes?: StringNullableFilter<"reservations"> | string | null
    origin_system?: StringFilter<"reservations"> | string
    synced_at?: DateTimeFilter<"reservations"> | Date | string
    updated_by_system?: StringFilter<"reservations"> | string
    created_at?: DateTimeFilter<"reservations"> | Date | string
    updated_at?: DateTimeFilter<"reservations"> | Date | string
    deleted_at?: DateTimeNullableFilter<"reservations"> | Date | string | null
    is_deleted?: BoolFilter<"reservations"> | boolean
    deleted_by?: StringNullableFilter<"reservations"> | string | null
  }

  export type TenantCreateWithoutDevice_roomsInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanCreateNestedManyWithoutTenantInput
    pages?: pagesCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDevice_roomsInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanUncheckedCreateNestedManyWithoutTenantInput
    pages?: pagesUncheckedCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsUncheckedCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDevice_roomsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDevice_roomsInput, TenantUncheckedCreateWithoutDevice_roomsInput>
  }

  export type TenantUpsertWithoutDevice_roomsInput = {
    update: XOR<TenantUpdateWithoutDevice_roomsInput, TenantUncheckedUpdateWithoutDevice_roomsInput>
    create: XOR<TenantCreateWithoutDevice_roomsInput, TenantUncheckedCreateWithoutDevice_roomsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDevice_roomsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDevice_roomsInput, TenantUncheckedUpdateWithoutDevice_roomsInput>
  }

  export type TenantUpdateWithoutDevice_roomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUpdateManyWithoutTenantNestedInput
    pages?: pagesUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDevice_roomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUncheckedUpdateManyWithoutTenantNestedInput
    pages?: pagesUncheckedUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUncheckedUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type pagesCreateWithoutPage_historiesInput = {
    Id: string
    Slug: string
    Title: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    IsPublished?: boolean
    PublishedAt?: Date | string | null
    Version?: number
    CreatedAt?: Date | string
    UpdatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    Tenant: TenantCreateNestedOneWithoutPagesInput
  }

  export type pagesUncheckedCreateWithoutPage_historiesInput = {
    Id: string
    TenantId: string
    Slug: string
    Title: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    IsPublished?: boolean
    PublishedAt?: Date | string | null
    Version?: number
    CreatedAt?: Date | string
    UpdatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type pagesCreateOrConnectWithoutPage_historiesInput = {
    where: pagesWhereUniqueInput
    create: XOR<pagesCreateWithoutPage_historiesInput, pagesUncheckedCreateWithoutPage_historiesInput>
  }

  export type pagesUpsertWithoutPage_historiesInput = {
    update: XOR<pagesUpdateWithoutPage_historiesInput, pagesUncheckedUpdateWithoutPage_historiesInput>
    create: XOR<pagesCreateWithoutPage_historiesInput, pagesUncheckedCreateWithoutPage_historiesInput>
    where?: pagesWhereInput
  }

  export type pagesUpdateToOneWithWhereWithoutPage_historiesInput = {
    where?: pagesWhereInput
    data: XOR<pagesUpdateWithoutPage_historiesInput, pagesUncheckedUpdateWithoutPage_historiesInput>
  }

  export type pagesUpdateWithoutPage_historiesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    IsPublished?: BoolFieldUpdateOperationsInput | boolean
    PublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    Tenant?: TenantUpdateOneRequiredWithoutPagesNestedInput
  }

  export type pagesUncheckedUpdateWithoutPage_historiesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    TenantId?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    IsPublished?: BoolFieldUpdateOperationsInput | boolean
    PublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type page_historiesCreateWithoutPagesInput = {
    Id: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    Version: number
    CreatedAt?: Date | string
    CreatedBy?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type page_historiesUncheckedCreateWithoutPagesInput = {
    Id: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    Version: number
    CreatedAt?: Date | string
    CreatedBy?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type page_historiesCreateOrConnectWithoutPagesInput = {
    where: page_historiesWhereUniqueInput
    create: XOR<page_historiesCreateWithoutPagesInput, page_historiesUncheckedCreateWithoutPagesInput>
  }

  export type page_historiesCreateManyPagesInputEnvelope = {
    data: page_historiesCreateManyPagesInput | page_historiesCreateManyPagesInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutPagesInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanCreateNestedManyWithoutTenantInput
    device_rooms?: device_roomsCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPagesInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanUncheckedCreateNestedManyWithoutTenantInput
    device_rooms?: device_roomsUncheckedCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsUncheckedCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPagesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPagesInput, TenantUncheckedCreateWithoutPagesInput>
  }

  export type page_historiesUpsertWithWhereUniqueWithoutPagesInput = {
    where: page_historiesWhereUniqueInput
    update: XOR<page_historiesUpdateWithoutPagesInput, page_historiesUncheckedUpdateWithoutPagesInput>
    create: XOR<page_historiesCreateWithoutPagesInput, page_historiesUncheckedCreateWithoutPagesInput>
  }

  export type page_historiesUpdateWithWhereUniqueWithoutPagesInput = {
    where: page_historiesWhereUniqueInput
    data: XOR<page_historiesUpdateWithoutPagesInput, page_historiesUncheckedUpdateWithoutPagesInput>
  }

  export type page_historiesUpdateManyWithWhereWithoutPagesInput = {
    where: page_historiesScalarWhereInput
    data: XOR<page_historiesUpdateManyMutationInput, page_historiesUncheckedUpdateManyWithoutPagesInput>
  }

  export type page_historiesScalarWhereInput = {
    AND?: page_historiesScalarWhereInput | page_historiesScalarWhereInput[]
    OR?: page_historiesScalarWhereInput[]
    NOT?: page_historiesScalarWhereInput | page_historiesScalarWhereInput[]
    Id?: StringFilter<"page_histories"> | string
    PageId?: StringFilter<"page_histories"> | string
    Html?: StringNullableFilter<"page_histories"> | string | null
    Css?: StringNullableFilter<"page_histories"> | string | null
    Content?: StringNullableFilter<"page_histories"> | string | null
    Template?: StringNullableFilter<"page_histories"> | string | null
    Version?: IntFilter<"page_histories"> | number
    CreatedAt?: DateTimeFilter<"page_histories"> | Date | string
    CreatedBy?: StringNullableFilter<"page_histories"> | string | null
    deleted_at?: DateTimeNullableFilter<"page_histories"> | Date | string | null
    deleted_by?: StringNullableFilter<"page_histories"> | string | null
    is_deleted?: BoolFilter<"page_histories"> | boolean
  }

  export type TenantUpsertWithoutPagesInput = {
    update: XOR<TenantUpdateWithoutPagesInput, TenantUncheckedUpdateWithoutPagesInput>
    create: XOR<TenantCreateWithoutPagesInput, TenantUncheckedCreateWithoutPagesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPagesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPagesInput, TenantUncheckedUpdateWithoutPagesInput>
  }

  export type TenantUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUpdateManyWithoutTenantNestedInput
    device_rooms?: device_roomsUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUncheckedUpdateManyWithoutTenantNestedInput
    device_rooms?: device_roomsUncheckedUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUncheckedUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type customersCreateWithoutReservationsInput = {
    id: string
    tenant_id: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birth_date?: Date | string | null
    member_id?: string | null
    rank_id?: string | null
    total_points?: number
    total_stays?: number
    pms_updatable_fields?: customersCreatepms_updatable_fieldsInput | string[]
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
  }

  export type customersUncheckedCreateWithoutReservationsInput = {
    id: string
    tenant_id: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    birth_date?: Date | string | null
    member_id?: string | null
    rank_id?: string | null
    total_points?: number
    total_stays?: number
    pms_updatable_fields?: customersCreatepms_updatable_fieldsInput | string[]
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
  }

  export type customersCreateOrConnectWithoutReservationsInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutReservationsInput, customersUncheckedCreateWithoutReservationsInput>
  }

  export type customersUpsertWithoutReservationsInput = {
    update: XOR<customersUpdateWithoutReservationsInput, customersUncheckedUpdateWithoutReservationsInput>
    create: XOR<customersCreateWithoutReservationsInput, customersUncheckedCreateWithoutReservationsInput>
    where?: customersWhereInput
  }

  export type customersUpdateToOneWithWhereWithoutReservationsInput = {
    where?: customersWhereInput
    data: XOR<customersUpdateWithoutReservationsInput, customersUncheckedUpdateWithoutReservationsInput>
  }

  export type customersUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member_id?: NullableStringFieldUpdateOperationsInput | string | null
    rank_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    total_stays?: IntFieldUpdateOperationsInput | number
    pms_updatable_fields?: customersUpdatepms_updatable_fieldsInput | string[]
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customersUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    member_id?: NullableStringFieldUpdateOperationsInput | string | null
    rank_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_points?: IntFieldUpdateOperationsInput | number
    total_stays?: IntFieldUpdateOperationsInput | number
    pms_updatable_fields?: customersUpdatepms_updatable_fieldsInput | string[]
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type response_nodesCreateWithoutResponse_node_translationsInput = {
    id: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_nodes?: response_nodesCreateNestedOneWithoutOther_response_nodesInput
    other_response_nodes?: response_nodesCreateNestedManyWithoutResponse_nodesInput
    response_trees: response_treesCreateNestedOneWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesUncheckedCreateWithoutResponse_node_translationsInput = {
    id: string
    treeId: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    parentId?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    other_response_nodes?: response_nodesUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesCreateOrConnectWithoutResponse_node_translationsInput = {
    where: response_nodesWhereUniqueInput
    create: XOR<response_nodesCreateWithoutResponse_node_translationsInput, response_nodesUncheckedCreateWithoutResponse_node_translationsInput>
  }

  export type response_nodesUpsertWithoutResponse_node_translationsInput = {
    update: XOR<response_nodesUpdateWithoutResponse_node_translationsInput, response_nodesUncheckedUpdateWithoutResponse_node_translationsInput>
    create: XOR<response_nodesCreateWithoutResponse_node_translationsInput, response_nodesUncheckedCreateWithoutResponse_node_translationsInput>
    where?: response_nodesWhereInput
  }

  export type response_nodesUpdateToOneWithWhereWithoutResponse_node_translationsInput = {
    where?: response_nodesWhereInput
    data: XOR<response_nodesUpdateWithoutResponse_node_translationsInput, response_nodesUncheckedUpdateWithoutResponse_node_translationsInput>
  }

  export type response_nodesUpdateWithoutResponse_node_translationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_nodes?: response_nodesUpdateOneWithoutOther_response_nodesNestedInput
    other_response_nodes?: response_nodesUpdateManyWithoutResponse_nodesNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUncheckedUpdateWithoutResponse_node_translationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    other_response_nodes?: response_nodesUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUncheckedUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_node_translationsCreateWithoutResponse_nodesInput = {
    id: string
    locale: string
    content?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    title?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type response_node_translationsUncheckedCreateWithoutResponse_nodesInput = {
    id: string
    locale: string
    content?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    title?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type response_node_translationsCreateOrConnectWithoutResponse_nodesInput = {
    where: response_node_translationsWhereUniqueInput
    create: XOR<response_node_translationsCreateWithoutResponse_nodesInput, response_node_translationsUncheckedCreateWithoutResponse_nodesInput>
  }

  export type response_node_translationsCreateManyResponse_nodesInputEnvelope = {
    data: response_node_translationsCreateManyResponse_nodesInput | response_node_translationsCreateManyResponse_nodesInput[]
    skipDuplicates?: boolean
  }

  export type response_nodesCreateWithoutOther_response_nodesInput = {
    id: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsCreateNestedManyWithoutResponse_nodesInput
    response_nodes?: response_nodesCreateNestedOneWithoutOther_response_nodesInput
    response_trees: response_treesCreateNestedOneWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesUncheckedCreateWithoutOther_response_nodesInput = {
    id: string
    treeId: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    parentId?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesCreateOrConnectWithoutOther_response_nodesInput = {
    where: response_nodesWhereUniqueInput
    create: XOR<response_nodesCreateWithoutOther_response_nodesInput, response_nodesUncheckedCreateWithoutOther_response_nodesInput>
  }

  export type response_nodesCreateWithoutResponse_nodesInput = {
    id: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsCreateNestedManyWithoutResponse_nodesInput
    other_response_nodes?: response_nodesCreateNestedManyWithoutResponse_nodesInput
    response_trees: response_treesCreateNestedOneWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesUncheckedCreateWithoutResponse_nodesInput = {
    id: string
    treeId: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsUncheckedCreateNestedManyWithoutResponse_nodesInput
    other_response_nodes?: response_nodesUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesCreateOrConnectWithoutResponse_nodesInput = {
    where: response_nodesWhereUniqueInput
    create: XOR<response_nodesCreateWithoutResponse_nodesInput, response_nodesUncheckedCreateWithoutResponse_nodesInput>
  }

  export type response_nodesCreateManyResponse_nodesInputEnvelope = {
    data: response_nodesCreateManyResponse_nodesInput | response_nodesCreateManyResponse_nodesInput[]
    skipDuplicates?: boolean
  }

  export type response_treesCreateWithoutResponse_nodesInput = {
    id: string
    tenantId: string
    name: string
    description?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt: Date | string
    isActive?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    response_tree_sessions?: response_tree_sessionsCreateNestedManyWithoutResponse_treesInput
    response_tree_versions?: response_tree_versionsCreateNestedManyWithoutResponse_treesInput
  }

  export type response_treesUncheckedCreateWithoutResponse_nodesInput = {
    id: string
    tenantId: string
    name: string
    description?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt: Date | string
    isActive?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    response_tree_sessions?: response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_treesInput
    response_tree_versions?: response_tree_versionsUncheckedCreateNestedManyWithoutResponse_treesInput
  }

  export type response_treesCreateOrConnectWithoutResponse_nodesInput = {
    where: response_treesWhereUniqueInput
    create: XOR<response_treesCreateWithoutResponse_nodesInput, response_treesUncheckedCreateWithoutResponse_nodesInput>
  }

  export type response_tree_historyCreateWithoutResponse_nodesInput = {
    id: string
    response?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    action?: string | null
    timestamp?: Date | string
    response_tree_sessions: response_tree_sessionsCreateNestedOneWithoutResponse_tree_historyInput
  }

  export type response_tree_historyUncheckedCreateWithoutResponse_nodesInput = {
    id: string
    sessionId: string
    response?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    action?: string | null
    timestamp?: Date | string
  }

  export type response_tree_historyCreateOrConnectWithoutResponse_nodesInput = {
    where: response_tree_historyWhereUniqueInput
    create: XOR<response_tree_historyCreateWithoutResponse_nodesInput, response_tree_historyUncheckedCreateWithoutResponse_nodesInput>
  }

  export type response_tree_historyCreateManyResponse_nodesInputEnvelope = {
    data: response_tree_historyCreateManyResponse_nodesInput | response_tree_historyCreateManyResponse_nodesInput[]
    skipDuplicates?: boolean
  }

  export type response_tree_sessionsCreateWithoutResponse_nodesInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_tree_sessionsInput
    response_tree_mobile_links?: response_tree_mobile_linksCreateNestedManyWithoutResponse_tree_sessionsInput
    response_trees: response_treesCreateNestedOneWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput = {
    id: string
    treeId: string
    userId?: string | null
    deviceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput
    response_tree_mobile_links?: response_tree_mobile_linksUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsCreateOrConnectWithoutResponse_nodesInput = {
    where: response_tree_sessionsWhereUniqueInput
    create: XOR<response_tree_sessionsCreateWithoutResponse_nodesInput, response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput>
  }

  export type response_tree_sessionsCreateManyResponse_nodesInputEnvelope = {
    data: response_tree_sessionsCreateManyResponse_nodesInput | response_tree_sessionsCreateManyResponse_nodesInput[]
    skipDuplicates?: boolean
  }

  export type response_node_translationsUpsertWithWhereUniqueWithoutResponse_nodesInput = {
    where: response_node_translationsWhereUniqueInput
    update: XOR<response_node_translationsUpdateWithoutResponse_nodesInput, response_node_translationsUncheckedUpdateWithoutResponse_nodesInput>
    create: XOR<response_node_translationsCreateWithoutResponse_nodesInput, response_node_translationsUncheckedCreateWithoutResponse_nodesInput>
  }

  export type response_node_translationsUpdateWithWhereUniqueWithoutResponse_nodesInput = {
    where: response_node_translationsWhereUniqueInput
    data: XOR<response_node_translationsUpdateWithoutResponse_nodesInput, response_node_translationsUncheckedUpdateWithoutResponse_nodesInput>
  }

  export type response_node_translationsUpdateManyWithWhereWithoutResponse_nodesInput = {
    where: response_node_translationsScalarWhereInput
    data: XOR<response_node_translationsUpdateManyMutationInput, response_node_translationsUncheckedUpdateManyWithoutResponse_nodesInput>
  }

  export type response_node_translationsScalarWhereInput = {
    AND?: response_node_translationsScalarWhereInput | response_node_translationsScalarWhereInput[]
    OR?: response_node_translationsScalarWhereInput[]
    NOT?: response_node_translationsScalarWhereInput | response_node_translationsScalarWhereInput[]
    id?: StringFilter<"response_node_translations"> | string
    nodeId?: StringFilter<"response_node_translations"> | string
    locale?: StringFilter<"response_node_translations"> | string
    content?: StringNullableFilter<"response_node_translations"> | string | null
    createdAt?: DateTimeFilter<"response_node_translations"> | Date | string
    updatedAt?: DateTimeFilter<"response_node_translations"> | Date | string
    answer?: JsonNullableFilter<"response_node_translations">
    language?: StringNullableFilter<"response_node_translations"> | string | null
    title?: StringNullableFilter<"response_node_translations"> | string | null
    deleted_at?: DateTimeNullableFilter<"response_node_translations"> | Date | string | null
    deleted_by?: StringNullableFilter<"response_node_translations"> | string | null
    is_deleted?: BoolFilter<"response_node_translations"> | boolean
  }

  export type response_nodesUpsertWithoutOther_response_nodesInput = {
    update: XOR<response_nodesUpdateWithoutOther_response_nodesInput, response_nodesUncheckedUpdateWithoutOther_response_nodesInput>
    create: XOR<response_nodesCreateWithoutOther_response_nodesInput, response_nodesUncheckedCreateWithoutOther_response_nodesInput>
    where?: response_nodesWhereInput
  }

  export type response_nodesUpdateToOneWithWhereWithoutOther_response_nodesInput = {
    where?: response_nodesWhereInput
    data: XOR<response_nodesUpdateWithoutOther_response_nodesInput, response_nodesUncheckedUpdateWithoutOther_response_nodesInput>
  }

  export type response_nodesUpdateWithoutOther_response_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUpdateManyWithoutResponse_nodesNestedInput
    response_nodes?: response_nodesUpdateOneWithoutOther_response_nodesNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUncheckedUpdateWithoutOther_response_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUncheckedUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUpsertWithWhereUniqueWithoutResponse_nodesInput = {
    where: response_nodesWhereUniqueInput
    update: XOR<response_nodesUpdateWithoutResponse_nodesInput, response_nodesUncheckedUpdateWithoutResponse_nodesInput>
    create: XOR<response_nodesCreateWithoutResponse_nodesInput, response_nodesUncheckedCreateWithoutResponse_nodesInput>
  }

  export type response_nodesUpdateWithWhereUniqueWithoutResponse_nodesInput = {
    where: response_nodesWhereUniqueInput
    data: XOR<response_nodesUpdateWithoutResponse_nodesInput, response_nodesUncheckedUpdateWithoutResponse_nodesInput>
  }

  export type response_nodesUpdateManyWithWhereWithoutResponse_nodesInput = {
    where: response_nodesScalarWhereInput
    data: XOR<response_nodesUpdateManyMutationInput, response_nodesUncheckedUpdateManyWithoutResponse_nodesInput>
  }

  export type response_nodesScalarWhereInput = {
    AND?: response_nodesScalarWhereInput | response_nodesScalarWhereInput[]
    OR?: response_nodesScalarWhereInput[]
    NOT?: response_nodesScalarWhereInput | response_nodesScalarWhereInput[]
    id?: StringFilter<"response_nodes"> | string
    treeId?: StringFilter<"response_nodes"> | string
    nodeType?: StringFilter<"response_nodes"> | string
    content?: StringNullableFilter<"response_nodes"> | string | null
    metadata?: JsonNullableFilter<"response_nodes">
    isRoot?: BoolFilter<"response_nodes"> | boolean
    parentId?: StringNullableFilter<"response_nodes"> | string | null
    position?: IntFilter<"response_nodes"> | number
    createdAt?: DateTimeFilter<"response_nodes"> | Date | string
    updatedAt?: DateTimeFilter<"response_nodes"> | Date | string
    answer?: JsonNullableFilter<"response_nodes">
    description?: StringNullableFilter<"response_nodes"> | string | null
    icon?: StringNullableFilter<"response_nodes"> | string | null
    order?: IntFilter<"response_nodes"> | number
    title?: StringNullableFilter<"response_nodes"> | string | null
    type?: StringNullableFilter<"response_nodes"> | string | null
  }

  export type response_treesUpsertWithoutResponse_nodesInput = {
    update: XOR<response_treesUpdateWithoutResponse_nodesInput, response_treesUncheckedUpdateWithoutResponse_nodesInput>
    create: XOR<response_treesCreateWithoutResponse_nodesInput, response_treesUncheckedCreateWithoutResponse_nodesInput>
    where?: response_treesWhereInput
  }

  export type response_treesUpdateToOneWithWhereWithoutResponse_nodesInput = {
    where?: response_treesWhereInput
    data: XOR<response_treesUpdateWithoutResponse_nodesInput, response_treesUncheckedUpdateWithoutResponse_nodesInput>
  }

  export type response_treesUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    response_tree_sessions?: response_tree_sessionsUpdateManyWithoutResponse_treesNestedInput
    response_tree_versions?: response_tree_versionsUpdateManyWithoutResponse_treesNestedInput
  }

  export type response_treesUncheckedUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    response_tree_sessions?: response_tree_sessionsUncheckedUpdateManyWithoutResponse_treesNestedInput
    response_tree_versions?: response_tree_versionsUncheckedUpdateManyWithoutResponse_treesNestedInput
  }

  export type response_tree_historyUpsertWithWhereUniqueWithoutResponse_nodesInput = {
    where: response_tree_historyWhereUniqueInput
    update: XOR<response_tree_historyUpdateWithoutResponse_nodesInput, response_tree_historyUncheckedUpdateWithoutResponse_nodesInput>
    create: XOR<response_tree_historyCreateWithoutResponse_nodesInput, response_tree_historyUncheckedCreateWithoutResponse_nodesInput>
  }

  export type response_tree_historyUpdateWithWhereUniqueWithoutResponse_nodesInput = {
    where: response_tree_historyWhereUniqueInput
    data: XOR<response_tree_historyUpdateWithoutResponse_nodesInput, response_tree_historyUncheckedUpdateWithoutResponse_nodesInput>
  }

  export type response_tree_historyUpdateManyWithWhereWithoutResponse_nodesInput = {
    where: response_tree_historyScalarWhereInput
    data: XOR<response_tree_historyUpdateManyMutationInput, response_tree_historyUncheckedUpdateManyWithoutResponse_nodesInput>
  }

  export type response_tree_historyScalarWhereInput = {
    AND?: response_tree_historyScalarWhereInput | response_tree_historyScalarWhereInput[]
    OR?: response_tree_historyScalarWhereInput[]
    NOT?: response_tree_historyScalarWhereInput | response_tree_historyScalarWhereInput[]
    id?: StringFilter<"response_tree_history"> | string
    sessionId?: StringFilter<"response_tree_history"> | string
    nodeId?: StringFilter<"response_tree_history"> | string
    response?: StringNullableFilter<"response_tree_history"> | string | null
    metadata?: JsonNullableFilter<"response_tree_history">
    createdAt?: DateTimeFilter<"response_tree_history"> | Date | string
    action?: StringNullableFilter<"response_tree_history"> | string | null
    timestamp?: DateTimeFilter<"response_tree_history"> | Date | string
  }

  export type response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_nodesInput = {
    where: response_tree_sessionsWhereUniqueInput
    update: XOR<response_tree_sessionsUpdateWithoutResponse_nodesInput, response_tree_sessionsUncheckedUpdateWithoutResponse_nodesInput>
    create: XOR<response_tree_sessionsCreateWithoutResponse_nodesInput, response_tree_sessionsUncheckedCreateWithoutResponse_nodesInput>
  }

  export type response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_nodesInput = {
    where: response_tree_sessionsWhereUniqueInput
    data: XOR<response_tree_sessionsUpdateWithoutResponse_nodesInput, response_tree_sessionsUncheckedUpdateWithoutResponse_nodesInput>
  }

  export type response_tree_sessionsUpdateManyWithWhereWithoutResponse_nodesInput = {
    where: response_tree_sessionsScalarWhereInput
    data: XOR<response_tree_sessionsUpdateManyMutationInput, response_tree_sessionsUncheckedUpdateManyWithoutResponse_nodesInput>
  }

  export type response_tree_sessionsScalarWhereInput = {
    AND?: response_tree_sessionsScalarWhereInput | response_tree_sessionsScalarWhereInput[]
    OR?: response_tree_sessionsScalarWhereInput[]
    NOT?: response_tree_sessionsScalarWhereInput | response_tree_sessionsScalarWhereInput[]
    id?: StringFilter<"response_tree_sessions"> | string
    treeId?: StringFilter<"response_tree_sessions"> | string
    userId?: StringNullableFilter<"response_tree_sessions"> | string | null
    deviceId?: StringNullableFilter<"response_tree_sessions"> | string | null
    currentNodeId?: StringNullableFilter<"response_tree_sessions"> | string | null
    metadata?: JsonNullableFilter<"response_tree_sessions">
    isComplete?: BoolFilter<"response_tree_sessions"> | boolean
    startedAt?: DateTimeFilter<"response_tree_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"response_tree_sessions"> | Date | string
    completedAt?: DateTimeNullableFilter<"response_tree_sessions"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"response_tree_sessions"> | Date | string | null
    interfaceType?: StringNullableFilter<"response_tree_sessions"> | string | null
    language?: StringNullableFilter<"response_tree_sessions"> | string | null
    lastActivityAt?: DateTimeNullableFilter<"response_tree_sessions"> | Date | string | null
    roomId?: StringNullableFilter<"response_tree_sessions"> | string | null
    sessionId?: StringFilter<"response_tree_sessions"> | string
  }

  export type response_nodesCreateWithoutResponse_tree_historyInput = {
    id: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsCreateNestedManyWithoutResponse_nodesInput
    response_nodes?: response_nodesCreateNestedOneWithoutOther_response_nodesInput
    other_response_nodes?: response_nodesCreateNestedManyWithoutResponse_nodesInput
    response_trees: response_treesCreateNestedOneWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesUncheckedCreateWithoutResponse_tree_historyInput = {
    id: string
    treeId: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    parentId?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsUncheckedCreateNestedManyWithoutResponse_nodesInput
    other_response_nodes?: response_nodesUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesCreateOrConnectWithoutResponse_tree_historyInput = {
    where: response_nodesWhereUniqueInput
    create: XOR<response_nodesCreateWithoutResponse_tree_historyInput, response_nodesUncheckedCreateWithoutResponse_tree_historyInput>
  }

  export type response_tree_sessionsCreateWithoutResponse_tree_historyInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_mobile_links?: response_tree_mobile_linksCreateNestedManyWithoutResponse_tree_sessionsInput
    response_nodes?: response_nodesCreateNestedOneWithoutResponse_tree_sessionsInput
    response_trees: response_treesCreateNestedOneWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsUncheckedCreateWithoutResponse_tree_historyInput = {
    id: string
    treeId: string
    userId?: string | null
    deviceId?: string | null
    currentNodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_mobile_links?: response_tree_mobile_linksUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsCreateOrConnectWithoutResponse_tree_historyInput = {
    where: response_tree_sessionsWhereUniqueInput
    create: XOR<response_tree_sessionsCreateWithoutResponse_tree_historyInput, response_tree_sessionsUncheckedCreateWithoutResponse_tree_historyInput>
  }

  export type response_nodesUpsertWithoutResponse_tree_historyInput = {
    update: XOR<response_nodesUpdateWithoutResponse_tree_historyInput, response_nodesUncheckedUpdateWithoutResponse_tree_historyInput>
    create: XOR<response_nodesCreateWithoutResponse_tree_historyInput, response_nodesUncheckedCreateWithoutResponse_tree_historyInput>
    where?: response_nodesWhereInput
  }

  export type response_nodesUpdateToOneWithWhereWithoutResponse_tree_historyInput = {
    where?: response_nodesWhereInput
    data: XOR<response_nodesUpdateWithoutResponse_tree_historyInput, response_nodesUncheckedUpdateWithoutResponse_tree_historyInput>
  }

  export type response_nodesUpdateWithoutResponse_tree_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUpdateManyWithoutResponse_nodesNestedInput
    response_nodes?: response_nodesUpdateOneWithoutOther_response_nodesNestedInput
    other_response_nodes?: response_nodesUpdateManyWithoutResponse_nodesNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUncheckedUpdateWithoutResponse_tree_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUncheckedUpdateManyWithoutResponse_nodesNestedInput
    other_response_nodes?: response_nodesUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUncheckedUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_tree_sessionsUpsertWithoutResponse_tree_historyInput = {
    update: XOR<response_tree_sessionsUpdateWithoutResponse_tree_historyInput, response_tree_sessionsUncheckedUpdateWithoutResponse_tree_historyInput>
    create: XOR<response_tree_sessionsCreateWithoutResponse_tree_historyInput, response_tree_sessionsUncheckedCreateWithoutResponse_tree_historyInput>
    where?: response_tree_sessionsWhereInput
  }

  export type response_tree_sessionsUpdateToOneWithWhereWithoutResponse_tree_historyInput = {
    where?: response_tree_sessionsWhereInput
    data: XOR<response_tree_sessionsUpdateWithoutResponse_tree_historyInput, response_tree_sessionsUncheckedUpdateWithoutResponse_tree_historyInput>
  }

  export type response_tree_sessionsUpdateWithoutResponse_tree_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_mobile_links?: response_tree_mobile_linksUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_nodes?: response_nodesUpdateOneWithoutResponse_tree_sessionsNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_sessionsUncheckedUpdateWithoutResponse_tree_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_mobile_links?: response_tree_mobile_linksUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_sessionsCreateWithoutResponse_tree_mobile_linksInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_tree_sessionsInput
    response_nodes?: response_nodesCreateNestedOneWithoutResponse_tree_sessionsInput
    response_trees: response_treesCreateNestedOneWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsUncheckedCreateWithoutResponse_tree_mobile_linksInput = {
    id: string
    treeId: string
    userId?: string | null
    deviceId?: string | null
    currentNodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsCreateOrConnectWithoutResponse_tree_mobile_linksInput = {
    where: response_tree_sessionsWhereUniqueInput
    create: XOR<response_tree_sessionsCreateWithoutResponse_tree_mobile_linksInput, response_tree_sessionsUncheckedCreateWithoutResponse_tree_mobile_linksInput>
  }

  export type response_tree_sessionsUpsertWithoutResponse_tree_mobile_linksInput = {
    update: XOR<response_tree_sessionsUpdateWithoutResponse_tree_mobile_linksInput, response_tree_sessionsUncheckedUpdateWithoutResponse_tree_mobile_linksInput>
    create: XOR<response_tree_sessionsCreateWithoutResponse_tree_mobile_linksInput, response_tree_sessionsUncheckedCreateWithoutResponse_tree_mobile_linksInput>
    where?: response_tree_sessionsWhereInput
  }

  export type response_tree_sessionsUpdateToOneWithWhereWithoutResponse_tree_mobile_linksInput = {
    where?: response_tree_sessionsWhereInput
    data: XOR<response_tree_sessionsUpdateWithoutResponse_tree_mobile_linksInput, response_tree_sessionsUncheckedUpdateWithoutResponse_tree_mobile_linksInput>
  }

  export type response_tree_sessionsUpdateWithoutResponse_tree_mobile_linksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_nodes?: response_nodesUpdateOneWithoutResponse_tree_sessionsNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_sessionsUncheckedUpdateWithoutResponse_tree_mobile_linksInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_historyCreateWithoutResponse_tree_sessionsInput = {
    id: string
    response?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    action?: string | null
    timestamp?: Date | string
    response_nodes: response_nodesCreateNestedOneWithoutResponse_tree_historyInput
  }

  export type response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput = {
    id: string
    nodeId: string
    response?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    action?: string | null
    timestamp?: Date | string
  }

  export type response_tree_historyCreateOrConnectWithoutResponse_tree_sessionsInput = {
    where: response_tree_historyWhereUniqueInput
    create: XOR<response_tree_historyCreateWithoutResponse_tree_sessionsInput, response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_historyCreateManyResponse_tree_sessionsInputEnvelope = {
    data: response_tree_historyCreateManyResponse_tree_sessionsInput | response_tree_historyCreateManyResponse_tree_sessionsInput[]
    skipDuplicates?: boolean
  }

  export type response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput = {
    id: string
    code: string
    qrCodeData?: string | null
    isActive?: boolean
    connectionId?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    connectedAt?: Date | string | null
    deviceId?: number | null
  }

  export type response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput = {
    id: string
    code: string
    qrCodeData?: string | null
    isActive?: boolean
    connectionId?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    connectedAt?: Date | string | null
    deviceId?: number | null
  }

  export type response_tree_mobile_linksCreateOrConnectWithoutResponse_tree_sessionsInput = {
    where: response_tree_mobile_linksWhereUniqueInput
    create: XOR<response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput, response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_mobile_linksCreateManyResponse_tree_sessionsInputEnvelope = {
    data: response_tree_mobile_linksCreateManyResponse_tree_sessionsInput | response_tree_mobile_linksCreateManyResponse_tree_sessionsInput[]
    skipDuplicates?: boolean
  }

  export type response_nodesCreateWithoutResponse_tree_sessionsInput = {
    id: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsCreateNestedManyWithoutResponse_nodesInput
    response_nodes?: response_nodesCreateNestedOneWithoutOther_response_nodesInput
    other_response_nodes?: response_nodesCreateNestedManyWithoutResponse_nodesInput
    response_trees: response_treesCreateNestedOneWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesUncheckedCreateWithoutResponse_tree_sessionsInput = {
    id: string
    treeId: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    parentId?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsUncheckedCreateNestedManyWithoutResponse_nodesInput
    other_response_nodes?: response_nodesUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesCreateOrConnectWithoutResponse_tree_sessionsInput = {
    where: response_nodesWhereUniqueInput
    create: XOR<response_nodesCreateWithoutResponse_tree_sessionsInput, response_nodesUncheckedCreateWithoutResponse_tree_sessionsInput>
  }

  export type response_treesCreateWithoutResponse_tree_sessionsInput = {
    id: string
    tenantId: string
    name: string
    description?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt: Date | string
    isActive?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    response_nodes?: response_nodesCreateNestedManyWithoutResponse_treesInput
    response_tree_versions?: response_tree_versionsCreateNestedManyWithoutResponse_treesInput
  }

  export type response_treesUncheckedCreateWithoutResponse_tree_sessionsInput = {
    id: string
    tenantId: string
    name: string
    description?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt: Date | string
    isActive?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    response_nodes?: response_nodesUncheckedCreateNestedManyWithoutResponse_treesInput
    response_tree_versions?: response_tree_versionsUncheckedCreateNestedManyWithoutResponse_treesInput
  }

  export type response_treesCreateOrConnectWithoutResponse_tree_sessionsInput = {
    where: response_treesWhereUniqueInput
    create: XOR<response_treesCreateWithoutResponse_tree_sessionsInput, response_treesUncheckedCreateWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_historyUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput = {
    where: response_tree_historyWhereUniqueInput
    update: XOR<response_tree_historyUpdateWithoutResponse_tree_sessionsInput, response_tree_historyUncheckedUpdateWithoutResponse_tree_sessionsInput>
    create: XOR<response_tree_historyCreateWithoutResponse_tree_sessionsInput, response_tree_historyUncheckedCreateWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_historyUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput = {
    where: response_tree_historyWhereUniqueInput
    data: XOR<response_tree_historyUpdateWithoutResponse_tree_sessionsInput, response_tree_historyUncheckedUpdateWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_historyUpdateManyWithWhereWithoutResponse_tree_sessionsInput = {
    where: response_tree_historyScalarWhereInput
    data: XOR<response_tree_historyUpdateManyMutationInput, response_tree_historyUncheckedUpdateManyWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_mobile_linksUpsertWithWhereUniqueWithoutResponse_tree_sessionsInput = {
    where: response_tree_mobile_linksWhereUniqueInput
    update: XOR<response_tree_mobile_linksUpdateWithoutResponse_tree_sessionsInput, response_tree_mobile_linksUncheckedUpdateWithoutResponse_tree_sessionsInput>
    create: XOR<response_tree_mobile_linksCreateWithoutResponse_tree_sessionsInput, response_tree_mobile_linksUncheckedCreateWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_mobile_linksUpdateWithWhereUniqueWithoutResponse_tree_sessionsInput = {
    where: response_tree_mobile_linksWhereUniqueInput
    data: XOR<response_tree_mobile_linksUpdateWithoutResponse_tree_sessionsInput, response_tree_mobile_linksUncheckedUpdateWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_mobile_linksUpdateManyWithWhereWithoutResponse_tree_sessionsInput = {
    where: response_tree_mobile_linksScalarWhereInput
    data: XOR<response_tree_mobile_linksUpdateManyMutationInput, response_tree_mobile_linksUncheckedUpdateManyWithoutResponse_tree_sessionsInput>
  }

  export type response_tree_mobile_linksScalarWhereInput = {
    AND?: response_tree_mobile_linksScalarWhereInput | response_tree_mobile_linksScalarWhereInput[]
    OR?: response_tree_mobile_linksScalarWhereInput[]
    NOT?: response_tree_mobile_linksScalarWhereInput | response_tree_mobile_linksScalarWhereInput[]
    id?: StringFilter<"response_tree_mobile_links"> | string
    sessionId?: StringFilter<"response_tree_mobile_links"> | string
    code?: StringFilter<"response_tree_mobile_links"> | string
    qrCodeData?: StringNullableFilter<"response_tree_mobile_links"> | string | null
    isActive?: BoolFilter<"response_tree_mobile_links"> | boolean
    connectionId?: StringNullableFilter<"response_tree_mobile_links"> | string | null
    createdAt?: DateTimeFilter<"response_tree_mobile_links"> | Date | string
    expiresAt?: DateTimeFilter<"response_tree_mobile_links"> | Date | string
    connectedAt?: DateTimeNullableFilter<"response_tree_mobile_links"> | Date | string | null
    deviceId?: IntNullableFilter<"response_tree_mobile_links"> | number | null
  }

  export type response_nodesUpsertWithoutResponse_tree_sessionsInput = {
    update: XOR<response_nodesUpdateWithoutResponse_tree_sessionsInput, response_nodesUncheckedUpdateWithoutResponse_tree_sessionsInput>
    create: XOR<response_nodesCreateWithoutResponse_tree_sessionsInput, response_nodesUncheckedCreateWithoutResponse_tree_sessionsInput>
    where?: response_nodesWhereInput
  }

  export type response_nodesUpdateToOneWithWhereWithoutResponse_tree_sessionsInput = {
    where?: response_nodesWhereInput
    data: XOR<response_nodesUpdateWithoutResponse_tree_sessionsInput, response_nodesUncheckedUpdateWithoutResponse_tree_sessionsInput>
  }

  export type response_nodesUpdateWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUpdateManyWithoutResponse_nodesNestedInput
    response_nodes?: response_nodesUpdateOneWithoutOther_response_nodesNestedInput
    other_response_nodes?: response_nodesUpdateManyWithoutResponse_nodesNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUncheckedUpdateWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUncheckedUpdateManyWithoutResponse_nodesNestedInput
    other_response_nodes?: response_nodesUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_treesUpsertWithoutResponse_tree_sessionsInput = {
    update: XOR<response_treesUpdateWithoutResponse_tree_sessionsInput, response_treesUncheckedUpdateWithoutResponse_tree_sessionsInput>
    create: XOR<response_treesCreateWithoutResponse_tree_sessionsInput, response_treesUncheckedCreateWithoutResponse_tree_sessionsInput>
    where?: response_treesWhereInput
  }

  export type response_treesUpdateToOneWithWhereWithoutResponse_tree_sessionsInput = {
    where?: response_treesWhereInput
    data: XOR<response_treesUpdateWithoutResponse_tree_sessionsInput, response_treesUncheckedUpdateWithoutResponse_tree_sessionsInput>
  }

  export type response_treesUpdateWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    response_nodes?: response_nodesUpdateManyWithoutResponse_treesNestedInput
    response_tree_versions?: response_tree_versionsUpdateManyWithoutResponse_treesNestedInput
  }

  export type response_treesUncheckedUpdateWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    response_nodes?: response_nodesUncheckedUpdateManyWithoutResponse_treesNestedInput
    response_tree_versions?: response_tree_versionsUncheckedUpdateManyWithoutResponse_treesNestedInput
  }

  export type response_treesCreateWithoutResponse_tree_versionsInput = {
    id: string
    tenantId: string
    name: string
    description?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt: Date | string
    isActive?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    response_nodes?: response_nodesCreateNestedManyWithoutResponse_treesInput
    response_tree_sessions?: response_tree_sessionsCreateNestedManyWithoutResponse_treesInput
  }

  export type response_treesUncheckedCreateWithoutResponse_tree_versionsInput = {
    id: string
    tenantId: string
    name: string
    description?: string | null
    isPublished?: boolean
    publishedAt?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt: Date | string
    isActive?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
    response_nodes?: response_nodesUncheckedCreateNestedManyWithoutResponse_treesInput
    response_tree_sessions?: response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_treesInput
  }

  export type response_treesCreateOrConnectWithoutResponse_tree_versionsInput = {
    where: response_treesWhereUniqueInput
    create: XOR<response_treesCreateWithoutResponse_tree_versionsInput, response_treesUncheckedCreateWithoutResponse_tree_versionsInput>
  }

  export type response_treesUpsertWithoutResponse_tree_versionsInput = {
    update: XOR<response_treesUpdateWithoutResponse_tree_versionsInput, response_treesUncheckedUpdateWithoutResponse_tree_versionsInput>
    create: XOR<response_treesCreateWithoutResponse_tree_versionsInput, response_treesUncheckedCreateWithoutResponse_tree_versionsInput>
    where?: response_treesWhereInput
  }

  export type response_treesUpdateToOneWithWhereWithoutResponse_tree_versionsInput = {
    where?: response_treesWhereInput
    data: XOR<response_treesUpdateWithoutResponse_tree_versionsInput, response_treesUncheckedUpdateWithoutResponse_tree_versionsInput>
  }

  export type response_treesUpdateWithoutResponse_tree_versionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    response_nodes?: response_nodesUpdateManyWithoutResponse_treesNestedInput
    response_tree_sessions?: response_tree_sessionsUpdateManyWithoutResponse_treesNestedInput
  }

  export type response_treesUncheckedUpdateWithoutResponse_tree_versionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    response_nodes?: response_nodesUncheckedUpdateManyWithoutResponse_treesNestedInput
    response_tree_sessions?: response_tree_sessionsUncheckedUpdateManyWithoutResponse_treesNestedInput
  }

  export type response_nodesCreateWithoutResponse_treesInput = {
    id: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsCreateNestedManyWithoutResponse_nodesInput
    response_nodes?: response_nodesCreateNestedOneWithoutOther_response_nodesInput
    other_response_nodes?: response_nodesCreateNestedManyWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesUncheckedCreateWithoutResponse_treesInput = {
    id: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    parentId?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
    response_node_translations?: response_node_translationsUncheckedCreateNestedManyWithoutResponse_nodesInput
    other_response_nodes?: response_nodesUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_nodesInput
    response_tree_sessions?: response_tree_sessionsUncheckedCreateNestedManyWithoutResponse_nodesInput
  }

  export type response_nodesCreateOrConnectWithoutResponse_treesInput = {
    where: response_nodesWhereUniqueInput
    create: XOR<response_nodesCreateWithoutResponse_treesInput, response_nodesUncheckedCreateWithoutResponse_treesInput>
  }

  export type response_nodesCreateManyResponse_treesInputEnvelope = {
    data: response_nodesCreateManyResponse_treesInput | response_nodesCreateManyResponse_treesInput[]
    skipDuplicates?: boolean
  }

  export type response_tree_sessionsCreateWithoutResponse_treesInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_history?: response_tree_historyCreateNestedManyWithoutResponse_tree_sessionsInput
    response_tree_mobile_links?: response_tree_mobile_linksCreateNestedManyWithoutResponse_tree_sessionsInput
    response_nodes?: response_nodesCreateNestedOneWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsUncheckedCreateWithoutResponse_treesInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    currentNodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
    response_tree_history?: response_tree_historyUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput
    response_tree_mobile_links?: response_tree_mobile_linksUncheckedCreateNestedManyWithoutResponse_tree_sessionsInput
  }

  export type response_tree_sessionsCreateOrConnectWithoutResponse_treesInput = {
    where: response_tree_sessionsWhereUniqueInput
    create: XOR<response_tree_sessionsCreateWithoutResponse_treesInput, response_tree_sessionsUncheckedCreateWithoutResponse_treesInput>
  }

  export type response_tree_sessionsCreateManyResponse_treesInputEnvelope = {
    data: response_tree_sessionsCreateManyResponse_treesInput | response_tree_sessionsCreateManyResponse_treesInput[]
    skipDuplicates?: boolean
  }

  export type response_tree_versionsCreateWithoutResponse_treesInput = {
    id: string
    version: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_tree_versionsUncheckedCreateWithoutResponse_treesInput = {
    id: string
    version: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_tree_versionsCreateOrConnectWithoutResponse_treesInput = {
    where: response_tree_versionsWhereUniqueInput
    create: XOR<response_tree_versionsCreateWithoutResponse_treesInput, response_tree_versionsUncheckedCreateWithoutResponse_treesInput>
  }

  export type response_tree_versionsCreateManyResponse_treesInputEnvelope = {
    data: response_tree_versionsCreateManyResponse_treesInput | response_tree_versionsCreateManyResponse_treesInput[]
    skipDuplicates?: boolean
  }

  export type response_nodesUpsertWithWhereUniqueWithoutResponse_treesInput = {
    where: response_nodesWhereUniqueInput
    update: XOR<response_nodesUpdateWithoutResponse_treesInput, response_nodesUncheckedUpdateWithoutResponse_treesInput>
    create: XOR<response_nodesCreateWithoutResponse_treesInput, response_nodesUncheckedCreateWithoutResponse_treesInput>
  }

  export type response_nodesUpdateWithWhereUniqueWithoutResponse_treesInput = {
    where: response_nodesWhereUniqueInput
    data: XOR<response_nodesUpdateWithoutResponse_treesInput, response_nodesUncheckedUpdateWithoutResponse_treesInput>
  }

  export type response_nodesUpdateManyWithWhereWithoutResponse_treesInput = {
    where: response_nodesScalarWhereInput
    data: XOR<response_nodesUpdateManyMutationInput, response_nodesUncheckedUpdateManyWithoutResponse_treesInput>
  }

  export type response_tree_sessionsUpsertWithWhereUniqueWithoutResponse_treesInput = {
    where: response_tree_sessionsWhereUniqueInput
    update: XOR<response_tree_sessionsUpdateWithoutResponse_treesInput, response_tree_sessionsUncheckedUpdateWithoutResponse_treesInput>
    create: XOR<response_tree_sessionsCreateWithoutResponse_treesInput, response_tree_sessionsUncheckedCreateWithoutResponse_treesInput>
  }

  export type response_tree_sessionsUpdateWithWhereUniqueWithoutResponse_treesInput = {
    where: response_tree_sessionsWhereUniqueInput
    data: XOR<response_tree_sessionsUpdateWithoutResponse_treesInput, response_tree_sessionsUncheckedUpdateWithoutResponse_treesInput>
  }

  export type response_tree_sessionsUpdateManyWithWhereWithoutResponse_treesInput = {
    where: response_tree_sessionsScalarWhereInput
    data: XOR<response_tree_sessionsUpdateManyMutationInput, response_tree_sessionsUncheckedUpdateManyWithoutResponse_treesInput>
  }

  export type response_tree_versionsUpsertWithWhereUniqueWithoutResponse_treesInput = {
    where: response_tree_versionsWhereUniqueInput
    update: XOR<response_tree_versionsUpdateWithoutResponse_treesInput, response_tree_versionsUncheckedUpdateWithoutResponse_treesInput>
    create: XOR<response_tree_versionsCreateWithoutResponse_treesInput, response_tree_versionsUncheckedCreateWithoutResponse_treesInput>
  }

  export type response_tree_versionsUpdateWithWhereUniqueWithoutResponse_treesInput = {
    where: response_tree_versionsWhereUniqueInput
    data: XOR<response_tree_versionsUpdateWithoutResponse_treesInput, response_tree_versionsUncheckedUpdateWithoutResponse_treesInput>
  }

  export type response_tree_versionsUpdateManyWithWhereWithoutResponse_treesInput = {
    where: response_tree_versionsScalarWhereInput
    data: XOR<response_tree_versionsUpdateManyMutationInput, response_tree_versionsUncheckedUpdateManyWithoutResponse_treesInput>
  }

  export type response_tree_versionsScalarWhereInput = {
    AND?: response_tree_versionsScalarWhereInput | response_tree_versionsScalarWhereInput[]
    OR?: response_tree_versionsScalarWhereInput[]
    NOT?: response_tree_versionsScalarWhereInput | response_tree_versionsScalarWhereInput[]
    id?: StringFilter<"response_tree_versions"> | string
    treeId?: StringFilter<"response_tree_versions"> | string
    version?: IntFilter<"response_tree_versions"> | number
    snapshot?: JsonFilter<"response_tree_versions">
    createdAt?: DateTimeFilter<"response_tree_versions"> | Date | string
    createdBy?: StringNullableFilter<"response_tree_versions"> | string | null
    data?: JsonNullableFilter<"response_tree_versions">
  }

  export type TenantCreateWithoutService_usage_statisticsInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanCreateNestedManyWithoutTenantInput
    device_rooms?: device_roomsCreateNestedManyWithoutTenantInput
    pages?: pagesCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutService_usage_statisticsInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanUncheckedCreateNestedManyWithoutTenantInput
    device_rooms?: device_roomsUncheckedCreateNestedManyWithoutTenantInput
    pages?: pagesUncheckedCreateNestedManyWithoutTenantInput
    tenant_services?: tenant_servicesUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutService_usage_statisticsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutService_usage_statisticsInput, TenantUncheckedCreateWithoutService_usage_statisticsInput>
  }

  export type TenantUpsertWithoutService_usage_statisticsInput = {
    update: XOR<TenantUpdateWithoutService_usage_statisticsInput, TenantUncheckedUpdateWithoutService_usage_statisticsInput>
    create: XOR<TenantCreateWithoutService_usage_statisticsInput, TenantUncheckedCreateWithoutService_usage_statisticsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutService_usage_statisticsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutService_usage_statisticsInput, TenantUncheckedUpdateWithoutService_usage_statisticsInput>
  }

  export type TenantUpdateWithoutService_usage_statisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUpdateManyWithoutTenantNestedInput
    device_rooms?: device_roomsUpdateManyWithoutTenantNestedInput
    pages?: pagesUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutService_usage_statisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUncheckedUpdateManyWithoutTenantNestedInput
    device_rooms?: device_roomsUncheckedUpdateManyWithoutTenantNestedInput
    pages?: pagesUncheckedUpdateManyWithoutTenantNestedInput
    tenant_services?: tenant_servicesUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutTenant_servicesInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanCreateNestedManyWithoutTenantInput
    device_rooms?: device_roomsCreateNestedManyWithoutTenantInput
    pages?: pagesCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTenant_servicesInput = {
    id: string
    name: string
    domain?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    features?: TenantCreatefeaturesInput | string[]
    is_deleted?: boolean
    planType?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    TenantSystemPlan?: TenantSystemPlanUncheckedCreateNestedManyWithoutTenantInput
    device_rooms?: device_roomsUncheckedCreateNestedManyWithoutTenantInput
    pages?: pagesUncheckedCreateNestedManyWithoutTenantInput
    service_usage_statistics?: service_usage_statisticsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTenant_servicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTenant_servicesInput, TenantUncheckedCreateWithoutTenant_servicesInput>
  }

  export type TenantUpsertWithoutTenant_servicesInput = {
    update: XOR<TenantUpdateWithoutTenant_servicesInput, TenantUncheckedUpdateWithoutTenant_servicesInput>
    create: XOR<TenantCreateWithoutTenant_servicesInput, TenantUncheckedCreateWithoutTenant_servicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTenant_servicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTenant_servicesInput, TenantUncheckedUpdateWithoutTenant_servicesInput>
  }

  export type TenantUpdateWithoutTenant_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUpdateManyWithoutTenantNestedInput
    device_rooms?: device_roomsUpdateManyWithoutTenantNestedInput
    pages?: pagesUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTenant_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    features?: TenantUpdatefeaturesInput | string[]
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    planType?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    TenantSystemPlan?: TenantSystemPlanUncheckedUpdateManyWithoutTenantNestedInput
    device_rooms?: device_roomsUncheckedUpdateManyWithoutTenantNestedInput
    pages?: pagesUncheckedUpdateManyWithoutTenantNestedInput
    service_usage_statistics?: service_usage_statisticsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    taxAmount: number
    totalAmount: number
    status?: string
    dueDate?: Date | string | null
    issuedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    taxAmount: number
    totalAmount: number
    status?: string
    dueDate?: Date | string | null
    issuedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTransactionsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
  }

  export type PaymentCreateWithoutTransactionInput = {
    id?: string
    tenantId: string
    paymentMethod: string
    amount: number
    status?: string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTransactionInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    paymentMethod: string
    amount: number
    status?: string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentCreateOrConnectWithoutTransactionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
  }

  export type InvoiceUpsertWithoutTransactionsInput = {
    update: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PaymentUpsertWithoutTransactionInput = {
    update: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutTransactionInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    paymentId?: string | null
    type: string
    amount: number
    taxAmount?: number
    totalAmount: number
    status?: string
    description?: string | null
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    paymentId?: string | null
    type: string
    amount: number
    taxAmount?: number
    totalAmount: number
    status?: string
    description?: string | null
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionCreateManyInvoiceInputEnvelope = {
    data: TransactionCreateManyInvoiceInput | TransactionCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    paymentMethod: string
    amount: number
    status?: string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    transaction?: TransactionCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    transactionId?: string | null
    paymentMethod: string
    amount: number
    status?: string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionUpdateManyWithWhereWithoutInvoiceInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    type?: StringFilter<"Transaction"> | string
    amount?: IntFilter<"Transaction"> | number
    taxAmount?: IntFilter<"Transaction"> | number
    totalAmount?: IntFilter<"Transaction"> | number
    status?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    reference?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    createdBy?: StringNullableFilter<"Transaction"> | string | null
    isDeleted?: BoolFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    deletedBy?: StringNullableFilter<"Transaction"> | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    tenantId?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    paymentMethod?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    createdBy?: StringNullableFilter<"Payment"> | string | null
    isDeleted?: BoolFilter<"Payment"> | boolean
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    deletedBy?: StringNullableFilter<"Payment"> | string | null
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    taxAmount: number
    totalAmount: number
    status?: string
    dueDate?: Date | string | null
    issuedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    customerId?: string | null
    customerName: string
    customerEmail?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items: JsonNullValueInput | InputJsonValue
    subtotal: number
    taxAmount: number
    totalAmount: number
    status?: string
    dueDate?: Date | string | null
    issuedAt?: Date | string | null
    paidAt?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type TransactionCreateWithoutPaymentInput = {
    id?: string
    tenantId: string
    paymentId?: string | null
    type: string
    amount: number
    taxAmount?: number
    totalAmount: number
    status?: string
    description?: string | null
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutPaymentInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    paymentId?: string | null
    type: string
    amount: number
    taxAmount?: number
    totalAmount: number
    status?: string
    description?: string | null
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TransactionCreateOrConnectWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    items?: JsonNullValueInput | InputJsonValue
    subtotal?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type TransactionUpsertWithoutPaymentInput = {
    update: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPaymentInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    tenantId: string
    menuItemId: number
    name: string
    price: number
    quantity: number
    status?: string
    notes?: string | null
    deliveredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type OrderItemUpdateWithoutOrderInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
    menuItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    menuItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    menuItemId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantSystemPlanCreateManySystemPlanRestrictionsInput = {
    id: string
    tenantId: string
    systemType: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    monthlyPrice: number
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type TenantSystemPlanUpdateWithoutSystemPlanRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    Tenant?: TenantUpdateOneRequiredWithoutTenantSystemPlanNestedInput
  }

  export type TenantSystemPlanUncheckedUpdateWithoutSystemPlanRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantSystemPlanUncheckedUpdateManyWithoutSystemPlanRestrictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantSystemPlanCreateManyTenantInput = {
    id: string
    systemType: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    monthlyPrice: number
    createdAt?: Date | string
    updatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type device_roomsCreateManyTenantInput = {
    id?: number
    roomId: string
    roomName?: string | null
    deviceId?: string | null
    deviceType?: string | null
    placeId?: string | null
    status?: string | null
    ipAddress?: string | null
    macAddress?: string | null
    lastUsedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    is_deleted?: boolean
    deleted_at?: Date | string | null
    deleted_by?: string | null
  }

  export type pagesCreateManyTenantInput = {
    Id: string
    Slug: string
    Title: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    IsPublished?: boolean
    PublishedAt?: Date | string | null
    Version?: number
    CreatedAt?: Date | string
    UpdatedAt: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type service_usage_statisticsCreateManyTenantInput = {
    id: string
    service_type: string
    month: string
    active_users_count?: number
    active_devices_count?: number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tenant_servicesCreateManyTenantInput = {
    id: string
    service_type: string
    plan_type: string
    is_active?: boolean
    activated_at?: Date | string
    expires_at?: Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TenantSystemPlanUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    SystemPlanRestrictions?: SystemPlanRestrictionsUpdateOneRequiredWithoutTenantSystemPlanNestedInput
  }

  export type TenantSystemPlanUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantSystemPlanUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemType?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type device_roomsUpdateWithoutTenantInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type device_roomsUncheckedUpdateWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: StringFieldUpdateOperationsInput | string
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type device_roomsUncheckedUpdateManyWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: StringFieldUpdateOperationsInput | string
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    macAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pagesUpdateWithoutTenantInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    IsPublished?: BoolFieldUpdateOperationsInput | boolean
    PublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    page_histories?: page_historiesUpdateManyWithoutPagesNestedInput
  }

  export type pagesUncheckedUpdateWithoutTenantInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    IsPublished?: BoolFieldUpdateOperationsInput | boolean
    PublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    page_histories?: page_historiesUncheckedUpdateManyWithoutPagesNestedInput
  }

  export type pagesUncheckedUpdateManyWithoutTenantInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Slug?: StringFieldUpdateOperationsInput | string
    Title?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    IsPublished?: BoolFieldUpdateOperationsInput | boolean
    PublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type service_usage_statisticsUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    active_users_count?: IntFieldUpdateOperationsInput | number
    active_devices_count?: IntFieldUpdateOperationsInput | number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_usage_statisticsUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    active_users_count?: IntFieldUpdateOperationsInput | number
    active_devices_count?: IntFieldUpdateOperationsInput | number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_usage_statisticsUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    active_users_count?: IntFieldUpdateOperationsInput | number
    active_devices_count?: IntFieldUpdateOperationsInput | number
    usage_data?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenant_servicesUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    activated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenant_servicesUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    activated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tenant_servicesUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    plan_type?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    activated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service_config?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_logCreateManyAdminInput = {
    id: string
    action: string
    target_type?: string | null
    target_id?: string | null
    ip_address?: string | null
    user_agent?: string | null
    success?: boolean
    error_message?: string | null
    created_at?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type admin_logUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_logUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_logUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target_type?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_category_relationsCreateManyCampaign_categoriesInput = {
    id: string
    campaignId: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_category_relationsUpdateWithoutCampaign_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaigns?: campaignsUpdateOneRequiredWithoutCampaign_category_relationsNestedInput
  }

  export type campaign_category_relationsUncheckedUpdateWithoutCampaign_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_category_relationsUncheckedUpdateManyWithoutCampaign_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_category_relationsCreateManyCampaignsInput = {
    id: string
    categoryId: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_itemsCreateManyCampaignsInput = {
    id: string
    itemId: string
    itemType: string
    priority?: number
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_translationsCreateManyCampaignsInput = {
    id: string
    locale: string
    title: string
    description?: string | null
    imageUrl?: string | null
    languageCode?: string | null
    name?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_usage_logsCreateManyCampaignsInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    action: string
    createdAt?: Date | string
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type campaign_category_relationsUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    campaign_categories?: campaign_categoriesUpdateOneRequiredWithoutCampaign_category_relationsNestedInput
  }

  export type campaign_category_relationsUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_category_relationsUncheckedUpdateManyWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_itemsUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_itemsUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_itemsUncheckedUpdateManyWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_translationsUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_translationsUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_translationsUncheckedUpdateManyWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_usage_logsUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_usage_logsUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type campaign_usage_logsUncheckedUpdateManyWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reservationsCreateManyCustomersInput = {
    id: string
    tenant_id: string
    guest_name: string
    guest_phone?: string | null
    guest_email?: string | null
    checkin_date: Date | string
    checkout_date: Date | string
    adult_count?: number
    child_count?: number
    room_type: string
    room_number?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    deposit_amount?: Decimal | DecimalJsLike | number | string
    status?: string
    origin: string
    ota_id?: string | null
    confirmation_number: string
    special_requests?: string | null
    internal_notes?: string | null
    origin_system?: string
    synced_at?: Date | string
    updated_by_system?: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    is_deleted?: boolean
    deleted_by?: string | null
  }

  export type reservationsUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    guest_name?: StringFieldUpdateOperationsInput | string
    guest_phone?: NullableStringFieldUpdateOperationsInput | string | null
    guest_email?: NullableStringFieldUpdateOperationsInput | string | null
    checkin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adult_count?: IntFieldUpdateOperationsInput | number
    child_count?: IntFieldUpdateOperationsInput | number
    room_type?: StringFieldUpdateOperationsInput | string
    room_number?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    ota_id?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_number?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationsUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    guest_name?: StringFieldUpdateOperationsInput | string
    guest_phone?: NullableStringFieldUpdateOperationsInput | string | null
    guest_email?: NullableStringFieldUpdateOperationsInput | string | null
    checkin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adult_count?: IntFieldUpdateOperationsInput | number
    child_count?: IntFieldUpdateOperationsInput | number
    room_type?: StringFieldUpdateOperationsInput | string
    room_number?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    ota_id?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_number?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationsUncheckedUpdateManyWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    guest_name?: StringFieldUpdateOperationsInput | string
    guest_phone?: NullableStringFieldUpdateOperationsInput | string | null
    guest_email?: NullableStringFieldUpdateOperationsInput | string | null
    checkin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkout_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adult_count?: IntFieldUpdateOperationsInput | number
    child_count?: IntFieldUpdateOperationsInput | number
    room_type?: StringFieldUpdateOperationsInput | string
    room_number?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    ota_id?: NullableStringFieldUpdateOperationsInput | string | null
    confirmation_number?: StringFieldUpdateOperationsInput | string
    special_requests?: NullableStringFieldUpdateOperationsInput | string | null
    internal_notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_system?: StringFieldUpdateOperationsInput | string
    synced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_by_system?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type page_historiesCreateManyPagesInput = {
    Id: string
    Html?: string | null
    Css?: string | null
    Content?: string | null
    Template?: string | null
    Version: number
    CreatedAt?: Date | string
    CreatedBy?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type page_historiesUpdateWithoutPagesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type page_historiesUncheckedUpdateWithoutPagesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type page_historiesUncheckedUpdateManyWithoutPagesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Html?: NullableStringFieldUpdateOperationsInput | string | null
    Css?: NullableStringFieldUpdateOperationsInput | string | null
    Content?: NullableStringFieldUpdateOperationsInput | string | null
    Template?: NullableStringFieldUpdateOperationsInput | string | null
    Version?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type response_node_translationsCreateManyResponse_nodesInput = {
    id: string
    locale: string
    content?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: string | null
    title?: string | null
    deleted_at?: Date | string | null
    deleted_by?: string | null
    is_deleted?: boolean
  }

  export type response_nodesCreateManyResponse_nodesInput = {
    id: string
    treeId: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
  }

  export type response_tree_historyCreateManyResponse_nodesInput = {
    id: string
    sessionId: string
    response?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    action?: string | null
    timestamp?: Date | string
  }

  export type response_tree_sessionsCreateManyResponse_nodesInput = {
    id: string
    treeId: string
    userId?: string | null
    deviceId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
  }

  export type response_node_translationsUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type response_node_translationsUncheckedUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type response_node_translationsUncheckedUpdateManyWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    language?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type response_nodesUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUpdateManyWithoutResponse_nodesNestedInput
    other_response_nodes?: response_nodesUpdateManyWithoutResponse_nodesNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUncheckedUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUncheckedUpdateManyWithoutResponse_nodesNestedInput
    other_response_nodes?: response_nodesUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUncheckedUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUncheckedUpdateManyWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type response_tree_historyUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    response_tree_sessions?: response_tree_sessionsUpdateOneRequiredWithoutResponse_tree_historyNestedInput
  }

  export type response_tree_historyUncheckedUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type response_tree_historyUncheckedUpdateManyWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type response_tree_sessionsUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_tree_mobile_links?: response_tree_mobile_linksUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_trees?: response_treesUpdateOneRequiredWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_sessionsUncheckedUpdateWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_tree_mobile_links?: response_tree_mobile_linksUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_sessionsUncheckedUpdateManyWithoutResponse_nodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    treeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type response_tree_historyCreateManyResponse_tree_sessionsInput = {
    id: string
    nodeId: string
    response?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    action?: string | null
    timestamp?: Date | string
  }

  export type response_tree_mobile_linksCreateManyResponse_tree_sessionsInput = {
    id: string
    code: string
    qrCodeData?: string | null
    isActive?: boolean
    connectionId?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    connectedAt?: Date | string | null
    deviceId?: number | null
  }

  export type response_tree_historyUpdateWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    response_nodes?: response_nodesUpdateOneRequiredWithoutResponse_tree_historyNestedInput
  }

  export type response_tree_historyUncheckedUpdateWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type response_tree_historyUncheckedUpdateManyWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type response_tree_mobile_linksUpdateWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type response_tree_mobile_linksUncheckedUpdateWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type response_tree_mobile_linksUncheckedUpdateManyWithoutResponse_tree_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type response_nodesCreateManyResponse_treesInput = {
    id: string
    nodeType: string
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: boolean
    parentId?: string | null
    position?: number
    createdAt?: Date | string
    updatedAt: Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    icon?: string | null
    order?: number
    title?: string | null
    type?: string | null
  }

  export type response_tree_sessionsCreateManyResponse_treesInput = {
    id: string
    userId?: string | null
    deviceId?: string | null
    currentNodeId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: boolean
    startedAt?: Date | string
    updatedAt: Date | string
    completedAt?: Date | string | null
    endedAt?: Date | string | null
    interfaceType?: string | null
    language?: string | null
    lastActivityAt?: Date | string | null
    roomId?: string | null
    sessionId: string
  }

  export type response_tree_versionsCreateManyResponse_treesInput = {
    id: string
    version: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdBy?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_nodesUpdateWithoutResponse_treesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUpdateManyWithoutResponse_nodesNestedInput
    response_nodes?: response_nodesUpdateOneWithoutOther_response_nodesNestedInput
    other_response_nodes?: response_nodesUpdateManyWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUncheckedUpdateWithoutResponse_treesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    response_node_translations?: response_node_translationsUncheckedUpdateManyWithoutResponse_nodesNestedInput
    other_response_nodes?: response_nodesUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_nodesNestedInput
    response_tree_sessions?: response_tree_sessionsUncheckedUpdateManyWithoutResponse_nodesNestedInput
  }

  export type response_nodesUncheckedUpdateManyWithoutResponse_treesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeType?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRoot?: BoolFieldUpdateOperationsInput | boolean
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type response_tree_sessionsUpdateWithoutResponse_treesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_history?: response_tree_historyUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_tree_mobile_links?: response_tree_mobile_linksUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_nodes?: response_nodesUpdateOneWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_sessionsUncheckedUpdateWithoutResponse_treesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    response_tree_history?: response_tree_historyUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput
    response_tree_mobile_links?: response_tree_mobile_linksUncheckedUpdateManyWithoutResponse_tree_sessionsNestedInput
  }

  export type response_tree_sessionsUncheckedUpdateManyWithoutResponse_treesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    currentNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interfaceType?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
  }

  export type response_tree_versionsUpdateWithoutResponse_treesInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_tree_versionsUncheckedUpdateWithoutResponse_treesInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type response_tree_versionsUncheckedUpdateManyWithoutResponse_treesInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionCreateManyInvoiceInput = {
    id?: string
    tenantId: string
    paymentId?: string | null
    type: string
    amount: number
    taxAmount?: number
    totalAmount: number
    status?: string
    description?: string | null
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    tenantId: string
    transactionId?: string | null
    paymentMethod: string
    amount: number
    status?: string
    reference?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TransactionUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    taxAmount?: IntFieldUpdateOperationsInput | number
    totalAmount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemPlanRestrictionsCountOutputTypeDefaultArgs instead
     */
    export type SystemPlanRestrictionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemPlanRestrictionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminCountOutputTypeDefaultArgs instead
     */
    export type AdminCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Campaign_categoriesCountOutputTypeDefaultArgs instead
     */
    export type Campaign_categoriesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Campaign_categoriesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignsCountOutputTypeDefaultArgs instead
     */
    export type CampaignsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomersCountOutputTypeDefaultArgs instead
     */
    export type CustomersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PagesCountOutputTypeDefaultArgs instead
     */
    export type PagesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PagesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Response_nodesCountOutputTypeDefaultArgs instead
     */
    export type Response_nodesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Response_nodesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Response_tree_sessionsCountOutputTypeDefaultArgs instead
     */
    export type Response_tree_sessionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Response_tree_sessionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Response_treesCountOutputTypeDefaultArgs instead
     */
    export type Response_treesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Response_treesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DatabaseChangeLogDefaultArgs instead
     */
    export type DatabaseChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DatabaseChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemPlanRestrictionsDefaultArgs instead
     */
    export type SystemPlanRestrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemPlanRestrictionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantSystemPlanDefaultArgs instead
     */
    export type TenantSystemPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantSystemPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use adminDefaultArgs instead
     */
    export type adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = adminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use admin_logDefaultArgs instead
     */
    export type admin_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = admin_logDefaultArgs<ExtArgs>
    /**
     * @deprecated Use campaign_categoriesDefaultArgs instead
     */
    export type campaign_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = campaign_categoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use campaign_category_relationsDefaultArgs instead
     */
    export type campaign_category_relationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = campaign_category_relationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use campaign_itemsDefaultArgs instead
     */
    export type campaign_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = campaign_itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use campaign_translationsDefaultArgs instead
     */
    export type campaign_translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = campaign_translationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use campaign_usage_logsDefaultArgs instead
     */
    export type campaign_usage_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = campaign_usage_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use campaignsDefaultArgs instead
     */
    export type campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = campaignsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use customersDefaultArgs instead
     */
    export type customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = customersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use device_roomsDefaultArgs instead
     */
    export type device_roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = device_roomsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use device_video_cachesDefaultArgs instead
     */
    export type device_video_cachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = device_video_cachesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notification_templatesDefaultArgs instead
     */
    export type notification_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notification_templatesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use page_historiesDefaultArgs instead
     */
    export type page_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = page_historiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pagesDefaultArgs instead
     */
    export type pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reservationsDefaultArgs instead
     */
    export type reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reservationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use response_node_translationsDefaultArgs instead
     */
    export type response_node_translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = response_node_translationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use response_nodesDefaultArgs instead
     */
    export type response_nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = response_nodesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use response_tree_historyDefaultArgs instead
     */
    export type response_tree_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = response_tree_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use response_tree_mobile_linksDefaultArgs instead
     */
    export type response_tree_mobile_linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = response_tree_mobile_linksDefaultArgs<ExtArgs>
    /**
     * @deprecated Use response_tree_sessionsDefaultArgs instead
     */
    export type response_tree_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = response_tree_sessionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use response_tree_versionsDefaultArgs instead
     */
    export type response_tree_versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = response_tree_versionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use response_treesDefaultArgs instead
     */
    export type response_treesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = response_treesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use room_gradesDefaultArgs instead
     */
    export type room_gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = room_gradesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use schema_versionDefaultArgs instead
     */
    export type schema_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = schema_versionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use service_plan_restrictionsDefaultArgs instead
     */
    export type service_plan_restrictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = service_plan_restrictionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use service_usage_statisticsDefaultArgs instead
     */
    export type service_usage_statisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = service_usage_statisticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use staffDefaultArgs instead
     */
    export type staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = staffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use system_eventDefaultArgs instead
     */
    export type system_eventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = system_eventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tenant_access_logsDefaultArgs instead
     */
    export type tenant_access_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tenant_access_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tenant_servicesDefaultArgs instead
     */
    export type tenant_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tenant_servicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use checkin_sessionsDefaultArgs instead
     */
    export type checkin_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = checkin_sessionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use session_billingsDefaultArgs instead
     */
    export type session_billingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = session_billingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}